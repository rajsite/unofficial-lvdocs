<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Shared_Libraries_DLLs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Debugging Shared Libraries and Calls to Shared Libraries</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Debugging_DLLs_and_Calls_to_DLLs"></a><h1>Debugging Shared Libraries and Calls to Shared Libraries</h1>
<p class="Body">
				 When you debug your LabVIEW calls to shared libraries, you must be prepared to trace problems in the shared library you are calling and in the implementation of the <a href="Configuring_the_CLF_Node.html">Call Library Function Node</a> in LabVIEW.</p><a name="Troubleshooting_the_Call_Library_Function_Node"></a><h2>Troubleshooting the Call Library Function Node</h2>
<p class="Body">When the LabVIEW calls to shared libraries generate errors, check for the following problems in your use of the Call Library Function Node:</p>
<ul>
<li>Verify the Call Library Function Node has the correct name or path for the shared library. Also ensure that you <a href="../lvexcodeconcepts/locations_for_shared_libraries.html">specify the location on disk appropriately</a> for your use case. Some use cases require you to specify the shared library by path, and other use cases require you to specify the shared library by name.</li>
<li>For LabVIEW-built shared libraries, make sure the computer <a href="../lvconcepts/Using_the_LV_Run_Time_Eng.html">has a version of the LabVIEW Run-Time Engine that is compatible</a> with each version of LabVIEW used to create the shared libraries.</li>
<li>If you receive the error message <span class="Monospace">Function not found in library</span>, verify the Call Library Function Node has the correct spelling, syntax, and case sensitivity for the function name that you are calling.</li>
<li>Be sure that the compiler has <a href="../lvhowto/Building_Function_Prototype.html">not decorated</a> the function.</li>
<li>If you receive an error message that a secondary shared library cannot be found, yet you	properly specified the path to the primary shared library in the Call Library Function Node, the primary shared library needs additional functions from one or more other shared libraries. You need to find the other shared libraries and place them in the same directory as the shared library that needs them or in a directory that is in the search path. Refer to the KnowledgeBase at <a href="javascript:WWW(WWW_Sec_DLL)">ni.com</a> for more information.</li>
<li>If your VI crashes, verify that return types and data types of arguments for functions in the Call Library Function Node exactly match the data types your function uses. Also, verify the <a href="../glang/Call_Library_Function.html">Call Library Function Node</a> uses the proper calling convention (C or <span class="Monospace">__stdcall</span>) using the Error Checking Level tab in the <a href="../lvdialog/Call_Lib_Function_DB.html">Call Library Function</a> dialog box.</li>
<li>Verify that all the parameters are defined to be passed by the correct method, such as value or pointer. Also, verify the Call Library Function Node passes arguments to the function in the correct order.</li>
<li>For arrays or strings of data, always pass a buffer or array that is large enough to hold any results that the function places in the buffer. However, if you are passing them as LabVIEW handles, use <a href="../lvexcode/LabVIEW_Manager_Functions.html">LabVIEW Manager functions</a> to resize them under Visual C++ or Xcode compilers.</li>
<li>If you receive a message, the cause is almost always an error in the code of the shared library, such as writing past the end of the memory allocated for an array. Notice that these kinds of crashes might or might not occur at the time the shared library call actually executes on the block diagram.</li>
<li>Use the <a href="../lvcomm/Automation_Open.html">Automation Open</a> function with the <a href="../glang/Property_Node.html">Property Node</a> and the <a href="../glang/Invoke_Node.html">Invoke Node</a> instead of the Call Library Function Node if you want to call a shared library that contains <a href="../lvhowto/ActiveX_Container.html">ActiveX</a> objects.</li>
<li>All calls to LabVIEW-built shared libraries should specify <strong>Run in any thread</strong>. If you configure the Call Library Function Node using LabVIEW-built shared libraries and specify <strong>Run in UI thread</strong>, LabVIEW might hang and require you to restart.</li>
<li>Pascal strings do not exceed 255 characters in length.</li>
<li>Resizing of arrays and strings can take place only when the Call Library Function Node passes a LabVIEW array handle or LabVIEW string handle. Resize arrays and strings using functions exported through <span class="Monospace">labviewv.lib</span> to a Visual C++ project, and <span class="Monospace">liblvexports.a</span> to an Xcode project</li>
<li>Remember that C strings are <span class="Monospace">NULL</span> terminated. If your DLL function returns numeric data in a binary string format, for example, through GPIB or the serial port, it might return <span class="Monospace">NULL</span> values as part of the data string. </li>
</ul><a name="Troubleshooting_your_DLL"></a><h2>Troubleshooting Your Shared Library</h2>
<p class="Body">Check for the following problems in your shared library when LabVIEW calls to shared libraries generate errors:</p>
<ul>
<li>Verify that shared library functions that other applications call appear in the module definition file <span class="Monospace">EXPORTS</span> section, or you include the <span class="Monospace">_declspec (dllexport)</span> keyword in the function declaration. Keep the C++ compiler from introducing platform dependence in exported function names through a process called name mangling by using the C++ compiler function export directive, extern "C"{}, in your header file, as shown in the following example code: 
					<br><br><p class="code"><span class="Monospace">extern "C" {</span></p>
<p class="code"><span class="Monospace">/* your function prototypes here */ </span></p>
<p class="code"><span class="Monospace">}</span></p>
</li>
<li>Remember that you need to declare the function with the <span class="Monospace">_declspec (dllexport)</span> keyword in the header file and the source code, or define it in the <span class="Monospace">EXPORTS</span> section of the module definition file. </li>
<li>When you use the <span class="Monospace">_declspec (dllexport)</span> keyword and you are also using the <span class="Monospace">__stdcall</span> calling convention, you must declare the shared library function name in the <span class="Monospace">EXPORTS</span> section of the module definition (<span class="Monospace">.def</span>) file. In the absence of a <span class="Monospace">.def</span> file, <span class="Monospace">__stdcall</span> might truncate function names in an unpredictable pattern, so the actual function name is unavailable to applications that call the shared library.</li>
<li>When a function has not been properly exported, you must recompile the shared library. Never recompile the shared library while the shared library is loaded into memory by another application, for example, by your VI. Before recompiling a shared library, make sure that all applications making use of the shared library are unloaded from memory. This ensures that the shared library itself is not loaded into memory during a recompile. The shared library might fail to rebuild correctly if you forget this point and your compiler does not warn you. However, most compilers warn you when the shared library is in use by an application.</li>
<li>Try to debug the shared library by using the source level debugger provided with your compiler. Using the debugger of your compiler, you can set breakpoints, step through your code, watch the values of the variables, and so on. Debugging using conventional tools can be extremely beneficial. Refer to the appropriate manual	for your compiler for more information about debugging.</li>
<li>Calling the shared library from another C program is also another way to debug the shared library. By calling the shared library from another C program, you have a means of testing the shared library independent of LabVIEW, thus helping you to identify any problems, sooner.</li>
<li>When calling a LabVIEW shared library that passes a 2D array, you must first declare the handler variable and initialize the variable to <span class="Monospace">NULL</span>, as shown in the following C code: 
					<br><br><p class="code"><span class="Monospace">main ( ) </span></p>
<p class="code"><span class="Monospace">{</span></p>
<p class="code"><span class="Monospace">�������/*LabVIEW data handler variable for the array */</span></p>
<p class="code"><span class="Monospace">�������TD1Hd1myArray = NULL;</span></p>
<p class="code"><span class="Monospace">�������...</span></p>
<p class="code"><span class="Monospace">�������/* Call to the LabVIEW shared library function */ </span></p>
<p class="code"><span class="Monospace">�������DLLFunctionalCall(&amp;myArray);</span></p>
<p class="code"><span class="Monospace">�������...</span></p>
<p class="code"><span class="Monospace">}</span></p>
					<br><br>If you do not initialize the handler variable to <span class="Monospace">NULL</span>, the code produces a <span class="Monospace">General Protection Fault</span> when you call the shared library.
				</li>
<li>
					To allow LabVIEW shared library functions to execute without interruption, LabVIEW delays the processing of operating system messages until the end of any calls to shared library functions or until you load a modal window from the shared library. Delaying the operating system messages, such as keyboard messages from the users, is useful in order to avoid calling the same shared library file while a shared library function runs. For example, if the shared library function is called in response to the user pressing a button, the user should not be able to press the button again until the shared library function has completed. When LabVIEW delays the processing of operating system messages, all function calls to the same LabVIEW shared library are put into a queue. That queue will be executed after the original shared library function call completes. A <em>modal</em> window is a type of window that remains active or remains on top of all other LabVIEW windows until you close the window or open another modal window. If you load a modal window from the shared library, LabVIEW overrides the process delay and processes the messages to allow the modal window to become active.  You cannot interact with other windows while a modal window is open. Most dialog boxes in LabVIEW are modal windows. You cannot open a non-modal window from a LabVIEW callback VI nor a shared library while any other process is running. If you want your callback VI or shared library to call a non-modal window, you must do so programmatically by completing the steps outlined in the <a href="../lvconcepts/CallbackVIs.html">Callback VIs</a> topic. </li>
<li>
					
					You can choose whether to delay operating system messages in shared libraries that you build. Before building the shared library, navigate to the <strong>Advanced</strong> page of the <a href="../lvdialog/DLL_Settings_DB.html">Shared Library Properties</a> dialog box and remove the checkmark from the <strong>Delay operating system messages in shared library</strong> checkbox to process operating system messages while shared library functions run.</li>
<li>
					The following scenarios might cause the <span class="Monospace">No debuggable applications or runtime libraries found</span> error to appear.
					<ul>
<li>The debuggable shared library was not loaded or was unloaded by the application.</li>
<li>The configuration (<span class="Monospace">ini</span>) file of the shared library, created by the Application Builder, was not distributed with the shared library.</li>
</ul>
					
				</li>
</ul>
</body>
</html>