<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Shared_Libraries_DLLs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Using Arrays and Strings in the Call Library Function Node</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Array_and_String_Options"></a><h1>Using Arrays and Strings in the Call Library Function Node</h1>
<p class="Body">
				
				This section reviews important concepts regarding array and string data in the <a href="Configuring_the_CLF_Node.html">Call Library Function Node</a>.</p>
<p class="Body">
				<span class="Platform">(Windows)</span> Refer to the <span class="Monospace">labview\examples\Connectivity\Libraries and Executables\Libraries and Executables.lvproj</span> for an example of using arrays and strings in shared libraries (DLLs).</p>
<p class="Body">
				<a href="javascript:openProj('examples%5C%5CConnectivity%5C%5CLibraries%20and%20Executables%5C%5CLibraries%20and%20Executables.lvproj');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		�<a href="javascript:findExamples(3769);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples
			</p><a name="Arrays_of_Numeric_Data"></a><h2>Arrays of Numeric Data</h2>
<p class="Body">Arrays of numeric data can be comprised of any type of integers or floating point numbers with single (4-byte) or double (8-byte) precision. When you pass an array of data to a shared library function, you can pass the data as an array data pointer, as a LabVIEW array handle, or as a LabVIEW array handle pointer.</p>
<p class="Body">Array Data Pointers have the following characteristics whether you pass the Array Data Pointers in the Windows API or in another API:</p>
<ul>
<li>You can set the number of dimensions in the array, but you must not include information about the size of the array dimension(s). Instead, you must pass the size of the array dimension(s) information to your shared library in a separate variable. </li>
<li>Never resize an array or perform operations that might change the length of the array data passed from LabVIEW. Resizing might cause a crash because the pointer sent is not an allocated block but points into the middle of an allocated block. </li>
<li>To return an array of data, you should allocate an array of sufficient size in LabVIEW, pass the array to your function, and have this array act as the buffer. If the data takes less space, you can return the correct size as a separate parameter and then, on the calling diagram, use array subset to extract the valid data. </li>
</ul>
<p class="Body">Remember that the Windows API does not use LabVIEW array handles, so with functions that are part of the Windows API you can use only Array Data Pointers. </p>
<p class="Body">If you pass the array data as a LabVIEW array handle, you can use LabVIEW <a href="../lvexcode/LabVIEW_Manager_Functions.html">LabVIEW Manager</a> functions, such as <a href="../lvexcode/numericarrayresize.html">NumericArrayResize</a>, to resize the handle. If you need to resize a handle to an array of strings or clusters, consider <a href="../lvexcodeconcepts/Array_and_String_Options.html#Alignment_Considerations">alignment on different platforms</a>.
</p><a name="String_Data"></a><h2>String Data</h2>
<p class="Body">The types of your string pointers must match the types of string pointers that your function uses, or errors occur. The Call Library Function Node offers the following choices:</p>
<ul>
<li>
					<strong>C String Pointer</strong> is a pointer to the string, followed by a NULL character. Most Win32 API functions use this C-style string pointer.</li>
<li>
					<strong>Pascal String Pointer</strong> is a pointer to the string, preceded by a length byte. </li>
<li>
					<strong>LabVIEW String Handle</strong> is a pointer to a pointer to the string, preceded by four bytes of length information. </li>
<li>
					<strong>LabVIEW String Handle Pointer</strong> is a pointer to a handle for a string, preceded by four bytes of length information. </li>
</ul>
<p class="Body">You can think of a string as an array of characters. Assembling the characters in order forms a string. LabVIEW stores a string in a special format in which the first four bytes of the array of characters form a 32-bit signed integer that stores how many characters appear in the string. Thus, a string with <em>n</em> characters requires <em>n</em> + 4 bytes to store in memory. For example, in the following illustration, the string <span class="Monospace">text</span> contains four characters.</p>
<p class="Anchor"><img src="loc_eps_stringformat.gif"></p>
<p class="Body">When LabVIEW stores the string, the first four bytes contain the value <span class="Monospace">4</span> as a 32-bit signed number, and each of the following four bytes contains a character of the string. The advantage of this type of string storage is that NULL characters are allowed in the string. Strings are virtually unlimited in length, up to 2<sup>31</sup> characters. This method of string storage is shown in the previous illustration. If you pass a LabVIEW string handle from the Call Library Function Node to the shared library, then you can use the LabVIEW Manager functions, such as <span class="Monospace">DSSetHandleSize</span>, to <a href="../lvexcodeconcepts/Array_and_String_Options.html#Alignment_Considerations">resize the LabVIEW string handle</a>. </p>
<p class="Body">The Pascal string format is nearly identical to the LabVIEW string format, but instead of storing the length of the string as a 32-bit signed integer, the string length is stored as an 8-bit unsigned integer. Storing the string length as an 8-bit unsigned integer limits the length of a Pascal-style string to 255 characters. A Pascal string that is <em>n</em> characters long will require <em>n</em> + 1 bytes of memory to store. The following illustrations shows a Pascal string.</p>
<p class="Anchor"><img src="loc_eps_pascalstringformat.gif"></p>
<p class="Body">C strings are probably the type of strings you will deal with most commonly. The similarities between the C-style string and normal numeric arrays in C becomes much more clear when you see that C strings are declared as <span class="Monospace">char*</span>, where <span class="Monospace">char</span> is typically an 8-bit unsigned integer. Unlike LabVIEW and Pascal strings, C strings do not contain any information that directly gives the length of the string. Instead, C strings use	a special character called the NULL character to indicate the end of the string. NULL is defined to have a value of zero in the ASCII character set. Notice that NULL is the number zero and not the character �<span class="Monospace">0.</span>� Thus, in C, a string that contains <em>n</em> characters requires <em>n</em> + 1 bytes of memory to store: n bytes for the characters in the string and one additional byte for the NULL termination character. The following illustration shows how a C-style string is stored in memory.</p>
<p class="Anchor"><img src="loc_eps_cstringformat.gif"></p>
<p class="Body">The advantage of C-style strings is that they are limited in size only by available memory. However, if you are acquiring data from an instrument that returns 	numeric data as a binary string, as is common with serial or GPIB instruments, values of zero in the string are possible. If you treat the string as a C-style string, your program incorrectly assumes that the end of the string has been reached, when in fact your instrument is returning a numeric value of zero. For binary data that might contain NULL values, consider using an array of 8-bit unsigned integers.</p>
<p class="Body">Observe the following guidelines when passing string data to a shared library:</p>
<ul>
<li>Never resize a string, concatenate a string, or perform operations that might increase the length of string data passed from LabVIEW if you are using the C or Pascal string pointers.</li>
<li>If you must return data as a string, allocate a string of the appropriate length in LabVIEW and pass this string into the shared library to act as a buffer. <br><br>You can specify the string size and allocate the correct amount of memory with the <strong>Minimum size</strong> control on the <strong>Parameters</strong> tab of the <a href="../lvdialog/Call_Lib_Function_DB.html">Call Library Function</a> dialog box. If you pass in a string that is smaller than the <strong>Minimum size</strong>, LabVIEW enlarges the size of the string to the minimum.
				</li>
<li>If you pass a LabVIEW string handle from the Call Library Function Node to the shared library, you can use the <a href="../lvexcode/LabVIEW_Manager_Functions.html">LabVIEW Manager</a> functions, such as <a href="../lvexcode/azsethandlesize_dssethandlesize.html">DSSetHandleSize</a>, to resize the LabVIEW string handle. Consider <a href="../lvexcodeconcepts/Array_and_String_Options.html#Alignment_Considerations">alignment on different platforms</a> before resizing the string handle.
				</li>
</ul><a name="Alignment_Considerations"></a><h2>Determining When to Resize Array and String Handles in Shared Libraries</h2>
<p class="Body">
    
When a shared library function increases the size of a string or array that you passed by handle, you need to adjust the size of the handle that references the data. You can adjust the handle size using the <a href="Memory_Manager.html">memory manager</a> routine <a href="../lvexcode/azsethandlesize_dssethandlesize.html"><span class="Monospace">DSSetHandleSize</span></a>. Because this routine requires you to calculate the size of the new memory space, you must account for platform-dependent requirements about how you align and pad memory. A piece of data is aligned if it falls on a boundary equal to a multiple of its size. For example, a 2-byte value is at a memory address that is a multiple of 2 and a 4-byte value is at a memory address that is a multiple of 4. On Intel processors the maximum alignment is 4.</p>
<p class="Body">The following examples highlight alignment differences on various platforms for a three-dimensional array of clusters, with each cluster containing a double-precision, floating-point number and a 1-byte Boolean:</p>
<ul>
<li><span class="Platform">(Windows)</span> The first twelve bytes describe the size of each dimension of the array (four bytes per dimension). Cluster elements follow, with each cluster element consisting of an 8-byte double-precision floating-point number followed by a 1-byte Boolean. LabVIEW ignores alignment on Windows.</li>
<li><span class="Platform">(64-bit LabVIEW running on Windows)</span> The first twelve bytes describe the size of each dimension of the array (four bytes per dimension) followed by four bytes of padding. Cluster elements follow, with each cluster element consisting of an 8-byte double-precision floating-point number followed by a 1-byte Boolean and seven bytes of padding.</li>
<li><span class="Platform">(OS X and Linux)</span> The first twelve bytes describe the size of each dimension of the array (four bytes per dimension). Cluster elements follow, with each cluster element consisting of an 8-byte double-precision floating-point number followed by a 1-byte Boolean and three bytes of padding.</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Although you must use <span class="Monospace">DSSetHandleSize</span> to resize a string or an array of arbitrary data type, you can use the <a href="../lvexcode/numericarrayresize.html"><span class="Monospace">NumericArrayResize</span></a> manager routine to resize arrays of numeric data. <span class="Monospace">NumericArrayResize</span> automatically accounts for platform-dependent alignment requirements.</td>
</tr>
</table><br><br>Learn about <a href="../lvconcepts/How_LabVIEW_Stores_Data_in_Memory.html">how LabVIEW stores data in memory</a> to calculate the size of array elements, especially for arbitrary data types such as <a href="../lvconcepts/How_LabVIEW_Stores_Data_in_Memory.html#Clusters">clusters</a>.<a name="Array_and_String_Tip"></a><h2>Array and String Tip</h2>
<p class="Body">When you are not passing LabVIEW handles and your shared library function must create an array, resize an array, or resize a string of data, you should break the shared library function into the following two shared library functions:</p>
<ul>
<li>Determine the number of elements that the array requires or the length of the string to be returned. Have the first shared library function return the desired size to LabVIEW. </li>
<li>In LabVIEW, initialize an array or string with default values and pass this array to the second shared library function in your shared library, which actually places the data into the array. If you are working with string-based instrument control, it might be easier to pass an array of 8-bit integers than C strings because of the possibility of having NULL values in the string. <br><br>When you are passing a LabVIEW array handle or LabVIEW string handle from the Call Library Function Node to your shared library, you can use the <a href="../lvhowto/Completing_c_File.html">LabVIEW Manager functions</a> to resize or create an array or string.
				</li>
</ul>
</body>
</html>