<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Shared_Libraries_DLLs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Configuring the Call Library Function Node</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Configuring_the_Call_Library_Function_Node"></a><h1>Configuring the Call Library Function Node</h1>
<p class="Body">
					Use the <a href="../glang/Call_Library_Function.html">Call Library Function Node</a> to directly call a 32-bit Windows DLL, a OS X Framework, or a Linux Shared Library function. With this node, you can create an interface in LabVIEW to call existing libraries or new libraries specifically written for use with LabVIEW. National Instruments recommends using the Call Library Function Node to create an interface to external code.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Be aware when using the Call Library Function Node or writing code that is called by the Call Library Function Node that LabVIEW reserves Windows messages WM_USER through WM_USER+99 for internal use only. </td>
</tr>
</table>
<p class="Body">Right-click the Call Library Function Node and select <strong>Configure</strong> from the shortcut menu to display the <a href="../lvdialog/Call_Lib_Function_DB.html">Call Library Function</a> dialog box. Use the <strong>Call Library Function</strong> dialog box to specify the library, function, parameters, return value for the node, calling conventions, and function callbacks on Windows. When you click the <strong>OK</strong> button in the <strong>Call Library Function</strong> dialog box, LabVIEW updates the Call Library Function Node according to your settings, displaying the correct number of terminals and setting the terminals to the correct data types.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you want to run applications or shared libraries created with different versions of LabVIEW on the same computer, the computer <a href="../lvconcepts/Using_the_LV_Run_Time_Eng.html">must have a version of the LabVIEW Run-Time Engine that is compatible</a> with each version of LabVIEW used to create the applications or shared libraries.</td>
</tr>
</table><a name="Configuring_Library_Name_or_Path"></a><h2>Configuring Library Name or Path</h2>
<p class="Body">You must specify either the name of the shared library or the path to the shared library on disk. However, these two techniques produce different consequences when you distribute or relocate your VIs and applications. Refer to the <a href="../lvexcodeconcepts/locations_for_shared_libraries.html">Specifying the Location of Shared Libraries on Disk</a> topic to determine whether to use the name or the path of the shared library for your use case.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��Do not specify the location of a system shared library, such as <span class="Monospace">kernel32.dll</span>, by path. Because LabVIEW automatically includes by-path shared libraries in build specifications, you might distribute a by-path system shared library to another computer inadvertently. Redistributing some shared libraries, such as <span class="Monospace">kernel32.dll</span>, might cause the target computer to crash. Therefore, always specify system shared libraries by name.</td>
</tr>
</table>
<p class="Body">If you want to run applications or shared libraries created on different platforms, use the * wildcard to make the reference to the shared library platform independent. Use * for the file extension and * or ** to the left of the file extension, depending on how you name 32-bit and 64-bit libraries.</p>
<p class="Body">The following example illustrates how to use the * wildcard.</p>
<table class="Bordered">
<tr>
<th class="Bordered"><strong>
				Example</strong></th>
<th class="Bordered">Translation</th>
</tr>
<tr>
<td class="Bordered"><span class="Monospace">
				myshared.*</span></td>
<td class="Bordered">LabVIEW replaces the reference with the appropriate file extension to match the platform that is running the Call Library Node, for example, <span class="Monospace">myshared.dll</span>, <span class="Monospace">myshared.so</span>, and <span class="Monospace">myshared.framework</span>.</td>
</tr>
<tr>
<td class="Bordered"><span class="Monospace">
				myshared*.*</span></td>
<td class="Bordered">LabVIEW replaces the reference with <span class="Monospace">myshared32.*</span> on 32-bit platforms and <span class="Monospace">myshared64.*</span> on 64-bit platforms. You can place the * anywhere to the left of the file extension. For example, <span class="Monospace">my*shared.*</span> can translate to <span class="Monospace">my32shared.*</span>. LabVIEW replaces <span class="Monospace">.*</span> with the appropriate file extension.</td>
</tr>
<tr>
<td class="Bordered"><span class="Monospace">
				myshared**.*</span></td>
<td class="Bordered">LabVIEW replaces the reference with <span class="Monospace">myshared.*</span> on 32-bit platforms and <span class="Monospace">myshared_64.*</span> on 64-bit platforms. You can place the ** anywhere to the left of the file extension. For example, <span class="Monospace">my**shared.*</span> can translate to <span class="Monospace">my_64shared.*</span>. LabVIEW replaces <span class="Monospace">.*</span> with the appropriate file extension.</td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��
					Keep the C++ compiler from introducing platform dependence in exported function names through a process called name mangling by using the C++ compiler function export directive, extern "C"{}, in your header file.
				</td>
</tr>
</table><a name="Configuring_for_Multiple_Thread_Operation"></a><h2>Configuring for Multiple Thread Operation</h2>
<p class="Body">In a <a href="../lvconcepts/Multitask_Multithread_Multip.html">multithreaded</a> operating system, you can make multiple calls to a DLL or shared library simultaneously. You can select the thread to execute the library call from the <strong>Thread</strong> section on the <strong>Function</strong> tab of the <strong>Call Library Function</strong> dialog box. The thread options are <strong>Run in UI thread</strong> and <strong>Run in any thread</strong>. If you select <strong>Run in UI thread</strong>, the Call Library Function Node switches from the thread the VI is currently executing in to the user interface thread. If you select <strong>Run in any thread</strong>, the Call Library Function Node continues in the currently executing thread. By default, all Call Library Function Nodes run in the user interface thread.</p>
<p class="Body">Before you configure a Call Library Function Node to run in any thread, make sure that multiple threads can call the function simultaneously. In a shared library, code can be considered thread-safe when:</p>
<ul>
<li>It does not store any global data, such as global variables, files on disk, and so on.</li>
<li>It does not access any hardware. In other words, the code does not contain register-level programming.</li>
<li>It does not make any calls to any functions, shared libraries, or drivers that are not thread safe. </li>
<li>It uses semaphores or mutexes to restrict access to global resources. </li>
<li>It is called by only one non-reentrant VI.</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��All calls to LabVIEW-built shared libraries should specify <strong>Run in any thread</strong>. If you configure the Call Library Function Node using LabVIEW-built shared libraries and specify <strong>Run in UI thread</strong>, LabVIEW might hang and require you to restart.</td>
</tr>
</table><a name="Setting_the_Calling_Convention"></a><h2>Setting the Calling Convention</h2>
<p class="Body">Calling conventions define the way to pass information from a piece of code to a function. Use the <strong>Calling convention</strong> control on the <strong>Function</strong> tab of the <strong>Call Library Function</strong> dialog box to select the calling convention for the function. The default calling convention is <span class="Monospace">C</span>. The <span class="Monospace">C</span> calling convention allows variable-length parameter lists.</p>
<p class="Body">
					<span class="Platform">(Windows)</span> You also can use the standard Windows calling convention, <span class="Monospace">stdcall</span>. The number of parameters passed to the function is fixed.</p>
<p class="Body">Refer to the documentation for the DLL you want to call for the appropriate calling conventions.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��Using the incorrect calling convention can cause an irregular shutdown of LabVIEW.</td>
</tr>
</table><a name="Configuring_Parameters"></a><h2>Configuring Parameters</h2>
<p class="Body">This section discusses the return value and how to add parameters to the Call Library Function Node.</p>
<p class="Body">
					 To configure parameters for the Call Library Function Node, navigate to the <strong>Parameters</strong> tab of the <strong>Call Library Function</strong> dialog box. Initially, the Call Library Function Node has no parameters and has a return type of <strong>Void</strong>.</p>
<p class="Body">As you configure parameters, the <strong>Function Prototype</strong> text box displays the C prototype for the function you are building. This text box is a read-only display.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If a type library is found, the parameters are updated to match the parameters found in the type library for the selected function. The order of the parameters must match the prototype of the function found in the library.</td>
</tr>
</table>
<p class="Body">The return type for the Call Library Function Node returns to the right terminal of the top terminal. If the return type is <strong>Void</strong>, the top terminal is unused. Each additional pair of terminals corresponds to a parameter in the <strong>Parameters</strong> list of the Call Library Function Node. To pass a value to the Call Library Function Node, wire to the left terminal of a terminal pair. To read the value of a parameter after the Call Library Function Node call, wire from the right terminal of a terminal pair. The following illustration shows a Call Library Function Node that has a return type of <strong>Void</strong>, a string parameter, and a numeric parameter.</p>
<p class="Anchor"><img src="noloc_bd_clfnode.gif"></p><a name="Configuring_Return_Type"></a><h3>Configuring Return Type</h3>
<p class="Body">For return type, you can set <strong>Type</strong> to <strong>Void</strong>, <a href="#Numeric">Numeric</a>, or <a href="../lvexcodeconcepts/Array_and_String_Options.html#String_Data">String</a>. <strong>Void</strong> is only available for return type and is not available for other parameters. Use <strong>Void</strong> for the return type if your function does not return any values.</p>
<p class="Body">Even if the function you call returns a value, you can use <strong>Void</strong> for the return type. When the function returns a value and you select <strong>Void</strong> as the return type, the value returned by the function is ignored.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The function you are calling can return a <a href="#String">C string pointer</a>. If you want to deallocate the pointer, you must do so explicitly as LabVIEW does not automatically deallocate the C string pointer for you.</td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="tip.gif"></td>
<td><strong>Tip</strong>��If the function you are calling returns a data type not listed, choose a return data type the same data size as the one returned by the function. For example, if the function returns a char data type, use an 8-bit unsigned integer. A call to a function in a DLL cannot return a pointer because there are no pointer types in LabVIEW. However, you can specify the return type as an integer that is the same size as the pointer. LabVIEW then treats the address as a simple integer, and you can pass it to future DLL calls.</td>
</tr>
</table><a name="Adding_and_Deleting_Parameters"></a><h3>Adding and Deleting Parameters</h3>
<p class="Body">
				To add parameters to the Call Library Function Node, navigate to the <strong>Parameters</strong> tab of the <strong>Call Library Function</strong> dialog box. Click the <strong>Add a parameter</strong> button. To remove a parameter, click the <strong>Delete the selected parameter</strong> button. To change the order of the parameters, use the <strong>Move the selected parameter up one</strong> and <strong>Move the selected parameter down one</strong> buttons to the right of the parameter list.
			</p><a name="Editing_Parameters"></a><h3>Editing Parameters</h3>
<p class="Body">
				Select the parameter from the <strong>Parameters</strong> list to edit the data type or parameter name. You can edit the parameter name to something more descriptive, which makes it easier to distinguish between parameters. The parameter name does not affect the call, but it is propagated to output wires. Also, you can edit all fields in the <strong>Current parameter</strong> section for the selected parameter.
			</p><a name="Selecting_the_Parameter_Type"></a><h3>Selecting the Parameter Type</h3>
<p class="Body">Use the <strong>Type</strong> pull-down menu to indicate the data type of each parameter. You can select from the following parameter types:</p>
<ul>
<li>
						<strong>Numeric</strong>
					</li>
<li>
						<strong>Array</strong>
					</li>
<li>
						<strong>String</strong>
					</li>
<li>
						<strong>Waveform</strong>
					</li>
<li>
						<strong>Digital Waveform</strong>
					</li>
<li>
						<strong>Digital Data</strong>
					</li>
<li>
						<strong>ActiveX</strong>
					</li>
<li>
						<strong>Adapt to Type</strong>
					</li>
<li>
						<strong>Instance Data Pointer</strong>
					</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If the library function expects a data type not included in the previous list, you must <a href="../lvexcodeconcepts/Configuring_the_CLF_Node.html#Calling_Functions_That_Expect_Other_Data_Types">convert the LabVIEW data</a> into the type the function expects. Common data types that require conversion include structures, arrays containing pointers to other data, and pointers to callback functions.</td>
</tr>
</table>
<p class="Body">After you select an item from the <strong>Type</strong> pull-down menu, you see more items you can use to indicate details about the parameter and about how to pass the data to the library function. The Call Library Function Node has a number of different items for parameter types because of the variety of data types required by different libraries. Refer to the documentation for the library you call to determine which parameter types to use.</p>
<p class="Body">The following sections discuss the different parameter types available from the <strong>Type</strong> pull-down menu.</p>
<p class="Body">
					<span class="Platform">(Windows)</span> Refer to the <span class="Monospace">labview\examples\Connectivity\Libraries and Executables\Libraries and Executables.lvproj</span> for an example of using data types in shared libraries.</p>
<p class="Body">
				<a href="javascript:openProj('examples%5C%5CConnectivity%5C%5CLibraries%20and%20Executables%5C%5CLibraries%20and%20Executables.lvproj');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		�<a href="javascript:findExamples(3769);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples
			</p><a name="Numeric"></a><h4>Numeric</h4>
<p class="Body">For numeric data types, you must indicate the exact numeric type by using the <strong>Data Type</strong> pull-down menu. You can choose from the following data types:</p>
<ul>
<li>8-, 16-, 32-, 64-bit, and pointer-sized signed and unsigned integers</li>
<li>4-byte, single-precision numbers</li>
<li>8-byte, double-precision numbers</li>
</ul>
<p class="Body">If you use pointer-sized integers, the Call Library Function Node adapts to the specific operating system it is being executed on and passes data of the appropriate size to and from the library function. LabVIEW represents the data in 64 bits and, on 32-bit platforms, translates the numeric data types to 32-bit integer types.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>�� You can pass extended-precision numbers and complex numbers by selecting <strong>Adapt to Type</strong> from the <strong>Type</strong> pull-down menu. However, standard libraries generally do not use extended-precision numbers and complex numbers.</td>
</tr>
</table>
<p class="Body">Use the <strong>Pass</strong> pull-down menu to indicate whether you want to pass the value or a pointer to the value.</p><a name="Array"></a><h4>Array</h4>
<p class="Body">Use the <strong>Data Type</strong> pull-down menu to indicate the data type of the array. You can choose from the same data types available for <a href="#Numeric">numeric</a> parameters.</p>
<p class="Body">Specify the dimensions of the array in <strong>Dimensions</strong>.</p>
<p class="Body">Use the <strong>Array Format</strong> pull-down menu to make one of the following choices:</p>
<ul>
<li>
						<strong>Array Data Pointer</strong>�passes a pointer to the array data, allowing the called library to access the array data as the specified data type of the array data.</li>
<li>
						<strong>Array Handle</strong>�passes a pointer to a pointer that points to a four-byte value for each dimension, followed by the data.</li>
<li>
						<strong>Array Handle Pointer</strong>�passes a pointer to an array handle.</li>
</ul>
<p class="Body">Use the <strong>Minimum size</strong> control to have LabVIEW check at run time that the memory LabVIEW allocated for an array data pointer is at least the <strong>Minimum size</strong>. To indicate the <strong>Minimum size</strong> of a 1D array, you can enter a numeric value, or, if you configure an integer parameter in the <strong>Parameters</strong> list, you can select the parameter from the pull-down menu. This option is available only for array data pointers.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you pass in an array that is smaller than the <strong>Minimum size</strong>, LabVIEW enlarges the size of the array to the minimum. However, if you pass in an array that is bigger than the minimum, the array retains the larger size.</td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��Do <em>not</em> attempt to resize an array with system functions, such as <span class="Monospace">realloc</span>. Doing so might crash your system. Instead, use one of the <a href="../lvexcode/memory_manager_functions.html">memory manager functions</a>,	such as <a href="../lvexcode/numericarrayresize.html"><span class="Monospace">NumericArrayResize</span></a>.</td>
</tr>
</table><a name="String"></a><h4>String</h4>
<p class="Body">Use the <strong>String Format</strong> pull-down menu to indicate the string format. You can choose from the following string formats:</p>
<ul>
<li>
						<strong>C String Pointer</strong>�a string followed by a null character.</li>
<li>
						<strong>Pascal String Pointer</strong>�a string preceded by a length byte.</li>
<li>
						<strong>String Handle</strong>�a pointer to a pointer to four bytes for length information, followed by string data.</li>
<li>
						<strong>String Handle Pointer</strong>�a pointer to an array of string handles.</li>
</ul>
<p class="Body">Select a string format that the library function expects. Most standard libraries expect either a C string or a Pascal string. If the library function	you are calling is written for LabVIEW, you might want to use the <strong>String Handle</strong> format. When configuring a Pascal string pointer, you must wire a value to the string input on the block diagram. That value must be initialized with enough characters to hold any new string that may be written to that Pascal string. When configuring a C string pointer, you have two options:</p>
<ul>
<li>Wire a value to the string input that is initialized with enough characters to hold any new string that may be written to that string.</li>
<li>Specify the string size in the <strong>Minimum size</strong> pull-down menu on the <strong>Parameters</strong> tab of the <strong>Call Library Function</strong> dialog box.</li>
</ul>
<p class="Body">Use the <strong>Minimum size</strong> control to have LabVIEW check at run time that the memory LabVIEW allocated for a C string pointer is at least the <strong>Minimum size</strong>. To indicate the <strong>Minimum size</strong> of a string, you can enter a numeric value, or, if you configure an integer parameter in the <strong>Parameters</strong> list, you can select the parameter from the pull-down menu. This option is available only for C string pointers.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you pass in a string that is smaller than the <strong>Minimum size</strong>, LabVIEW enlarges the size of the string to the minimum. However, if you pass in a string that is bigger than the minimum, the string retains the larger size.</td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��Do <em>not</em> attempt to resize an array with system functions, such as <span class="Monospace">realloc</span>. Doing so might crash your system. Instead, use one of the <a href="../lvexcode/memory_manager_functions.html">memory manager functions</a>,	such as <a href="../lvexcode/numericarrayresize.html"><span class="Monospace">NumericArrayResize</span></a>.</td>
</tr>
</table><a name="Waveform"></a><h4>Waveform</h4>
<p class="Body">
				When you call a shared library that includes a waveform data type, you do not have to specify a numeric value from the <strong>Data Type</strong> pull-down menu; the default is <strong>8-byte Double</strong>. However, you must specify <strong>Dimensions</strong>. If the parameter is a single waveform, specify <strong>Dimensions</strong> as <span class="Monospace">0</span>. If the parameter is an array of waveforms, specify <strong>Dimensions</strong> as <span class="Monospace">1</span>. LabVIEW does not support an array of waveforms greater than one-dimensional.
			</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Pointer-sized signed and unsigned integers are not available in the <strong>Data Type</strong> pull-down menu for waveforms.</td>
</tr>
</table><a name="Digital_Waveform"></a><h4>Digital Waveform</h4>
<p class="Body">
				Specify <strong>Dimensions </strong>as <span class="Monospace">0</span> if the parameter is a single digital waveform. Specify <strong>Dimensions</strong> as <span class="Monospace">1</span> if	the parameter is an array of digital waveforms. LabVIEW does not support an array of digital waveforms greater than one-dimensional.
			</p><a name="Digital_Table"></a><h4>Digital Data</h4>
<p class="Body">Specify <strong>Dimensions</strong> as <span class="Monospace">1</span> if the Parameter is an array of digital data. Otherwise, specify <strong>Dimensions</strong> as <span class="Monospace">0</span>. LabVIEW does not support an array of digital data greater than	one-dimensional.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You can pass waveforms, digital waveforms, and digital data through shared libraries, but you cannot access the data inside the shared libraries.</td>
</tr>
</table><a name="ActiveX"></a><h4>ActiveX</h4>
<p class="Body">Select one of the following items from the <strong>Data	Type</strong> pull-down menu: </p>
<ul>
<li>
						<strong>ActiveX Variant Pointer</strong>�passes a pointer to <a href="../lvconcepts/Using_ActiveX_with_LabVIEW.html">ActiveX</a> data.</li>
<li>
						<strong>IDispatch* Pointer</strong>�passes a pointer to the IDispatch interface of an ActiveX Automation server.</li>
<li>
						<strong>IUnknown* Pointer</strong>�passes a pointer to the IUnknown interface of an ActiveX Automation server.</li>
</ul><a name="Adapt_to_Type"></a><h4>Adapt to Type</h4>
<p class="Body">Use <strong>Adapt to Type</strong> to pass arbitrary LabVIEW data types to DLLs in the following ways:</p>
<ul>
<li>Scalars are passed by reference. A pointer to the scalar is passed to the	library.</li>
<li>Arrays and strings are passed according to the <strong>Data Format</strong> setting. You can choose from the following <strong>Data Format</strong> settings: <ul>
<li>
								<strong>Handles by Value</strong> passes the handle to the library. The handle is not NULL.</li>
<li>
								<strong>Pointers to Handles</strong> passes a pointer to	the handle to the library. If the handle is NULL, treat the handle as an empty string or array. To set a value when the handle is NULL, you must allocate a new handle.</li>
<li>
								<strong>Array Data Pointer</strong> passes a pointer to the first element of the array, allowing the called library to access the array data as the data type of the array data.</li>
<li><strong>Interface to Data</strong> allows you to inspect LabVIEW data and data type information in C++ code. For more information about this setting, refer to the <span class="Monospace">ILVDataInterface.idl</span> and <span class="Monospace">ILVTypeInterface.idl</span> files in the <span class="Monospace">labview\cintools</span> directory. </li>
</ul>
					</li>
<li>Clusters are passed by reference.</li>
<li>Scalar elements in arrays or clusters are in line. For example, a cluster containing a numeric is passed as a pointer to a structure containing a numeric.</li>
<li>Clusters within arrays are in line.</li>
<li>Strings and arrays within clusters are referenced by a handle.</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When one or more of the parameters of the function you want to call in a DLL are of types that do not exist in LabVIEW, ensure that each parameter is passed to the function in a way that allows the DLL to correctly interpret the data. <a href="../lvhowto/Completing_c_File.html">Create a skeleton<span class="Monospace">.c</span></a> file from the current configuration of the Call Library Function Node. By viewing the <span class="Monospace">.c</span> file, you can determine whether LabVIEW will pass the data in a manner compatible with the DLL function. You then can make any necessary adjustments.</td>
</tr>
</table><a name="Instance_Data_Pointer"></a><h4>Instance Data Pointer</h4>
<p class="Body">Use <strong>Instance Data Pointer</strong> to access data allocated for each instance of the Call Library Function Node. The <strong>Instance Data Pointer</strong> references a pointer sized allocation that you may use at your own discretion. This allocation is also passed to each of the callback functions on the <strong>Callbacks</strong> tab.</p><a name="Configuring_Callbacks"></a><h2>Configuring Callbacks</h2>
<p class="Body">When you configure a Call Library Function Node to call a function, you can use the <strong>Callback</strong> tab to specify other functions within the same library to call at the following times:</p>
<ul>
<li>Reserve time�When the top-level VI that causes the Call Library Function Node to execute begins executing. Specify a Reserve callback when you need to perform initialization tasks before the primary function executes.</li>
<li>Unreserve time�When the top-level VI that caused the Call Library Function Node to execute stops executing. Specify an Unreserve callback when you save or analyze information or carry out clean-up operations.</li>
<li>Abort�The specified function executes if the VI that called the primary function aborts.</li>
</ul><br><br>Each function that you specify as one of the previous callback functions must accept an <strong>Instance Data Pointer</strong> parameter. When the Call Library Function Node calls one of the callbacks, it passes the <strong>Instance Data Pointer</strong> associated with the function for which the Call Library Function Node is configured.<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You cannot use the <strong>Callback</strong> tab to pass callback functions as parameters to library functions. The Call Library Function Node cannot directly call library functions that require a callback function as a parameter, but you can <a href="../lvexcodeconcepts/Configuring_the_CLF_Node.html#Calling_Functions_That_Expect_Other_Data_Types">create a wrapper library</a> to implement such calls.</td>
</tr>
</table><a name="Calling_Functions_That_Expect_Other_Data_Types"></a><h2>Calling Functions That Expect Other Data Types</h2>
<p class="Body">You might encounter a function that expects data in a form that the Call Library Function Node cannot pass. Specifically, the Call Library Function Node does not support structures or arrays containing a pointer to other data or structures containing flat arrays that can be variably sized. You can call a function that expects an unsupported data type in the following ways:</p>
<ul>
<li>If the data contains no pointers, you might be able to use the <a href="../glang/Flatten_To_String.html">Flatten To String</a> function to create a string containing the binary image of the data required and pass this string as a C string pointer. You will probably want to use the <strong>byte	order</strong> input to Flatten To String to specify that the data be flattened in native byte order.</li>
<li>Write a library function that accepts the data in the form used by LabVIEW and builds the data structure expected by the other library. This function then can call the other library and retrieve any returned values before returning. Your function will probably accept the data from the block diagram as Adapt to Type, so that any block diagram data type can be passed.</li>
<li>If the function expects a callback function as a parameter, complete the following steps to call the function from LabVIEW.
						<ol>
<li>Write a wrapper library that defines at least two new functions:
							 <ul>
<li>A wrapper function that accepts from LabVIEW any data required by the original function. This wrapper function must call the original function, passing the data from LabVIEW as well as a callback function that you define in the same wrapper library.</li>
<li>The callback function that you want to pass to the original function.</li>
</ul>
</li>
<li>Call the wrapper function with the Call Library Function Node.</li>
</ol>
</li>
</ul>
<h2>Configuring Error Checking</h2>
<p class="Body">Use error checking to ensure no errors occur if you call a DLL or shared library with the Call Library Function Node.</p>
<p class="Body">The <strong>Maximum</strong> and <strong>Default</strong> controls on the <strong>Error Checking</strong> tab of the <a href="../lvdialog/Call_Lib_Function_DB.html">Call Library Function</a> dialog box allow LabVIEW to recover from unhandled exceptions that occur in the configuration of the Call Library Function Node or during a call to a shared library or DLL. The <strong>Disabled</strong> control on the <strong>Error Checking</strong> tab disables error checking but improves the execution speed of the Call Library Function Node. </p>
<p class="Body">If you use the Call Library Function Node to call a shared library generated by LabVIEW, the node automatically calls the LVDLLStatus function embedded in the shared library. For these LabVIEW-generated shared libraries, this function detects certain errors, including the following:</p>
<ul>
<li>A VI inside the shared library uses licensed features that are not installed on the target computer.</li>
<li>A VI inside the shared library uses a Call Library Function Node whose associated shared library is not installed on the target computer.</li>
<li>The VIs inside the shared library were compiled using the SSE2 optimizations but the target computer does not support SSE2 instructions.</li>
</ul>
<p class="Body">In these cases, the Call Library Function Node returns error 1003.</p>
</body>
</html>