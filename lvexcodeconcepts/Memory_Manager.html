<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Programming_Issues_for_CINs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Memory Manager</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Memory_Manager"></a><h1>Memory Manager</h1>
<p class="Body">
  
Most applications need routines for allocating and deallocating memory on request. The LabVIEW memory manager is the set of platform-independent <a href="../lvexcode/memory_manager_functions.html">memory manager functions</a> you can use to dynamically allocate, manipulate, and deallocate memory. The memory manager supports dynamic allocation of both nonrelocatable and relocatable blocks, using pointers and handles.</p>
<p class="Body">If you need to perform dynamic memory allocation or manipulation from external code modules, use the memory manager. If your external code operates on data types other than scalars, you should understand how LabVIEW manages memory and know which utilities manipulate data.</p>
<p class="Body">The following code shows how the memory manager defines generic handle and pointer data types:</p>
<p class="code"><span class="Monospace">typedef uChar *UPtr;</span></p>
<p class="code"><span class="Monospace">typedef uChar **UHandle;</span></p>
<p class="Body">All data passed to or from a shared library is allocated using the memory manager. You should only use file manager functions, not the memory manager routines, to manipulate paths. Thus, your shared library should use the memory routines when working with parameters passed from the block diagram. </p><a name="Memory_Allocation"></a><h2>Memory Allocation</h2>
<p class="Body">Applications use the following types of memory allocation:</p>
<ul>
<li>Static</li>
<li>Dynamic</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You can allocate memory for variables in C code using <span class="Monospace">malloc</span>. However, do not assign the resulting pointer to any variable you pass back to the LabVIEW block diagram. Use the memory manager functions if you want to create or resize memory associated with a variable passed from the LabVIEW block diagram.</td>
</tr>
</table><a name="Static_Memory_Allocation"></a><h3>Static Memory Allocation</h3>
<p class="Body">With static memory allocation, the compiler determines memory requirements when you create an application. When you launch the application, LabVIEW creates memory for the known global memory requirements of the application. The memory LabVIEW creates remains allocated while the application runs. Static memory allocation is simple to work with because the compiler handles all the details.</p>
<p class="Body">However, static memory allocation cannot address the memory management requirements of most real-world applications because you cannot determine most memory requirements until run time. Also, statically declared memory might result in larger memory requirements because the memory is allocated for the duration of the application.</p><a name="Dynamic_Memory_Allocation"></a><h3>Dynamic Memory Allocation</h3>
<p class="Body">With dynamic memory allocation, you reserve memory when you need it and free memory when you are no longer using it. Dynamic allocation requires more work than static memory allocation because you have to determine memory requirements and allocate and deallocate memory as necessary.</p>
<p class="Body">You can use the LabVIEW memory manager to dynamically allocate memory in the following ways:</p>
<ul>
<li>Using pointers to allocate memory</li>
<li>Using handles to allocate memory</li>
</ul><a name="Using_Pointers_for_Dynamic_Memory_Allocation"></a><h4>Using Pointers for Dynamic Memory Allocation</h4>
<p class="Body">The more conventional method uses pointers to allocate memory. With pointers, you request a block of memory of a certain size. The routine returns the address of the block of memory to your shared library. When you no longer need the block of memory, you call a routine to free the block of memory. You can use the block of memory to store data. You reference the data stored in the block of memory by using the address the manager routine returned when you created the pointer. You can make copies of the pointer and use them in multiple places in your application to refer to the same data.</p>
<p class="Body">Pointers in the LabVIEW memory manager are nonrelocatable, which means the manager never moves the memory block to which a pointer refers while that memory is allocated for a pointer. Because other references to the memory block do not become out of date, not moving the memory block allocated to a pointer avoids problems that occur when you need to change the amount of memory allocated to a pointer. If you need more memory, sufficient memory might not exist to expand the memory space of the pointer without moving the memory block to a new location. If an application had multiple references to the pointer, moving the memory block to a new location causes problems because each pointer refers to the old memory address of the data. Using invalid pointers can cause severe problems.</p><a name="Using_Handles_for_Dynamic_Memory_Allocation"></a><h4>Using Handles for Dynamic Memory Allocation</h4>
<p class="Body">A second form of memory allocation uses handles. As with pointers, when you allocate memory using handles, you request a block of memory of a certain size. The memory manager allocates the memory and adds the address of the memory block to a list of master pointers. The memory manager returns a handle that is a pointer to the master pointer. If you reallocate a handle and it moves to another address, the memory manager updates the master pointer to refer to the new address. If you look up the correct address using the handle, you access the correct data.</p>
<p class="Body">Use handles to perform most memory allocation in LabVIEW. Pointers are available because in some cases they are more convenient and simpler to use.</p><a name="Using_Pointers_and_Handles"></a><h3>Using Pointers and Handles</h3>
<p class="Body">Create a handle using <a href="../lvexcode/aznewhandle_dsnewhandle.html"><span class="Monospace">DSNewHandle</span></a>, which allows you to specify the size of the memory block, or <a href="../lvexcode/dsnewalignedhandle.html"><span class="Monospace">DSNewAlignedHandle</span></a>, which allows you to specify the size, alignment, and alignment offset of the memory block. Create a pointer using <a href="../lvexcode/aznewptr_dsnewptr.html"><span class="Monospace">DSNewPtr</span></a>. Create a handle or pointer and set it to all zeros using <a href="../lvexcode/aznewhclr_dsnewhclr.html"><span class="Monospace">DSNewHClr</span></a>, <a href="../lvexcode/dsnewalignedhclr.html"><span class="Monospace">DSNewAlignedHClr</span></a>, and <a href="../lvexcode/aznewpclr_dsnewpclr.html"><span class="Monospace">DSNewPClr</span></a>.</p>
<p class="Body">When you are finished with the handle or pointer, release it using <a href="../lvexcode/azdisposehandle_dsdisposehandle.html"><span class="Monospace">DSDisposeHandle</span></a> or <a href="../lvexcode/azdisposeptr_dsdisposeptr.html"><span class="Monospace">DSDisposePtr</span></a>.</p>
<p class="Body">If you need to resize an existing handle, use the <a href="../lvexcode/azsethandlesize_dssethandlesize.html"><span class="Monospace">DSSetHandleSize</span></a> function, which determines the size of an existing handle. If you need to resize and realign an existing handle, use the <a href="../lvexcode/dssetalignedhandlesize.html"><span class="Monospace">DSSetAlignedHandleSize</span></a> function, which determines the size, alignment, and alignment offset of an existing handle. You also can resize and realign an existing handle and set it to all zeros using <a href="../lvexcode/dssetalignedhszclr.html">DSSetAlignedHSzClr</a>. Because pointers are not relocatable, you cannot resize them.</p>
<p class="Body">A handle is a pointer to a pointer. In other words, a handle is the address of an address. The second pointer, or address, is a master pointer, which means it is maintained by the memory manager. Languages that support pointers provide operators for accessing data by its address. With a handle, you use this operator twice�once to get to the master pointer, and a second time to get to the actual data.</p>
<p class="Body">Additional routines make it easy to copy and concatenate handles and pointers to other handles, check the validity of handles and pointers, and copy or move blocks of memory from one place to another.</p><a name="Simple_Example_of_Using_Pointers_and_Handles"></a><h4>Simple Example of Using Pointers and Handles</h4>
<p class="Body">This simple example demonstrates how to work with pointers and handles in C.</p>
<p class="Body">The following code shows how to work with a pointer to an <span class="Monospace">int32</span>:</p>
<p class="code"><span class="Monospace">int32 *myInt32P;</span></p>
<p class="code"><span class="Monospace">myInt32P = (int32 *)DSNewPtr(sizeof(int32));</span></p>
<p class="code"><span class="Monospace">*myInt32P = 5;</span></p>
<p class="code"><span class="Monospace">x = *myInt32P + 7;</span></p>
<p class="code"><span class="Monospace">...</span></p>
<p class="code"><span class="Monospace">DSDisposePtr(myInt32P);</span></p>
<p class="Body">The first line declares the variable <span class="Monospace">myInt32P</span> as a pointer to, or the address of, a 32-bit signed integer. The first line does not actually allocate memory for the <span class="Monospace">int32</span>. The first line creates memory for an address and associates the name <span class="Monospace">myInt32P</span> with that address. The <span class="Monospace">P</span> at the end of the variable name is a convention used in this example to indicate the variable is a pointer.</p>
<p class="Body">The second line creates a block of memory in the data space large enough to hold a single 32-bit signed integer and sets <span class="Monospace">myInt32P</span> to refer to this memory block.</p>
<p class="Body">The third line places the value 5 in the memory location to which <span class="Monospace">myInt32P</span> refers. The <span class="Monospace">*</span> operator refers to the value in the address location. </p>
<p class="Body">The fourth line sets <span class="Monospace">x</span> equal to the value at address <span class="Monospace">myInt32P</span> plus 7.</p>
<p class="Body">The last line frees the pointer.</p>
<p class="Body">The following code is the same example using handles instead of pointers:</p>
<p class="code"><span class="Monospace">int32 **myInt32H;</span></p>
<p class="code"><span class="Monospace">myInt32H =(int32**)DSNewHandle(sizeof(int32));</span></p>
<p class="code"><span class="Monospace">**myInt32H = 5;</span></p>
<p class="code"><span class="Monospace">x = **myInt32H + 7;</span></p>
<p class="code"><span class="Monospace">...</span></p>
<p class="code"><span class="Monospace">DSDisposeHandle(myInt32H);</span></p>
<p class="Body">The first line declares the variable <span class="Monospace">myInt32H</span> as a handle to a 32-bit signed integer. Strictly speaking, the first line declares <span class="Monospace">myInt32H</span> as a pointer to a pointer to an <span class="Monospace">int32</span>. As with the previous example, the first line does not allocate memory for the <span class="Monospace">int32</span>. The first line creates memory for an address and associates the name <span class="Monospace">myInt32H</span> with that address. The <span class="Monospace">H</span> at the end of the variable name is a convention used in this example to indicate the variable is a handle.</p>
<p class="Body">The second line creates a block of memory in the data space large enough to hold a single <span class="Monospace">int32</span>. <span class="Monospace">DSNewHandle</span> places the address of the memory block as an entry in the master pointer list and returns the address of the master pointer entry. Finally, the second line sets <span class="Monospace">myInt32H</span> to refer to the master pointer.</p>
<p class="Body">The third line places the value 5 in the memory location to which <span class="Monospace">myInt32H</span> refers. Because <span class="Monospace">myInt32H</span> is a handle, you use the <span class="Monospace">*</span> operator twice to get to the data.</p>
<p class="Body">The fourth line sets <span class="Monospace">x</span> equal to the value referenced by <span class="Monospace">myInt32H</span> plus 7.</p>
<p class="Body">The last line frees the handle.</p>
<p class="Body">This example shows only the simplest aspects of how to work with pointers and handles in C. Other examples show different aspects of using pointers and handles. Refer to a C manual for a list of other operators you can use with pointers and for more information about how to work with pointers.</p>
</body>
</html>