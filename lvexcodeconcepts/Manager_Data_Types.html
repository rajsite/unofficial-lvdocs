<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Programming_Issues_for_CINs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>LabVIEW Manager Data Types</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Manager_Data_Types"></a><h1>LabVIEW Manager Data Types</h1>
<p class="Body"><a href="../lvexcodeconcepts/LabVIEW_Manager_Routines.html">LabVIEW Manager</a> data types include the following data types:</p>
<ul>
<li>Scalar</li>
<li>Char</li>
<li>Dynamic</li>
<li>Memory-related</li>
<li>Constants</li>
</ul><a name="Scalar"></a><h2>Scalar</h2>
<p class="Body">Scalar data types include Boolean and numeric.</p><a name="Boolean"></a><h3>Boolean</h3>
<p class="Body">External code modules work with two kinds of Boolean scalars�those existing in LabVIEW block diagrams and those passing to and from manager routines. The manager routines use a conventional Boolean form where 0 is FALSE and 1 is TRUE. This conventional Boolean form is called a <span class="Monospace">Bool32</span> and is stored as a 32-bit value.</p>
<p class="Body">LabVIEW block diagrams store Boolean scalars as 8-bit values. The value is 0 if FALSE and 1 if TRUE. This Boolean form is called an <span class="Monospace">LVBoolean</span>.</p>
<p class="Body">The following table describes the two forms of Boolean scalars.</p>
<table class="Bordered">
<tr>
<td class="Bordered"><strong>Name</strong></td>
<td class="Bordered"><strong>Description</strong></td>
</tr>
<tr>
<td class="Bordered"><span class="Monospace">Bool32</span></td>
<td class="Bordered">32-bit integer, 0 if FALSE, 1 if TRUE</td>
</tr>
<tr>
<td class="Bordered"><span class="Monospace">LVBoolean</span></td>
<td class="Bordered">8-bit integer, 0 if FALSE, 1 if TRUE</td>
</tr>
</table><a name="Numeric"></a><h3>Numeric</h3>
<p class="Body">The manager data types support 8-, 16-, 32-, and 64-bit signed and unsigned integers.</p>
<p class="Body">LabVIEW supports the following single, double, and extended floating-point data types.</p>
<table class="Bordered">
<tr>
<td class="Bordered"><strong>Type</strong></td>
<td class="Bordered"><strong>Description</strong></td>
</tr>
<tr>
<td class="Bordered">Single</td>
<td class="Bordered">32-bit</td>
</tr>
<tr>
<td class="Bordered">Double</td>
<td class="Bordered">64-bit</td>
</tr>
<tr>
<td class="Bordered">Extended</td>
<td class="Bordered">Up to 80-bit</td>
</tr>
</table>
<p class="Body">LabVIEW supports complex numbers containing two floating-point numbers, with different complex numeric types for each of the floating-point data types.</p>
<p class="Body">LabVIEW supports the following basic data types for numbers:</p>
<ul>
<li>Signed integers
<ul>
<li><span class="Monospace">int8</span>��8-bit integer</li>
<li><span class="Monospace">int16</span>��16-bit integer</li>
<li><span class="Monospace">int32</span>��32-bit integer</li>
<li><span class="Monospace">int64</span>��64-bit integer</li>
</ul>
 </li>
<li>Unsigned integers
 <ul>
<li><span class="Monospace">uInt8</span>��8-bit integer</li>
<li><span class="Monospace">uInt16</span>��16-bit integer</li>
<li><span class="Monospace">uInt32</span>��32-bit integer</li>
<li><span class="Monospace">uInt64</span>��64-bit integer</li>
<li><span class="Monospace">size_t</span>��32-bit integer</li>
</ul>
 </li>
<li>Floating-point numbers
  <ul>
<li><span class="Monospace">float32</span>��32-bit floating-point number</li>
<li><span class="Monospace">float64</span>��64-bit floating-point number</li>
<li><span class="Monospace">floatExt</span>��extended-precision floating-point number</li>
</ul>
</li>
</ul>
<p class="Body">The following table explains how various platforms store extended-precision numbers.</p>
<table class="Bordered">
<tr>
<td class="Bordered"><strong>Platform</strong></td>
<td class="Bordered"><strong>Storage Format</strong></td>
</tr>
<tr>
<td class="Bordered">Windows and Linux</td>
<td class="Bordered">80-bit structure with two <span class="Monospace">int32</span> components, <span class="Monospace">mhi</span> and <span class="Monospace">mlo</span>,
 and an <span class="Monospace">int16</span> component, <span class="Monospace">e</span></td>
</tr>
<tr>
<td class="Bordered">Mac Intel</td>
<td class="Bordered">64-bit double-precision floating-point number</td>
</tr>
</table><a name="Complex_Numbers"></a><h4>Complex Numbers</h4>
<p class="Body">The complex data types are structures with two floating-point components, <span class="Monospace">re</span> and <span class="Monospace">im</span>. As with floating-point numbers, complex numbers can have 32-bit, 64-bit, and extended-precision components. The following table contains the code for the type definitions for each of these complex data types.</p>
<table class="Bordered">
<tr>
<td class="Bordered"><strong>Complex Number Type</strong></td>
<td class="Bordered"><strong>Code</strong></td>
</tr>
<tr>
<td class="Bordered">32-bit</td>
<td class="Bordered">
<p class="code"><span class="Monospace">typedef struct {</span></p>
<p class="code"><span class="Monospace">����float32 re, im;</span></p>
<p class="code"><span class="Monospace">����} cmplx64;</span></p>
</td>
</tr>
<tr>
<td class="Bordered">64-bit</td>
<td class="Bordered">
<p class="code"><span class="Monospace">typedef struct {</span></p>
<p class="code"><span class="Monospace">����float64 re, im;</span></p>
<p class="code"><span class="Monospace">����} cmplx128;</span></p>
</td>
</tr>
<tr>
<td class="Bordered">Extended-precision</td>
<td class="Bordered">
<p class="code"><span class="Monospace">typedef struct {</span></p>
<p class="code"><span class="Monospace">����floatExtre, im;</span></p>
<p class="code"><span class="Monospace">����} cmplxExt;</span></p>
</td>
</tr>
</table><a name="char"></a><h2>char</h2>
<p class="Body">The <span class="Monospace">char</span> data type is defined by C to be an 8-bit signed integer. LabVIEW defines an unsigned <span class="Monospace">char</span> data type, with the following type definition:</p>
<p class="code"><span class="Monospace">typedef uInt8 uChar;</span></p><a name="Dynamic"></a><h2>Dynamic</h2>
<p class="Body">LabVIEW defines a number of data types you must allocate and deallocate dynamically. Arrays, strings, and paths have data types you must allocate using <a href="Memory_Manager.html">memory manager</a> and <a href="File_Manager.html">file manager</a> routines.</p><a name="Arrays"></a><h3>Arrays</h3>
<p class="Body">LabVIEW supports arrays of any of the basic data types described in this section. You can construct more complicated data types using clusters, which can in turn contain scalars, arrays, and other clusters.</p>
<p class="Body">The first four bytes of a LabVIEW array indicate the number of elements in the array. The elements of the array follow the length field.</p><a name="Strings"></a><h3>Strings</h3>
<p class="Body">LabVIEW supports C- and Pascal-style strings, lists of strings, and <span class="Monospace">LStr</span>, a special string data type you use for string parameters to external code modules. The <a href="Support_Manager.html">support manager</a> contains routines for manipulating strings and converting them among the different types of strings.</p><a name="C-Style_Strings_(CStr)"></a><h4>C-Style Strings (CStr)</h4>
<p class="Body">A C-style string (<span class="Monospace">CStr</span>) is a series of zero or more unsigned characters, terminated by a zero. C strings have no effective length limit. Most manager routines use C strings, unless you specify otherwise. The following code is the type definition for a C string:</p>
<p class="code"><span class="Monospace">typedef uChar *CStr;</span></p><a name="Pascal-Style_Strings_(PStr)"></a><h4>Pascal-Style Strings (PStr)</h4>
<p class="Body">A Pascal-style string (<span class="Monospace">PStr</span>) is a series of unsigned characters. The value of the first character indicates the length of the string. A <span class="Monospace">PStr</span> can have a range of 0 to 255 characters. The following code is the type definition for a Pascal string:</p>
<table class="Borderless">
<tr>
<td class="Borderless">
<p class="code"><span class="Monospace">typedef uChar</span></p>
</td>
<td class="Borderless">
<p class="code"><span class="Monospace">Str255[256], Str31[32],</span></p>
</td>
</tr>
<tr>
<td class="Borderless"></td>
<td class="Borderless">
<p class="code"><span class="Monospace">*StringPtr,</span></p>
</td>
</tr>
<tr>
<td class="Borderless"></td>
<td class="Borderless">
<p class="code"><span class="Monospace">**StringHandle;</span></p>
</td>
</tr>
<tr>
<td class="Borderless">
<p class="code"><span class="Monospace">typedef uChar</span></p>
</td>
<td class="Borderless">
<p class="code"><span class="Monospace">*PStr;</span></p>
</td>
</tr>
</table><a name="LabVIEW_Strings_(LStr)"></a><h4>LabVIEW Strings (LStr)</h4>
<p class="Body">The first four bytes of a LabVIEW string (<span class="Monospace">LStr</span>) indicate the length of the string. The specified number of characters follow the length of the string. <span class="Monospace">LStr</span> is the string data type used by LabVIEW block diagrams. The following code is the type definition for an <span class="Monospace">LStr</span> string:</p>
<p class="code"><span class="Monospace">typedef struct {</span></p>
<p class="code"><span class="Monospace">����int32 cnt;</span></p>
<p class="code"><span class="Monospace">����/* number of bytes that follow */</span></p>
<p class="code"><span class="Monospace">����uChar str[1];</span></p>
<p class="code"><span class="Monospace">����/* cnt bytes */</span></p>
<p class="code"><span class="Monospace">����} LStr, *LStrPtr, **LStrHandle;</span></p><a name="Concatenated_Pascal_String_(CPStr)"></a><h4>Concatenated Pascal String (CPStr)</h4>
<p class="Body">Many algorithms require manipulation of lists of strings. Arrays of strings are usually the most convenient representation for lists. However, arrays of strings can place a burden on the memory manager because of the large number of dynamic objects it must manage. To make working with lists more efficient, LabVIEW supports the concatenated Pascal string (<span class="Monospace">CPStr</span>) data type, which is a list of Pascal-style strings concatenated into a single block of memory. Using the <span class="Monospace">CPStr</span> data structure , you can use support manager routines to create and manipulate lists.</p>
<p class="Body">The following code is the type definition for a <span class="Monospace">CPStr</span> string:</p>
<p class="code"><span class="Monospace">typedef struct {</span></p>
<p class="code"><span class="Monospace">����int32 cnt;</span></p>
<p class="code"><span class="Monospace">����/* number of pascal strings that follow */</span></p>
<p class="code"><span class="Monospace">����uChar str[1];</span></p>
<p class="code"><span class="Monospace">����/* cnt concatenated pascal strings */</span></p>
<p class="code"><span class="Monospace">����} CPStr, *CPStrPtr, **CPStrHandle;</span></p><a name="Paths"></a><h3>Paths</h3>
<p class="Body">A path (pathname) indicates the location of a file or directory in a file system. LabVIEW has a separate data type for a path, represented as <span class="Monospace">Path</span>, which the file manager defines in a platform-independent manner. The actual data type for a path is private to the file manager and subject to change. You can create and manipulate <span class="Monospace">Path</span> data types using file.</p><a name="Memory-Related"></a><h2>Memory-Related</h2>
<p class="Body">LabVIEW uses pointers and handles to reference dynamically allocated memory. The memory-related data types have the following type definitions:</p>
<p class="code"><span class="Monospace">typedef uChar *UPtr;</span></p>
<p class="code"><span class="Monospace">typedef uChar **UHandle;</span></p><a name="Constants"></a><h2>Constants</h2>
<p class="Body">The manager data types define the following constant for use with external code modules:</p>
<p class="code"><span class="Monospace">NULL 0(uInt32)</span></p>
<p class="Body">The following constants define the possible values of the <span class="Monospace">Bool32</span> data type:</p>
<p class="code"><span class="Monospace">FALSE 0 (int32)</span></p>
<p class="code"><span class="Monospace">TRUE 1 (int32)</span></p>
<p class="Body">The following constants define the possible values of the <span class="Monospace">LVBoolean</span> data type:</p>
<p class="code"><span class="Monospace">LVFALSE 0 (uInt8)</span></p>
<p class="code"><span class="Monospace">LVTRUE 1 (uInt8) </span></p>
</body>
</html>