<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from CINs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Using LabVIEW Manager Functions in Shared Libraries</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="LabVIEW_Manager_Routines"></a><h1>Using LabVIEW Manager Functions in Shared Libraries</h1>
<p class="Body">
   LabVIEW has a suite of functions that you can call from shared libraries. This suite of functions performs user-specified routines using the appropriate instructions for a given platform. These routines, which manage the functions of a specific operating system, are grouped into the following categories:</p>
<ul>
<li><a href="Memory_Manager.html">Memory manager</a></li>
<li><a href="File_Manager.html">File manager</a></li>
<li><a href="Support_Manager.html">Support manager</a></li>
</ul><a name="portability"></a><h2>Portability of LabVIEW Manager Functions</h2>
<p class="Body">External code written using the LabVIEW managers is portable, that is, you can compile it without modification on any platform that supports LabVIEW. This portability has the following advantages:</p>
<ul>
<li>The LabVIEW application is built on top of the manager functions. Except for the manager functions, the LabVIEW source code is identical across platforms.</li>
<li>The analysis VIs rely mainly on manager functions. Therefore, their source code is the same for all platforms.</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When you call the LabVIEW manager functions from a shared library, use <span class="Monospace">#include extcode.h</span> in any files that use manager functions and link to <span class="Monospace">labviewv.lib</span>. Set the structure alignment of the compiler to 1 byte.</td>
</tr>
</table>
<p class="Body">To achieve platform independence, data types should not depend on the peculiarities of various compilers. For example, the C language does not define the size of an integer. Without an explicit definition of the size of each data type, you have difficulty creating code that works identically across multiple compilers. LabVIEW managers use data types that explicitly indicate the size of the data type. For example, if a routine requires a 4-byte integer as a parameter, you define the parameter as an <span class="Monospace">int32</span>. The managers define data types in terms of the fundamental data types for each compiler. Thus, on one compiler, the managers might define an <span class="Monospace">int32</span> as an <span class="Monospace">int</span>, while on another compiler, the managers might define an <span class="Monospace">int32</span> as a <span class="Monospace">long int</span>. When you write external code, use the <a href="Manager_Data_Types.html">manager data types</a> instead of the host computer data types so your code is more portable and has fewer errors.</p><a name="Pointers_as_Parameters"></a><h2>Pointers as Parameters</h2>
<p class="Body"> 
  
 
 
  Some manager functions have a parameter that is a <em>pointer</em>. These parameter type descriptions are identified by a trailing asterisk, such as the <strong>ph</strong> parameter of the <a href="../lvexcode/azcopyhandle_dscopyhandle.html"><span class="Monospace">DSCopyHandle</span></a> allocating and releasing function, or are type defined as such, such as the <strong>name</strong> parameter of the <a href="../lvexcode/fnameptr.html"><span class="Monospace">FNamePtr</span></a> function. In most cases, the manager function writes a value to pre-allocated memory. In some cases, such as <a href="../lvexcode/fstrfitspat.html"><span class="Monospace">FStrFitsPath</span></a> or <a href="../lvexcode/getalong.html"><span class="Monospace">GetALong</span></a>, the function reads a value from the memory location, so you do not have to pre-allocate memory for a return value.</p>
<p class="Body">The following functions have parameters that return a value for which you must pre-allocate memory.</p>
<table class="Bordered">
<tr>
<td class="Bordered"><a href="../lvexcode/azmemstats_dsmemstats.html"><span class="Monospace">DSMemStats</span></a></td>
<td class="Bordered"><a href="../lvexcode/fnameptr.html"><span class="Monospace">FNamePtr</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/azcopyhandle_dscopyhandle.html"><span class="Monospace">DSCopyHandle</span></a></td>
<td class="Bordered"><a href="../lvexcode/fnewrefnum.html"><span class="Monospace">FNewRefNum</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/datetosecs.html"><span class="Monospace">DateToSecs</span></a></td>
<td class="Bordered"><a href="../lvexcode/fpathtoarr.html"><span class="Monospace">FPathToArr</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/azmemstats_dsmemstats.html"><span class="Monospace">DSMemStats</span></a></td>
<td class="Bordered"><a href="../lvexcode/fpathtoazstring.html"><span class="Monospace">FPathToAZString</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fcreate.html"><span class="Monospace">FCreate</span></a></td>
<td class="Bordered"><a href="../lvexcode/fpathtodsstring.html"><span class="Monospace">FPathToDSString</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fcreatealways.html"><span class="Monospace">FCreateAlways</span></a></td>
<td class="Bordered"><a href="../lvexcode/fpathtopath.html"><span class="Monospace">FPathToPath</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fflattenpath.html"><span class="Monospace">FFlattenPath</span></a></td>
<td class="Bordered"><a href="../lvexcode/frefnumtofd.html"><span class="Monospace">FRefNumToFD</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fgetaccessrights.html"><span class="Monospace">FGetAccessRights</span></a></td>
<td class="Bordered"><a href="../lvexcode/fstringtopath.html"><span class="Monospace">FStringToPath</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fgeteof.html"><span class="Monospace">FGetEOF</span></a></td>
<td class="Bordered"><a href="../lvexcode/ftexttopath.html"><span class="Monospace">FTextToPath</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fgetinfo.html"><span class="Monospace">FGetInfo</span></a></td>
<td class="Bordered"><a href="../lvexcode/funflattenpath.html"><span class="Monospace">FUnflattenPath</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fgetpathtype.html"><span class="Monospace">FGetPathType</span></a></td>
<td class="Bordered"><a href="../lvexcode/getalong.html"><span class="Monospace">GetAlong</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fmopen.html"><span class="Monospace">FMOpen</span></a></td>
<td class="Bordered"><a href="../lvexcode/setalong.html"><span class="Monospace">SetALong</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fmread.html"><span class="Monospace">FMRead</span></a></td>
<td class="Bordered"><a href="../lvexcode/randomgen.html"><span class="Monospace">RandomGen</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fmtell.html"><span class="Monospace">FMTell</span></a></td>
<td class="Bordered"><a href="../lvexcode/secstodate.html"><span class="Monospace">SecsToDate</span></a></td>
</tr>
<tr>
<td class="Bordered"><a href="../lvexcode/fmwrite.html"><span class="Monospace">FMWrite</span></a></td>
<td class="Bordered"><a href="../lvexcode/numericarrayresize.html"><span class="Monospace">NumericArrayResize</span></a></td>
</tr>
</table>
<p class="Body">You must allocate space for this return value. The following examples illustrate incorrect and correct ways to call one of these functions from within a generic function <span class="Monospace">foo</span>.</p>
<p class="Body">Incorrect example:</p>
<p class="code"><span class="Monospace">foo(Path path) {</span></p>
<p class="code"><span class="Monospace">����PStr p;/* an uninitialized pointer */ File *fd;/* an uninitialized pointer */</span></p>
<p class="code"><span class="Monospace">����MgErr err;</span></p>
<p class="code"><span class="Monospace">����err = FNamePtr(path, p);</span></p>
<p class="code"><span class="Monospace">����err = FMOpen(fd, path, openReadOnly denyWriteOnly);</span></p>
<p class="code"><span class="Monospace">����}</span></p>
<p class="Body">In the incorrect example, <span class="Monospace">p</span> is a pointer to a Pascal string, but the pointer is not initialized to point to any allocated buffer. <span class="Monospace">FNamePtr</span> expects its caller to pass a pointer to an allocated space and writes the name of the file referred to by <span class="Monospace">path</span> into that space. Even if the pointer does not point to a valid place, <span class="Monospace">FNamePtr</span> writes its results there, with unpredictable consequences. Similarly, <span class="Monospace">FMOpen</span> writes its results to the space to which <span class="Monospace">fd</span> points, which is not a valid place because <span class="Monospace">fd</span> is uninitialized.</p>
<p class="Body">Correct example:</p>
<p class="code"><span class="Monospace">foo(Path path) {</span></p>
<p class="code"><span class="Monospace">����Str255 buf; /* allocated buffer of 256 chars */</span></p>
<p class="code"><span class="Monospace">����File fd;</span></p>
<p class="code"><span class="Monospace">����MgErr err;</span></p>
<p class="code"><span class="Monospace">����err = FNamePtr(path, buf);</span></p>
<p class="code"><span class="Monospace">����err = FMOpen(&amp;fd, path, openReadOnly, denyWriteOnly);</span></p>
<p class="code"><span class="Monospace">����}</span></p>
<p class="Body">In the correct example, <span class="Monospace">buf</span> contains space for the maximum-sized Pascal string, whose address is passed to <span class="Monospace">FNamePtr</span>. <span class="Monospace">fd</span> is a local variable (allocated space) for a file descriptor.</p>
</body>
</html>