<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Shared_Libraries_DLLs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Calling External APIs</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Calling_External_APIs"></a><h1>Calling External APIs</h1>
<p class="Body">
				 You might need to access external APIs from within LabVIEW code. Most often, you access external APIs to obtain functionality that the operating system provides. Normally, you can use the LabVIEW <a href="Configuring_the_CLF_Node.html">Call Library Function Node</a> to accomplish this goal. You must provide the following information to the Call Library Function Node to access external APIs from within LabVIEW code:</p>
<ul>
<li>Function name as it appears in the library</li>
<li>
					<a href="../lvhowto/Building_Function_Prototype.html">Function prototype</a>
				</li>
<li>Library or module in which the function resides</li>
<li>Calling conventions of the function</li>
<li>Thread-safe status of the function</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��Do not <a href="../lvexcodeconcepts/locations_for_shared_libraries.html">specify the location</a> of a system shared library, such as <span class="Monospace">kernel32.dll</span>, by path. Because LabVIEW automatically includes by-path shared libraries in build specifications, you might distribute a system shared library to another computer inadvertently. Redistributing some shared libraries, such as <span class="Monospace">kernel32.dll</span>, might cause the target computer to crash. Therefore, always specify system shared libraries by name.</td>
</tr>
</table><a name="Common_Pitfalls_with_the_Call_Library_Function_Node"></a><h2>Common Pitfalls with the Call Library Function Node</h2>
<p class="Body">The function reference documentation for any API should provide most of the information that the Call Library Function Node requires. However, you should keep in mind the common errors listed in this section.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Configure the Call Library Function Node to return an error when some of the pitfalls described below occur by selecting the <strong>Maximum</strong> or <strong>Default</strong> control on the <strong>Error Checking</strong> tab of the <strong>Call Library Function</strong> dialog box. </td>
</tr>
</table><a name="Incorrect_Function_Name"></a><h3>Incorrect Function Name</h3>
<p class="Body">Your library call can fail when the name of the function as it appears in the library is different than is expected. Usually this error occurs due to function name redefinition, or to function name decoration, as in the following examples: </p>
<ul>
<li>
					<strong>Redefinition</strong>�This pitfall appears when an API manufacturer uses a define mechanism, such as <span class="Monospace">#define</span> directive in ANSI C, to define an abstracted function name to one of many functions present in the library, based on some external condition such as language or debug mode. In such cases, you can look in the header ( <span class="Monospace">.h</span>) file for the API to determine whether a <span class="Monospace">#define</span> directive redefined the name of a function you want to use. </li>
<li>
					<strong>Function Name Decoration</strong>�This pitfall appears when certain functions have their names decorated when they are linked. A typical C compiler tracks name decoration, and when it looks for a function in a shared library, it recognizes the decorated name. However, because LabVIEW is not a C compiler, it does not recognize decorated names. If you suspect that function name decoration is causing difficulty, inspect the shared library�s exported functions. If the function name that appears in the function prototype section has characters such as @ appended to it, the function was decorated when the DLL was built. This is most common with C++ compilers.<br><br>In LabVIEW, the <strong>Function name</strong> control in the <a href="../lvdialog/Call_Lib_Function_DB.html">Call Library Function</a> dialog box is a pull-down menu where you can access a list of all functions within the library you have selected. In addition, most operating systems have a utility you can use to view a library�s exports, for example, QuickView on the Windows operating system and the <span class="Monospace">nm</span> command on most Linux systems.
					<br><br> If the <strong>Function name</strong> list contains entries	but the function you want to call does not appear in the list, the most likely reason is that the function has not been exported. Refer to the documentation for your compiler for information about how to mark functions for export. 
				</li>
</ul><a name="Data_Types"></a><h3>Data Types</h3>
<p class="Body">Your library call can fail when you do not use the correct data types. LabVIEW only supports basic numeric data types and C strings. Also, you can select <strong>Adapt to Type</strong> from the <strong>Type</strong> pull-down menu of the <strong>Call Library Function</strong> dialog box and direct LabVIEW to pass its own internal data types for a given parameter. You might encounter the following specific problems:</p>
<ul>
<li>
					<strong>Non-Standard Data Type Definitions</strong>�Frequently, other APIs use non-standard definitions for data types. For example, instead of using <span class="Monospace">char</span>, <span class="Monospace">short</span>, and	<span class="Monospace">long</span>, the Windows API uses <span class="Monospace">BYTE</span>, <span class="Monospace">WORD</span>, and <span class="Monospace">DWORD</span>. If an API that you are using makes use of such data types, you need to <a href="Ex_3_Call_the_Win32_API.html">find the equivalent basic C data type</a> so that you can properly configure the Call Library Function Node.</li>
<li>
					<strong>Structure and Class Data Types</strong>�Some APIs have structure and, in the case of C++, class data types. LabVIEW cannot use these data types. If you need to use a function that has a structure or class as an argument, you should write a shared library wrapper function that takes as inputs the data types that LabVIEW supports and that appropriately packages them before LabVIEW calls the desired function.</li>
<li>
					<strong>ActiveX Objects</strong>�If you want to call a shared library that contains <a href="../lvhowto/ActiveX_Container.html">ActiveX</a> objects, use the <a href="../lvcomm/Automation_Open.html">Automation Open</a> function with the <a href="../glang/Property_Node.html">Property Node</a> and the <a href="../glang/Invoke_Node.html">Invoke Node</a> instead of the Call Library Function Node.</li>
</ul>
<p class="Body">
				<span class="Platform">(Windows)</span> Refer to the <span class="Monospace">labview\examples\Connectivity\Libraries and Executables\Libraries and Executables.lvproj</span> for an example of using data types in shared libraries.</p>
<p class="Body">
				<a href="javascript:openProj('examples%5C%5CConnectivity%5C%5CLibraries%20and%20Executables%5C%5CLibraries%20and%20Executables.lvproj');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		�<a href="javascript:findExamples(3769);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples
			</p><a name="Constants"></a><h3>Constants</h3>
<p class="Body">Your library call can fail when your external code uses identifiers in place of constants. Many APIs define identifiers for constants to make the code easier to read. LabVIEW must receive the actual value of the constant rather than the identifier that a particular API uses. Constants are usually numeric, but they might also be strings or other values. To identify all constants, inspect the header file for the API to <a href="Ex_3_Call_the_Win32_API.html#Constants">find the definitions</a>. The definition might either be in <span class="Monospace">#define</span> statements or in enumerations, which use the <span class="Monospace">enum</span> keyword.</p><a name="Calling_Conventions"></a><h3>Calling Conventions</h3>
<p class="Body">Your library call can fail when certain operating systems use calling conventions other than the C calling convention and the Standard (<span class="Monospace">__stdcall</span>) calling convention. The calling convention defines how data is passed to a function and how clean up occurs after the function call is complete. The documentation for the API should say which calling convention(s) you must use. The Standard (<span class="Monospace">__stdcall</span>) calling convention is  also known as the WINAPI convention, or the Pascal convention. </p>
<p class="Body">Use of calling conventions other than the C or Standard calling conventions frequently causes the failure of library calls in LabVIEW because those other calling conventions use an incompatible method for maintaining the stack.</p>
</body>
</html>