<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><head><!--Generated from database. Edit in the database; do not edit this file.--><!--Function id="555"--><TITLE>Type Cast Function</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252"><meta http-equiv="Content-Style-Type" content="text/css"><link rel="STYLESHEET" type="text/css" href="minimal.css"><script src="common.js" type="text/javascript"></script><script src="jquery-1.7.2.min.js" type="text/javascript"></script><script src="cssframes.js" type="text/javascript"></script><link media="print" rel="stylesheet" type="text/css" href="print.css"></head><body bgcolor="#ffffff"><noscript><p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p><hr width="100%" noshade></noscript><div id="styleDivTitle"><!-- VI or Function Name --><H1>Type Cast Function</H1><!--Owning Palette--><p class="Body"><strong>Owning Palette:</strong> <a href="../glang/Data_Manipulation_Funct.html">Data Manipulation Functions</a></p><!--Package and Platform--><p class="Body"><strong>Requires:</strong> Base Development System</p><!-- VI/Function Description --><p class="Body">Casts <strong>x</strong> to the data type, <strong>type</strong>, by <a href="../lvconcepts/Flattened_Data.html">flattening</a> it and unflattening it using the new data type. If the function must reinterpret data instead of transforming it, LabVIEW uses a temporary buffer. This function has the risk of reinterpreting data. To preserve the data value while converting the data, use the <a href="../glang/coerce_to_type.html">Coerce To Type</a> function instead.</p><!-- Supplemental VI/Function Information --><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;You can also use the <a href="../glang/Conversion_Functions.html">Conversion</a> VIs and functions to convert data types.</td></tr></table><!-- Link to Additional VI/Function Information and Examples  --><p class="Body"><a href="#details">Details</a>&nbsp;&nbsp;</p><!-- Graphic Reference --><MAP NAME="connector_pane"><AREA SHAPE="rect" COORDS="0,14,44,24" HREF="#Input0"><AREA SHAPE="rect" COORDS="0,43,44,49" HREF="#Input1"><AREA SHAPE="rect" COORDS="135,40,199,51" HREF="#Output0"></MAP><p class="Anchor"><img src="typecast.gif" usemap="#connector_pane" border="0"></p><!--Add/Find Buttons--><table class="Borderless"><tr><td><a href="javascript:placeObject(object555);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Add to the block diagram</td><td><a href="javascript:findObject(object555);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find on the palette</td></tr></table></div><div id="styleDivScrolling"><!-- Table of VI/Function Parameters --><table class="Borderless"><tr><td class="Icon"><a name="Input0"></a><img src="cstr.gif"></td><td><strong>type</strong> is the data type to which you want to convert the data. Wire any constant or control to <strong>type</strong> to set the data type to which you want to convert the data. LabVIEW ignores any data in the constant or control you wire to <strong>type</strong>. </td></tr><tr><td class="Icon"><a name="Input1"></a><img src="cext.gif"></td><td><strong>x</strong> specifies the data you want to convert. <BR><BR>This input accepts any data type.</td></tr><tr><td class="Icon"><a name="Output0"></a><img src="istr.gif"></td><td><strong>*(type *) &amp;x</strong> is the value provided in <strong>x</strong> and converted to the same data type as <strong>type</strong>. </td></tr></table><!-- Additional VI/Function Information --><h2><a name="details">Type Cast Details</a></h2><h3>Choosing between the Type Cast Function and the Coerce To Type Function</h3><p class="Body">The <a href="../glang/coerce_to_type.html">Coerce To Type</a> function also converts data to a desired data type. Unlike the Coerce To Type function, the Type Cast function allows conversion between incompatible data types by flattening and unflattening the input data, which allows for radical reinterpretation of the data. When the desired data type requires a different memory size than the input data, the Type Cast function may reinterpret the input data. The Coerce To Type function allows only conversion between compatible data types to preserve the value of the input data, similar to what a <a href="../lvconcepts/Coercion_Dots.html">coercion dot</a> does. You also can use the Coerce To Type function to convert a type definition or rename data on the wire, such as a user event refnum. NI recommends that you use the Coerce To Type function instead of the Type Cast function to avoid reinterpreting the data.</p><h3>Effects of Mismatching the Sizes of X and Type</h3><p class="Body">This function can generate unexpected data if <strong>x</strong> and <strong>type</strong> are not the same size. If <strong>x</strong> requires more bits of storage than <strong>type</strong>, this function uses the upper bytes of <strong>x</strong> and discards the remaining lower bytes. If <strong>x</strong> is of a smaller data type than <strong>type</strong>, this function moves the data in <strong>x</strong> to the upper bytes of <strong>type</strong> and fills the remaining bytes with zeros. For example, an 8-bit unsigned integer with value 1 type cast to a 16-bit unsigned integer results in a value of 256.</p><h3>Type Casting Arrays</h3><p class="Body">You can use this function with an array of scalars or an array of clusters of scalars. For example, if you typecast an array of four 16-bit integers to an array of 32-bit integers, the output array contains two elements, each formed from the bits of pairs of elements from the input array. If the input array does not contain enough bytes to form a whole number of output elements, LabVIEW omits the final elements of the input array.</p><h3>Type Casting References</h3><p class="Body">If you want to upcast or downcast references, use the <a href="../glang/To_More_Generic_Class.html">To More Generic Class</a> function and the <a href="../glang/To_More_Specific_Class.html">To More Specific Class</a> function instead of the Type Cast function. The Type Cast function does not provide error checking, but the To More Generic Class function and the To More Specific Class function do. The To More Specific Class function has <strong>error in</strong> and <strong>error out</strong> parameters. The To More Generic Class function breaks the wire at edit time when you wire a reference to an incompatible target class.</p><h3>Type Casting Boolean Data from Early Versions of LabVIEW</h3><p class="Body">If <strong>x</strong> might contain Boolean data created with LabVIEW 4.<em>x</em> or earlier, right-click this function and select <strong>Convert 4.x Data</strong> from the shortcut menu to convert the data to a format that is readable by LabVIEW 5.0 and later. In <strong>Convert 4.x Data</strong> mode, this function interprets <strong>x</strong> as if the data is stored in LabVIEW 4.<em>x</em> data storage layout and displays the icon for this function with a red <strong>4.x</strong> on it. LabVIEW 4.<em>x</em> and earlier stores Boolean data in two bytes unless the data is in an array, in which case LabVIEW stores each Boolean element in a single bit. LabVIEW 5.0 and later stores Boolean values in a single byte, regardless of whether it is in an array. National Instruments recommends reworking any application that uses the <strong>Convert 4.x Data</strong> mode as a long term solution.</p><!--Module Specific Content--><script type="text/javascript">if (typeof(writeVarRefs)=="function"){writeVarRefs("555");}</script><!-- Example Information --></div></body></HTML>