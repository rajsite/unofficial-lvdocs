<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><head><!--Generated from database. Edit in the database; do not edit this file.--><!--Function id="3563"--><TITLE>Match Regular Expression Function</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252"><meta http-equiv="Content-Style-Type" content="text/css"><link rel="STYLESHEET" type="text/css" href="minimal.css"><script src="common.js" type="text/javascript"></script><script src="jquery-1.7.2.min.js" type="text/javascript"></script><script src="cssframes.js" type="text/javascript"></script><link media="print" rel="stylesheet" type="text/css" href="print.css"></head><body bgcolor="#ffffff"><noscript><p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p><hr width="100%" noshade></noscript><div id="styleDivTitle"><!-- VI or Function Name --><H1>Match Regular Expression Function</H1><!--Owning Palette--><p class="Body"><strong>Owning Palette:</strong> <a href="../glang/String_Functions.html">String Functions</a></p><!--Package and Platform--><p class="Body"><strong>Requires:</strong> Base Development System</p><!-- VI/Function Description --><p class="Body">Searches for a regular expression in the <strong>input string</strong> beginning at the <strong>offset</strong> you enter. If the function finds a match, it splits the string into three substrings and any number of submatches. <a href="../lvhowto/Resizing_Array_Functions.html">Resize</a> the function to view any submatches found in the string.</p><!-- Supplemental VI/Function Information --><!-- Link to Additional VI/Function Information and Examples  --><p class="Body"><a href="#details">Details</a>&nbsp;&nbsp;</p><!-- Graphic Reference --><MAP NAME="connector_pane"><AREA SHAPE="rect" COORDS="0,15,123,26" HREF="#Input0"><AREA SHAPE="rect" COORDS="0,29,123,40" HREF="#Input1"><AREA SHAPE="rect" COORDS="0,47,123,57" HREF="#Input2"><AREA SHAPE="rect" COORDS="0,60,123,71" HREF="#Input3"><AREA SHAPE="rect" COORDS="0,74,123,85" HREF="#Input4"><AREA SHAPE="rect" COORDS="0,89,123,97" HREF="#Input5"><AREA SHAPE="rect" COORDS="254,44,319,53" HREF="#Output0"><AREA SHAPE="rect" COORDS="254,58,315,67" HREF="#Output1"><AREA SHAPE="rect" COORDS="254,72,311,81" HREF="#Output2"><AREA SHAPE="rect" COORDS="254,86,340,97" HREF="#Output3"><AREA SHAPE="rect" COORDS="254,101,298,109" HREF="#Output4"></MAP><p class="Anchor"><img src="matchregexpression.gif" usemap="#connector_pane" border="0"></p><!--Add/Find Buttons--><table class="Borderless"><tr><td><a href="javascript:placeObject(object3563);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Add to the block diagram</td><td><a href="javascript:findObject(object3563);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find on the palette</td></tr></table></div><div id="styleDivScrolling"><!-- Table of VI/Function Parameters --><table class="Borderless"><tr><td class="Icon"><a name="Input0"></a><img src="cbool.gif"></td><td><strong>multiline?</strong> specifies whether to treat the text in <strong>input string</strong> as a multiple-line string. This setting affects how the  ^ and $ characters handle matches. If you set <strong>multiline?</strong> to FALSE (default), when you enter ^ at the beginning of a regular expression, the expression matches only the beginning of the string in <strong>input string</strong>. When you enter $ at the end of a regular expression, the expression matches only the end of the string in <strong>input string</strong>. If you set <strong>multiline?</strong> to TRUE, ^ matches the beginning of any line in <strong>input string</strong> and $ matches the end of any line in <strong>input string</strong>.<br><br><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;The ^ character anchors the match to the beginning of a string when used as the first character of a pattern. If you add ^ to the beginning of a character class immediately after an open square bracket, the expression matches any character not in a given character class.</td></tr></table></td></tr><tr><td class="Icon"><a name="Input1"></a><img src="cbool.gif"></td><td><strong>ignore case?</strong> specifies whether the string search is case sensitive. If FALSE (default), the string search is case sensitive. </td></tr><tr><td class="Icon"><a name="Input2"></a><img src="cstr.gif"></td><td><strong>input string</strong> specifies the input string the function searches. This string cannot contain null characters. </td></tr><tr><td class="Icon"><a name="Input3"></a><img src="cstr.gif"></td><td><strong>regular expression</strong> specifies the pattern you want to search for in <strong>input string</strong>. If the function does not find a match, <strong>whole match</strong> and <strong>after match</strong> contain empty strings, <strong>before match</strong> contains the entire input string, <strong>offset past match</strong> returns &#8211;1, and all submatches outputs return empty strings. Place any substrings you want to search for in parentheses. The function returns any substring expressions it finds in <strong>substring 1..n</strong>. This string cannot contain null characters.</td></tr><tr><td class="Icon"><a name="Input4"></a><img src="ci32.gif"></td><td><strong>offset</strong> specifies the number of characters into <strong>input string</strong> at which the function starts searching for <strong>search string</strong>. </td></tr><tr><td class="Icon"><a name="Input5"></a><img src="cerrcodeclst.gif"></td><td><strong>error in</strong> describes error conditions that occur before this node runs. This input provides <a href="../lvconcepts/using_standard_error_in.html">standard error in</a> functionality. </td></tr><tr><td class="Icon"><a name="Output0"></a><img src="istr.gif"></td><td><strong>before match</strong> returns all the characters before the match. </td></tr><tr><td class="Icon"><a name="Output1"></a><img src="istr.gif"></td><td><strong>whole match</strong> returns all the characters that match the expression entered in <strong>regular expression</strong>. Any substring matches the function finds appear in the submatch outputs.</td></tr><tr><td class="Icon"><a name="Output2"></a><img src="istr.gif"></td><td><strong>after match</strong> returns all the characters after the match. </td></tr><tr><td class="Icon"><a name="Output3"></a><img src="ii32.gif"></td><td><strong>offset past match</strong> returns the index in <strong>input string</strong> of the first character after the last match. If the VI does not find a match, <strong>offset past match</strong> returns &#8211;1. </td></tr><tr><td class="Icon"><a name="Output4"></a><img src="ierrcodeclst.gif"></td><td><strong>error out</strong> contains error information. This output provides <a href="../lvconcepts/using_standard_error_out.html">standard error out</a> functionality. </td></tr></table><!-- Additional VI/Function Information --><h2><a name="details">Match Regular Expression Details</a></h2><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;The Match Regular Expression function does not support null characters in strings. If you include null characters in strings you wire to this function, LabVIEW returns an error and the function may return unexpected results.</td></tr></table><p class="Body">Regular expression support is provided by the PCRE library package. Refer to <span class="Monospace">&lt;National Instruments&gt;\_Legal Information</span> directory for more information about the license under which the PCRE library package is redistributed.</p><p class="Body">Refer to the <a href="javascript:WWW(WWW_PCRERegExp)">PCRE website</a> at <span class="Monospace">www.pcre.org</span> for more information about Perl Compatible Regular Expressions.</p><p class="Body"><!--begin parent  = ../lvconcepts/Searching_Strings.html  tag="MRE_slower"-->The Match Regular Expression function gives you more options for matching strings but performs more slowly than the <a href="../glang/Match_Pattern.html">Match Pattern</a> function.<!--end parent  = ../lvconcepts/Searching_Strings.html  tag="MRE_slower"--></p><p class="Body">Use <a href="../lvhowto/Regular_Expression_Patterns.html">regular expressions</a> in this function to refine searches.</p><h3>Avoiding Stack Overflow</h3><p class="Body">Certain regular expressions that use repeated grouped expressions (such as <span class="Monospace">(.|\s)* or (a*)*</span>) require significant resources to process when applied to large input strings. In some cases a stack overflow may occur on large input strings. Some regular expressions may recurse repeatedly while attempting to match a large string, which may eventually overflow the stack. For example, the regular expression <span class="Monospace">(.|\n)*A</span> and a large input string may cause LabVIEW to crash. To avoid recursion, you can rewrite the regular expression<span class="Monospace"> (.|\n)*A</span> as <span class="Monospace">(?s).*A</span>. The <span class="Monospace">(?s)</span> notation indicates that a period matches new lines. You also can rewrite the expression as <span class="Monospace">[^A]*A</span>.</p><h3>Grouping Patterns for Submatches</h3><p class="Body">You can capture submatches by placing parentheses <span class="Monospace">( )</span> around a portion of a regular expression that you want the function to return as a submatch. For example, the regular expression <span class="Monospace">(el.)..(L..)</span> returns two submatches in the input string <span class="Monospace">Hello LabVIEW!</span>: <span class="Monospace">ell</span> and <span class="Monospace">Lab</span>. Each submatch corresponds to a character group in the order that the character group appears in the regular expression. In this example, <strong>submatch 1</strong> is <span class="Monospace">ell</span> and <strong>submatch 2</strong> is <span class="Monospace">Lab</span>.</p><p class="Body">If you nest a character group within another character group, the regular expression creates a submatch for the outer group before the inner group. For example, the regular expression <span class="Monospace">(.(el.).).(L..)</span> returns three submatches in the input <span class="Monospace">Hello LabVIEW!</span>: <span class="Monospace">Hello</span>, <span class="Monospace">ell</span>, and <span class="Monospace">Lab</span>. In this example, <strong>submatch 1</strong> is <span class="Monospace">Hello</span> because the regular expression matches the outer character group before the inner group.</p><h3>Examples of Regular Expressions</h3><p class="Body">The following table shows examples of regular expressions you can use with the Match Regular Expression function.</p><table class="Bordered"><tr><th class="Bordered">Characters to Find</th><th class="Bordered">Regular Expression</th></tr><tr><td class="Bordered"><span class="Monospace">VOLTS</span></td><td class="Bordered"><span class="Monospace">VOLTS</span></td></tr><tr><td class="Bordered">A plus sign or a minus sign</td><td class="Bordered"><span class="Monospace">[+-]</span></td></tr><tr><td class="Bordered">A sequence of one or more digits</td><td class="Bordered"><span class="Monospace">[0-9]+</span></td></tr><tr><td class="Bordered">Zero or more spaces</td><td class="Bordered"><span class="Monospace">\s*</span> or <span class="Monospace">*</span> (that is, a space followed by an asterisk)</td></tr><tr><td class="Bordered">One or more spaces, tabs, new lines, or carriage returns</td><td class="Bordered"><span class="Monospace">[\t \r \n \s]+</span></td></tr><tr><td class="Bordered">One or more characters other than digits</td><td class="Bordered"><span class="Monospace">[^0-9]+</span></td></tr><tr><td class="Bordered">The word <span class="Monospace">Level</span> only if it appears at the beginning of the string</td><td class="Bordered"><span class="Monospace">^Level</span></td></tr><tr><td class="Bordered">The word <span class="Monospace">Volts</span> only if it appears at the end of the string</td><td class="Bordered"><span class="Monospace">Volts$</span></td></tr><tr><td class="Bordered">The longest string within parentheses</td><td class="Bordered"><span class="Monospace">\(.*\)</span></td></tr><tr><td class="Bordered">The first string within parentheses but not containing any parentheses within it</td><td class="Bordered"><span class="Monospace">\([^()]*\)</span></td></tr><tr><td class="Bordered">A left bracket</td><td class="Bordered"><span class="Monospace">\[</span></td></tr><tr><td class="Bordered">A right bracket</td><td class="Bordered"><span class="Monospace">\]</span></td></tr><tr><td class="Bordered"><span class="Monospace">cat</span>, <span class="Monospace">cag</span>, <span class="Monospace">cot</span>, <span class="Monospace">cog</span>, <span class="Monospace">dat</span>, <span class="Monospace">dag</span>, <span class="Monospace">dot</span>, and <span class="Monospace">dog</span></td><td class="Bordered"><span class="Monospace">[cd][ao][tg]</span></td></tr><tr><td class="Bordered"><span class="Monospace">cat</span> or <span class="Monospace">dog</span></td><td class="Bordered"><span class="Monospace">cat|dog</span></td></tr><tr><td class="Bordered"><span class="Monospace">dog</span>, <span class="Monospace">cat dog</span>, <span class="Monospace">cat cat dog</span>,<span class="Monospace">cat cat cat dog</span>, and so on</td><td class="Bordered"><span class="Monospace">((cat )*dog)</span></td></tr><tr><td class="Bordered">One or more of the letter <span class="Monospace">a</span> followed by a space and the same number of the letter <span class="Monospace">a</span>, that is, <span class="Monospace">a a</span>, <span class="Monospace">aa aa</span>, <span class="Monospace">aaa aaa</span>, and so on</td><td class="Bordered"><span class="Monospace">(a+) \1</span></td></tr></table><!--Module Specific Content--><script type="text/javascript">if (typeof(writeVarRefs)=="function"){writeVarRefs("3563");}</script><!-- Example Information --></div></body></HTML>