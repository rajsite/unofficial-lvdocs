<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<meta http-equiv="Content-Style-Type" content="text/css">

<title>Channel Wire Endpoints</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script>
</head>
<body bgcolor="#ffffff">
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript>
<h1>Channel Wire Endpoints</h1>

<p class="Body"><strong>Requires:</strong> Base Development System</p>
<p class="Body"><a href="../lvconcepts/channel_wires_intro.html">Channel wire</a> endpoints are nodes where a channel wire terminates. By connecting a channel writer endpoint to a reader endpoint using a channel wire, you build a channel. The channel wire endpoints operate on the channel in the following way: the writer endpoints write data to the channel, and reader endpoints read data from the channel. You can use the channel wire endpoints to write or read data between parallel sections of code. LabVIEW provides several channel templates. Each template expresses a different communications protocol to use between the writers and readers. Choose which channel template to use based on your communications needs.</p>
<p class="Body">Create a channel endpoint by right-clicking a terminal or a wire and selecting <strong>Create&#0187;Channel Writer</strong> or <strong>Create&#0187;Channel Reader</strong>. When you create an endpoint from a terminal, you instantiate the channel template with that data type as its transmission type.</p>
<table class="Bordered"><tr><th class="Bordered Left-Align">Template</th><th class="Bordered Left-Align">Description</th></tr><tr><td class="Bordered"><a href="../glang/channel_stream.html">Stream</a></td><td class="Bordered">Use the Stream channel to communicate homogeneous data from a single writer to a single reader. The data elements are buffered and transferred with no data loss in a first-in-first-out (FIFO) order.</td></tr><tr><td class="Bordered"><a href="../glang/channel_tag.html">Tag</a></td><td class="Bordered">Use the Tag channel to share a single value among multiple readers and/or writers. Sharing the value is similar to sharing a global or network shared variable. Each time a writer endpoint writes a value to the channel, the value overwrites the existing value in the channel to ensure that the reader endpoints always read the latest value.</td></tr><tr><td class="Bordered"><a href="../glang/channel_messenger.html">Messenger</a></td><td class="Bordered">Use the Messenger channel to transfer command-like messages among multiple writers and/or multiple readers. Messages can optionally be synchronous when the writer waits until the message is acknowledged by the reader. The Messenger channel is also capable of consolidating repetitive messages and disposing orphaned messages when the channel aborts.</td></tr><tr><td class="Bordered"><a href="../glang/channel_accumulator.html">Accumulator Tag</a></td><td class="Bordered">Use the Accumulator Tag channel to share a single value among multiple writers and readers. Sharing the value is similar to sharing a global or network shared variable. Each time a writer endpoint writes a value to the channel, the channel adds the value to the existing value. Reader endpoints can optionally clear the value when they retrieve the current sum.</td></tr><tr><td class="Bordered"><a href="../glang/channel_event_messenger.html">Event Messenger</a></td>
<td class="Bordered">Use the Event Messenger channel to transfer data from multiple writers to one or more <a href="../glang/Event_Structure.html">Event structures</a>. Each write operation to the channel triggers an <a href="../lvconcepts/What_Are_Events.html">event</a>. The Event Messenger channel allows the channel syntax to combine with the event syntax that controls your user interface events and generated events.</td></tr><tr><td class="Bordered"><a href="../glang/channel_hsstream.html">High Speed Stream</a></td><td class="Bordered">Use the High Speed Stream channel to transfer data from a single writer to a single reader in a fast and highly efficient manner. The High Speed Stream channels can handle complex data transfer scenarios while managing the whole execution process of parallel loops. The High Speed Stream channel lacks the debug capabilities of the other Streams.</td></tr><tr><td class="Bordered"><a href="../glang/channel_lossy_stream.html">Lossy Stream</a></td>
<td class="Bordered">Use the Lossy Stream channel to communicate homogeneous data from a single writer to a single reader. If the channel is already full when the writer attempts to write a new data, the writer does not wait for space to be available. Instead, the channel optionally either drops the oldest data element in the channel to make room for this new data or discards this new data. You can use the Lossy Stream readers to identify data gaps.</td></tr><tr><td class="Bordered"><a href="../glang/channel_one_element_stream.html">One Element Stream</a></td><td class="Bordered">Use the One Element Stream channel exactly the way you use a Stream channel with size equal to one. Allowing only one element in the buffer makes One Element Stream channels more optimized. They execute faster and save resources compared with Stream channels.</td></tr></table>
</body>
</html>