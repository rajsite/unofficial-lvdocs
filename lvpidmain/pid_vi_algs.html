<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from lvpidmain.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Implementing the PID Algorithm with the PID VIs</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>Implementing the PID Algorithm with the PID VIs</h1>
<p class="Body">This following sections describe how the basic <a href="../lvpid/PIDTitle.html">PID</a> VIs (not including <a href="../lvpid/PIDAdvanced.html">PID Advanced</a>, <a href="../lvpid/pid_advanced_autotuning.html">PID Advanced Autotuning</a>, and other VIs with advanced options) implement the <a href="pid_algs.html">PID algorithm</a>, and the assumptions and transformations necessary to implement the PID controller. To implement a PID controller, LabVIEW requires the algorithm to sample the input signals and discretize the integral and derivative action.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The following formulas apply to most VIs on the <a href="../lvpid/PIDTitle.html">PID</a> palette. The <a href="../lvpid/PIDAdvanced.html">PID Advanced</a> and <a href="../lvpid/pid_advanced_autotuning.html">PID Advanced Autotuning</a> VIs use <a href="../lvpidmain/pid_adv_alg.html">extended formulas</a> with more advanced optional features.</td>
</tr>
</table>
<p class="Body">The following simulation diagram represents the PID implementation provided by the basic PID VIs:</p>
<p class="Anchor"><img src="loc_bd_pid_basic_alg.gif"></p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Constructing a simulation diagram like the one in the previous image requires the <a href="../lvsimconcepts/SIM_C_Intro.html" class="checkLink lvsimconcepts">LabVIEW Control Design and Simulation Module</a>. However, the <a href="../lvpid/PIDTitle.html">PID</a> VIs implement PID controllers for you. You do not need the Control Design and Simulation Module to build PID controllers. Refer to the <a href="javascript:WWW(WWW_ControlDesign)">National Instruments website</a> at <span class="Monospace">ni.com</span> for more information about the Control Design and Simulation Module.</td>
</tr>
</table><a name="errorcalc"></a><h2>Error Calculation</h2>
<p class="Body">
			
			
			The following formula represents the current error used in calculating proportional, integral, and derivative action:</p>
<p class="Anchor"><img src="loc_eq_vierror.gif"></p>
<table class="Borderless">
<tr>
<td>where</td>
<td><em>k</em> is the index of the sampled signal at time <em>k</em>*<em>t</em></td>
</tr>
<tr>
<td></td>
<td><em>e(k)</em> is the current error</td>
</tr>
<tr>
<td></td>
<td><em>SP</em> is the setpoint</td>
</tr>
<tr>
<td></td>
<td><em>PV</em> is the process variable</td>
</tr>
</table><a name="propact"></a><h2>Proportional Action</h2>
<p class="Body">
			Proportional action is the controller gain times the error, as shown in the following formula:</p>
<p class="Anchor"><img src="noloc_eq_vipropact.gif"></p>
<table class="Borderless">
<tr>
<td>where</td>
<td><em>K<sub>c</sub></em> is the controller gain</td>
</tr>
<tr>
<td></td>
<td><em>e(k)</em> is the current error</td>
</tr>
</table>
<p class="Body">The PID VIs express the proportional component in terms of controller gain. The relationship between controller gain (<em>K<sub>c</sub></em>) and proportional band (<em>PB</em>) is <em>K<sub>c</sub></em> = 100 / <em>PB</em>.</p><a name="trapint"></a><h2>Integral Action (Trapezoidal Integration)</h2>
<p class="Body">
			
			
			There are several options for discretizing integral action, such as forward difference, backward difference, and trapezoidal approximation, which is also known as Tustin or Bilinear transformation. The <a href="../lvpid/PIDTitle.html">PID</a> VIs use trapezoidal integration to avoid sharp changes in integral action when there is a sudden change in <em>PV</em> or <em>SP</em>, as represented by the following formula:</p>
<p class="Anchor"><img src="noloc_eq_vitrapint.gif"></p>
<table class="Borderless">
<tr>
<td>where</td>
<td>&#916;<em>T</em> is the sampling time of the controller</td>
</tr>
</table><a name="der"></a><h2>Derivative Action</h2>
<p class="Body">
			Abrupt changes in <em>SP</em> can generate bumps to the output of the controller as a result of applying derivative action to the error <em>e</em>. These bumps are referred to as derivative kick. To avoid derivative kick, you can apply derivative action to the <em>PV</em> only, and not to the error <em>e</em>. The following formula represents the derivative action implemented by the <a href="../lvpid/PIDTitle.html">PID</a> VIs, which avoids derivative kick:</p>
<p class="Anchor"><img src="loc_eq_vipartderact.gif"></p><a name="contout"></a><h2>Controller Output</h2>
<p class="Body">
			
			
			Controller output is the summation of the proportional, integral, and derivative action, as shown in the following formula:</p>
<p class="Anchor"><img src="noloc_eq_vicontout.gif"></p><a name="outlimit"></a><h2>Output Limiting and the Anti-Windup Algorithm</h2>
<p class="Body">
			
			
						
			
			
			
			
			The actual controller output is limited to the range specified for control output.</p>
<table class="Borderless">
<tr>
<td>If</td>
<td><img style="display:inline" src="loc_eq_vioutputlimit1.gif"></td>
<td>then</td>
<td><img style="display:inline" src="loc_eq_vioutputlimit2.gif"></td>
</tr>
</table>
<p class="Body">and</p>
<table class="Borderless">
<tr>
<td>if</td>
<td><img style="display:inline" src="loc_eq_vioutputlimit3.gif"></td>
<td>then</td>
<td><img style="display:inline" src="loc_eq_vioutputlimit4.gif"></td>
</tr>
</table>
<p class="Body">The <a href="../lvpid/PIDTitle.html">PID</a> VIs use an integral sum correction algorithm that facilitates anti-windup. Windup occurs at the upper limit of the controller output. When the error <em>e</em> decreases, the controller output decreases, moving out of the windup area. The integral sum correction algorithm prevents abrupt controller output changes when you switch from manual to automatic mode or change any other parameters. The integral sum correction works as follows:</p>
<table class="Borderless">
<tr>
<td>If</td>
<td><img style="display:inline" src="loc_eq_inputsum1.gif"></td>
<td>then</td>
<td><img style="display:inline" src="loc_eq_inputsum2.gif"></td>
</tr>
</table>
<p class="Body">The previous statement demonstrates that the integral sum correction does not take into account the derivative action on value changes.</p><a name="defaults"></a><h2>Default PID Values and Gain Changes</h2>
<p class="Body">The default ranges for the parameters <em>SP</em>, <em>PV</em>, and output range correspond to percentage values. However, you can use actual engineering units. Adjust corresponding ranges accordingly. The parameters <em>T<sub>i</sub></em> and <em>T<sub>d</sub></em> are specified in minutes.</p>
<p class="Body">You can call the <a href="../lvpid/PIDTitle.html">PID</a> VIs from inside a <a href="../glang/While_Loop.html">While Loop</a> with a fixed cycle time. All the PID VIs are reentrant. Multiple calls from high-level VIs use separate and distinct data. Also, the <a href="../lvpid/PID_VI.html">PID</a> VI has a multi-channel mode where you provide an array that represents an input for each channel.</p>
<p class="Body">PID gains can change at any time. When a change is detected, the PID algorithm tries to perform a bumpless transition by adjusting the integral action to keep the output constant with the new parameters. This avoids output changes when you try to modify the PID parameters, and is useful in gain scheduling.</p><a name="gainsched"></a><h3>Gain Scheduling</h3>
<p class="Body"><a href="../lvpidmain/gain_schedule.html">Gain scheduling</a> refers to a system where you change controller parameters based on measured operating conditions. For example, the scheduling variable can be the setpoint, the process variable, a controller output, or an external signal. For historical reasons, the term gain scheduling is used even if other parameters such as derivative time or integral time change. Gain scheduling effectively controls a system with dynamics that change with operating conditions.</p>
<p class="Body">With the <a href="../lvpid/PIDGainSchedule.html">PID Gain Schedule</a> VI, you can define unlimited sets of PID parameters for gain scheduling. For each schedule, you can use <a href="tuning_pid.html">autotuning</a> to update the PID parameters.</p>
<p class="Body"><br><br><SPAN title=" Add to the block diagram "><a href="javascript:placeObject(object3861);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Add</SPAN>�
			<SPAN title=" Find on the palette "><a href="javascript:findObject(object3861);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find</SPAN><br><br></p>
</body>
</html>