<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><!--Generated from database. Edit in the database; do not edit this file.--><!--VI id="3443"--><HTML><head><!--LabVIEW VI path:vi.lib\gmath\interp.llb\Interpolate 1D.vi--><TITLE>Interpolate 1D VI</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252"><meta http-equiv="Content-Style-Type" content="text/css"><link rel="STYLESHEET" type="text/css" href="minimal.css"><script src="common.js" type="text/javascript"></script><script src="jquery-1.7.2.min.js" type="text/javascript"></script><script src="cssframes.js" type="text/javascript"></script><link media="print" rel="stylesheet" type="text/css" href="print.css"></head><body bgcolor="#ffffff"><noscript><p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p><hr width="100%" noshade></noscript><div id="styleDivTitle"><!-- VI or Function Name --><H1>Interpolate 1D VI</H1><!--Owning Palette--><p class="Body"><strong>Owning Palette:</strong> <a href="../gmath/Interp_Extrap_pal.html">Interpolation &amp; Extrapolation VIs</a></p><!--Package and Platform--><p class="Body"><strong>Requires:</strong> Full Development System</p><!-- VI/Function Description --><p class="Body">Performs one-dimensional interpolation using a selected method based on the lookup table defined by <strong>X</strong> and <strong>Y</strong>.</p><!-- Supplemental VI/Function Information --><!-- Link to Additional VI/Function Information --><p class="Body"><a href="#details">Details</a>&nbsp;&nbsp;<a href="#examples">Example</a></p><!-- Graphic Reference --><MAP NAME="connector_pane"><AREA SHAPE="rect" COORDS="0,9,79,18" HREF="#Input0"><AREA SHAPE="rect" COORDS="0,25,79,33" HREF="#Input1"><AREA SHAPE="rect" COORDS="0,39,79,47" HREF="#Input2"><AREA SHAPE="rect" COORDS="0,53,79,61" HREF="#Input3"><AREA SHAPE="rect" COORDS="0,67,79,75" HREF="#Input4"><AREA SHAPE="rect" COORDS="0,81,79,89" HREF="#Input5"><AREA SHAPE="rect" COORDS="197,25,207,35" HREF="#Output0"><AREA SHAPE="rect" COORDS="197,38,233,47" HREF="#Output1"><AREA SHAPE="rect" COORDS="197,55,223,61" HREF="#Output2"></MAP><p class="Anchor"><img src="Interpolate_1D.gif" usemap="#connector_pane" border="0"></p><!--Add/Find Buttons--><table class="Borderless"><tr><td><a href="javascript:placeObject(object3443);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Add to the block diagram</td><td><a href="javascript:findObject(object3443);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find on the palette</td></tr></table></div><div id="styleDivScrolling"><!-- Table of VI/Function Parameters --><table class="Borderless"><tr><td class="Icon"><a name="Input0"></a><img src="ci32.gif"></td><td><strong>method</strong> specifies the interpolation method. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered"><strong>nearest</strong>&#8212;Chooses the <strong>Y</strong> value corresponding to the <strong>X</strong> value that is nearest to the current <strong>xi</strong> value. LabVIEW sets the interpolated value to the nearest data point.</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered"><strong>linear</strong>&#8212;Sets the interpolated values to points along the line segments connecting the <strong>X</strong> and <strong>Y</strong> data points.</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered"><strong>spline</strong>&#8212;Guarantees that the first and second derivatives of the cubic interpolating polynomials are continuous, even at the data points.</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered"><strong>cubic Hermite</strong>&#8212;Guarantees that the first derivative of the cubic interpolating polynomials is continuous and sets the derivative at the endpoints to certain values in order to preserve the original shape and monotonicity of the <strong>Y</strong> data.</td></tr><tr><td class = "Bordered">4</td><td class = "Bordered"><strong>Lagrange</strong>&#8212;Uses the barycentric Lagrange interpolation algorithm.</td></tr></table></td></tr><tr><td class="Icon"><a name="Input1"></a><img src="c1ddbl.gif"></td><td><strong>Y</strong> specifies the array of tabulated values of the dependent variable. </td></tr><tr><td class="Icon"><a name="Input2"></a><img src="c1ddbl.gif"></td><td><strong>X</strong> specifies the array of tabulated values of the independent variable. The length of <strong>X</strong> must equal the length of <strong>Y</strong>.</td></tr><tr><td class="Icon"><a name="Input3"></a><img src="c1ddbl.gif"></td><td><strong>xi</strong> specifies the array of values of the independent variable at which LabVIEW computes the interpolated values <strong>yi</strong> of the dependent variable. </td></tr><tr><td class="Icon"><a name="Input4"></a><img src="cbool.gif"></td><td><strong>X is monotonic</strong> specifies whether the values in <strong>X</strong> are increasing monotonically with the index. If <strong>X is monotonic</strong> is TRUE, the interpolation algorithm can avoid sorting <strong>X</strong> and reordering <strong>Y</strong> accordingly. If <strong>X is monotonic</strong> is FALSE, this VI sorts the <strong>X</strong> input arrays to be in ascending order and then reorders <strong>Y</strong> accordingly.</td></tr><tr><td class="Icon"><a name="Input5"></a><img src="ci32.gif"></td><td><strong>ntimes</strong> determines the interpolation <strong>xi</strong> locations, yielding interpolated values between every <strong>Y</strong> element when <strong>xi</strong> is empty. Interpolation between <strong>Y</strong> elements is repeated <strong>ntimes</strong>. The VI ignores <strong>ntimes</strong> if you wire the <strong>xi</strong> input. </td></tr><tr><td class="Icon"><a name="Output0"></a><img src="i1ddbl.gif"></td><td><strong>yi</strong> returns the output array of interpolated values that correspond to the <strong>xi</strong> independent variable values. </td></tr><tr><td class="Icon"><a name="Output1"></a><img src="i1ddbl.gif"></td><td><strong>xi used</strong> is the 1D array of values of the independent variable at which interpolated values of the dependent variable <strong>yi</strong> are computed. <br><br>If <strong>xi</strong> is empty, <strong>xi used</strong> returns (2<sup><strong>ntimes</strong></sup> &#8211; 1)*(<em>N</em> &#8211; 1) + <em>N</em> points with (2<sup><strong>ntimes</strong></sup> &#8211; 1) points located evenly between each two adjacent elements in <strong>X</strong>, where <em>N</em> is the length of <strong>X</strong>. If you wire the <strong>xi</strong> input, this VI ignores <strong>ntimes</strong>, and <strong>xi used</strong> is the same as <strong>xi</strong>.</td></tr><tr><td class="Icon"><a name="Output2"></a><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Additional VI/Function Information --><h2><a name="details">Interpolate 1D Details</a></h2><p class="Body">The VI accepts tabulated dependent and independent variable values <strong>Y</strong> and <strong>X</strong> and provides interpolated values <strong>yi</strong> corresponding to each <strong>xi</strong> location. The VI finds each value of <strong>xi</strong> in <strong>X</strong> and uses the relative location in <strong>X</strong> to find the interpolated value <strong>yi</strong> at the same relative location in <strong>Y</strong>.</p><p class="Body">Interpolate 1D VI allows you to choose between five different interpolation methods. The following sections contain more information about each of these methods. As you read these sections, consider the following situation:</p><ul><li><strong>X</strong> and <strong>Y</strong> already are in ascending order.</li><li><em>x</em><sub><em>j</em></sub> and <em>y</em><sub><em>j</em></sub> are the elements of <strong>X</strong> and <strong>Y</strong>, respectively.</li><li><em>xi</em><sub><em>m</em></sub> is the <em>m</em>-th element in <strong>xi</strong>, and <em>yi</em><sub><em>m</em></sub> is the corresponding <em>m</em>-th dependent value in <strong>yi</strong>.</li></ul><h3>Nearest Method</h3><p class="Body">The nearest method finds the point nearest to <strong>xi</strong> in <strong>X</strong> and then assigns the corresponding y value in <strong>Y</strong> to <strong>yi</strong>, as shown in the following graph.</p><img src="loc_fp_interp_nearest.gif"><h3>Linear Method</h3><p class="Body">The linear method interpolates <strong>yi</strong> on the line segment that connects the two points (<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>) when <strong>xi</strong> is located between the two points (<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>) in <strong>X</strong>, as shown in the following graph.</p><img src="noloc_fp_interp_linear.gif"><p class="Body">In the previous graph, the following equation is true:</p><p class="Indent1"><img src="noloc_eq_interp_1d_lin_meth.gif"></p><h3>Spline Method</h3><p class="Body">The spline method refers to the cubic spline method. With this method, the VI derives a third-order polynomial for each interval between two adjacent points. The polynomials meet the following conditions:</p><ul><li>The first and second derivatives at <em>x</em><sub><em>j</em></sub> are continuous.</li><li>The polynomials pass all the specified data points.</li><li>The second derivatives at the beginning and end are zero.</li></ul><p class="Body">The following graph illustrates the cubic spline method.</p><img src="noloc_fp_interp_spline.gif"><p class="Body">In the previous graph, <em>P</em><sub><em>j</em></sub>(<em>x</em>) is the third-order polynomial between two adjacent points, (<em>x</em><sub><em>j</em></sub>, <em>y</em><sub><em>j</em></sub>) and (<em>x</em><sub><em>j</em> + 1</sub>, <em>y</em><sub><em>j</em> + 1</sub>).</p><p class="Body">Refer to <em>A Practical Guide to Splines</em> in the <a href="../gmath/Mathematics_References.html">Mathematics Related Documentation</a> topic for more information about the cubic spline method.</p><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;If you choose the <span class="Monospace">spline</span> method, this VI returns the same results as the <a href="../gmath/Spline_Interpolation_1D.html">Spline Interpolation 1D</a> VI with natural spline boundary conditions.</td></tr></table><h3>Cubic Hermite Method</h3><p class="Body">The cubic Hermitian spline method is the piecewise cubic Hermitian interpolation. This method derives a third-order polynomial in Hermitian form for each interval and ensures only the first derivatives of the interpolation polynomials are continuous. Compared to the cubic spline method, the cubic Hermitian method has better local property. In other words, if you change one data point <em>x</em><sub><em>j</em></sub>, the effect on the interpolation result lies in the range between [<em>x</em><sub><em>j</em> &#8211; 1</sub>, <em>x</em><sub><em>j</em></sub>] and [<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>].</p><p class="Body">Refer to <em>A Practical Guide to Splines</em> in the <em>Mathematics Related Documentation</em> topic for more information about the cubic Hermitian method.</p><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;If you choose the <span class="Monospace">cubic Hermite</span> method, this VI returns the same results as the <a href="../gmath/Hermite_Interpolation_1D.html">Hermite Interpolation 1D</a> VI.</td></tr></table><h3>Lagrange Method</h3><p class="Body">The Lagrange method derives a polynomial of order <em>N</em> &#8211; 1 that passes all the <em>N</em> points specified in <strong>X</strong> and <strong>Y</strong>, where <em>N</em> is the length of <strong>X</strong> and <strong>Y</strong>. This method is a reformulation of the Newton polynomial that avoids the computation of divided differences. The following equation defines the Lagrange method:</p><p class="Indent1"><img src="noloc_eq_interp_1d_lagrange_a.gif" align="middle">, where <img src="noloc_eq_interp_1d_lagrange_b.gif" align="middle"></p><p class="Body">When you choose between the five interpolation methods in this VI, the following tips might be useful:</p><ul><li>The <span class="Monospace">nearest</span> method and the <span class="Monospace">linear</span> method are simple to use but are too inaccurate in most applications.</li><li>The <span class="Monospace">spline</span> method returns the smoothest result out of all five methods.</li><li>The <span class="Monospace">cubic Hermite</span> method has better local property than the <span class="Monospace">spline</span> method and the <span class="Monospace">Lagrange</span> method.</li><li>The <span class="Monospace">Lagrange</span> method is simple to implement but not suitable for exploratory calculation. When compared to the <span class="Monospace">spline</span> method, the <span class="Monospace">Lagrange</span> method yields the interpolation result with extreme derivatives.</li></ul><!--Module Specific Content--><script type="text/javascript">if (typeof(writeVarRefs)=="function"){writeVarRefs("3443");}</script><!-- Example Information --><h2><a name="examples">Example</a></h2><p class="Body">Refer to the 1D Interpolation VI in the <span class="Monospace">labview\examples\Mathematics\Interpolation</span> directory for an example of using the Interpolate 1D VI.</p><p class="Body"><a href="javascript:openVI('examples%5C%5CMathematics%5C%5CInterpolation%5C%5C1D%20Interpolation.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Open example&nbsp;<a href="javascript:findExamples(3739);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find related examples</p></div></body></HTML>