<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><head><!--Generated from database. Edit in the database; do not edit this file.--><!--Poly VI id="3510"--><!--LabVIEW VI path:vi.lib\gmath\interp.llb\Interpolate 2D.vi--><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252"><meta http-equiv="Content-Style-Type" content="text/css"><TITLE>Interpolate 2D VI</TITLE><link rel="STYLESHEET" type="text/css" href="minimal.css"><script src="common.js" type="text/javascript"></script><script src="polyviselect.js" type="text/javascript"></script><script src="jquery-1.7.2.min.js" type="text/javascript"></script><script src="cssframes.js" type="text/javascript"></script><link media="print" rel="stylesheet" type="text/css" href="print.css"></head><body bgcolor="#ffffff"><noscript><p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p><hr width="100%" noshade></noscript><div id="styleDivTitle"><!-- VI or Function Name --><H1>Interpolate 2D VI</H1><!--Owning Palette--><p class="Body"><strong>Owning Palette:</strong> <a href="../gmath/Interp_Extrap_pal.html">Interpolation &amp; Extrapolation VIs</a></p><!--Package and Platform--><p class="Body"><strong>Requires:</strong> Full Development System</p><!-- VI/Function Description --><p class="Body">Performs two-dimensional interpolation using a selected interpolation method based on the lookup table defined by <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong>, where <strong>Z</strong> is a 2D array. You must <a href="../lvhowto/SelectingDefaultInstPolyVI.html">manually select the polymorphic instance</a> to use.</p><!-- Supplemental VI/Function Information --><!-- Link to Additional VI/Function Information --><p class="Body"><a href="#details">Details</a>&nbsp;&nbsp;<a href="#examples">Example</a></p><!--Instance drop-down list--><p class="Body">Use the pull-down menu to select an instance of this VI.</p><table class="Borderless">   <tr>   <td>      <select name="site" size="1" onchange="polyVISelectHandler(this)">      <option value="">Select an instance</option>      <option value="#parent">Interpolate 2D (2D X, Y)</option><option value="#instance1">Interpolate 2D (1D X,Y)</option><option value="#instance2">Interpolate 2D (1D xi, yi)</option></select>   </td>      </tr>   </table><!--Add/Find Buttons--><table class="Borderless"><tr><td><a href="javascript:placeObject(object3510);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Add to the block diagram</td><td><a href="javascript:findObject(object3510);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find on the palette</td></tr></table></div><div id="styleDivScrolling"><!--Parent Link Text --><h2><a name="parent">Interpolate 2D (2D X, Y)</a></h2><!-- Instance 1 Note --><p class="Body">Performs two-dimensional interpolation when <strong>X</strong>, <strong>Y</strong>, <strong>xi</strong>, and <strong>yi</strong> are 2D arrays.</p><!-- Parent Graphic Reference --><p class="Anchor"><img src="Interpolate_2D_2d_XKommaY.gif"></p><!-- Table of VI/Function Parameters for Parent --><table class="Borderless"><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>method</strong> sets the interpolation method. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered"><strong>nearest</strong>&#8212;Selects the <strong>Z</strong> value that corresponds to the <strong>X</strong>,<strong> Y</strong> value that is nearest to the current <strong>xi</strong>, <strong>yi</strong> value. The interpolated value is set to the nearest data point.</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered"><strong>bilinear</strong>&#8212;Sets the interpolated values to points along the line segments that connect <strong> X</strong> and <strong>Y</strong>.</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered"><strong>bicubic</strong>&#8212;Yields an interpolated point from a bicubic surface that covers sixteen of the closest <strong>X</strong>, <strong>Y</strong>, <strong>Z</strong> data points and guarantees that the first partial derivatives and the second-order mixed derivative of the interpolated surfaces are continuous.</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered"><strong>bicubic spline</strong>&#8212;Guarantees that the first and second partial derivatives of the cubic interpolating polynomials are continuous, even at the data points.</td></tr></table></td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Z</strong> is the 2D array of tabulated values of the dependent variable. </td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>X</strong> is the 2D array of tabulated values of the first independent variable. All interpolation methods require that <strong>X</strong> be monotonic along each row, and all rows must be identical. Otherwise, this VI uses only the first row of <strong>X</strong> to perform the interpolation. If <strong>X</strong> is not empty, the number of columns in <strong>X</strong> must equal the number of columns in <strong>Z</strong>. If <strong>X</strong> is empty, this VI treats <strong>X</strong> as an array whose size equals the size of <strong>Z</strong> and whose rows are [0, 1, �, <em>N</em> &#8211; 1], where <em>N</em> is the number of columns in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Y</strong> is the 2D array of tabulated values of the second independent variable. All interpolation methods require that <strong>Y</strong> be monotonic along each column, and all columns must be identical. Otherwise, this VI uses only the first column of <strong>Y</strong> to perform the interpolation. If <strong>Y</strong> is not empty, the number of rows in <strong>Y</strong> must equal the number of rows in <strong>Z</strong>. If <strong>Y</strong> is empty, this VI treats <strong>Y</strong> as an array whose size equals the size of <strong>Z</strong> and whose columns are [0, 1, �, <em>M</em> &#8211; 1]<sup><em>T</em></sup>, where <em>M</em> is the number of rows in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>xi</strong> is the 2D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. </td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>yi</strong> is the 2D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. The size of <strong>yi</strong> must equal the size of <strong>xi</strong>. </td></tr><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>ntimes</strong> determines the locations of the interpolation points. Interpolations between each <strong>X</strong> element and each <strong>Y</strong> element are repeated <strong>ntimes</strong>. If you wire data to <strong>xi</strong> or <strong>yi</strong>, this VI ignores <strong>ntimes</strong>. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>zi</strong> is the output 2D array of interpolated values that correspond to the <strong>xi</strong>, <strong>yi</strong> independent variable values. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>xi used</strong> is the 2D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>xi</strong>, <strong>xi used</strong> returns <strong>xi</strong> unchanged. Otherwise, <strong>xi used</strong> returns an array with identical rows of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in the first row of <strong>X</strong>, and the number of rows in <strong>xi used</strong> equals the number of rows in <strong>yi used</strong>.</td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>yi used</strong> is the 2D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>yi</strong>, <strong>yi used</strong> returns <strong>yi</strong> unchanged. Otherwise, <strong>yi used</strong> returns an array with identical columns of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in the first column of <strong>Y</strong>, and the number of columns in <strong>yi used</strong> equals the number of columns in <strong>xi used</strong>.</td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Instance 1 Link Text --><h2><a name="instance1">Interpolate 2D (1D X,Y)</a></h2><!--LabVIEW VI Inst Path:vi.lib\gmath\interp.llb\Interpolate 2D (1d X,Y).vi--><!-- Instance 1 Note --><p class="Body">Performs two-dimensional interpolation when <strong>X</strong> and <strong>Y</strong> are 1D arrays and <strong>xi</strong> and <strong>yi</strong> are 2D arrays.</p><!-- Instance 1 Graphic Reference --><p class="Anchor"><img src="Interpolate_2D_1d_XKommaY.gif"></p><!-- Table of VI/Function Parameters for Instance 1 --><table class="Borderless"><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>method</strong> sets the interpolation method. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered"><strong>nearest</strong>&#8212;Selects the <strong>Z</strong> value that corresponds to the <strong>X</strong>,<strong> Y</strong> value that is nearest to the current <strong>xi</strong>, <strong>yi</strong> value. The interpolated value is set to the nearest data point.</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered"><strong>bilinear</strong>&#8212;Sets the interpolated values to points along the line segments that connect <strong> X</strong> and <strong>Y</strong>.</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered"><strong>bicubic</strong>&#8212;Yields an interpolated point from a bicubic surface that covers sixteen of the closest <strong>X</strong>, <strong>Y</strong>, <strong>Z</strong> data points and guarantees that the first partial derivatives and the second-order mixed derivative of the interpolated surfaces are continuous.</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered"><strong>bicubic spline</strong>&#8212;Guarantees that the first and second partial derivatives of the cubic interpolating polynomials are continuous, even at the data points.</td></tr></table></td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Z</strong> is the 2D array of tabulated values of the dependent variable. </td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>X</strong> is the 1D array of tabulated values of the first independent variable. All interpolation methods require that <strong>X</strong> be monotonic. If <strong>X</strong> is not empty, the length of <strong>X</strong> must equal the number of columns in <strong>Z</strong>. If <strong>X</strong> is empty, this VI treats <strong>X</strong> as [0, 1, �, <em>N</em> &#8211; 1], where <em>N</em> is the number of columns in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>Y</strong> is the 1D array of tabulated values of the second independent variable. All interpolation methods require that <strong>Y</strong> be monotonic. If <strong>Y</strong> is not empty, the length of <strong>Y</strong> must equal the number of rows in <strong>Z</strong>. If <strong>Y</strong> is empty, this VI treats <strong>Y</strong> as [0, 1, �, <em>M</em> &#8211; 1], where <em>M</em> is the number of rows in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>xi</strong> is the 2D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. </td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>yi</strong> is the 2D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. The size of <strong>yi</strong> must equal the size of <strong>xi</strong>. </td></tr><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>ntimes</strong> determines the locations of the interpolation points. Interpolations between each <strong>X</strong> element and each <strong>Y</strong> element are repeated <strong>ntimes</strong>. If you wire data to <strong>xi</strong> or <strong>yi</strong>, this VI ignores <strong>ntimes</strong>. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>zi</strong> is the output 2D array of interpolated values that correspond to the <strong>xi</strong>, <strong>yi</strong> independent variable values. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>xi used</strong> is the 2D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>xi</strong>, <strong>xi used</strong> returns <strong>xi</strong>. Otherwise, <strong>xi used</strong> returns an array with rows of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in <strong>X</strong>, and the number of rows in <strong>xi used</strong> equals the number of rows in <strong>yi used</strong>.</td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>yi used</strong> is the 2D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>yi</strong>, <strong>yi used</strong> returns <strong>yi</strong>. Otherwise, <strong>yi used</strong> returns an array with columns of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in <strong>Y</strong>, and the number of columns in <strong>yi used</strong> equals the number of columns in <strong>xi used</strong>.</td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Instance 2 Link Text --><h2><a name="instance2">Interpolate 2D (1D xi, yi)</a></h2><!--LabVIEW VI Inst Path:vi.lib\gmath\interp.llb\Interpolate 2D (1d xi,yi).vi--><!-- Instance 2 Note --><p class="Body">Performs two-dimensional interpolation when <strong>X</strong>, <strong>Y</strong>, <strong>xi</strong>, and <strong>yi</strong> are 1D arrays.</p><!-- Instance 2 Graphic Reference --><p class="Anchor"><img src="Interpolate_2D_1d_xiKommayi.gif"></p><!-- Table of VI/Function Parameters for Instance 2 --><table class="Borderless"><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>method</strong> sets the interpolation method. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered"><strong>nearest</strong>&#8212;Selects the <strong>Z</strong> value that corresponds to the <strong>X</strong>,<strong> Y</strong> value that is nearest to the current <strong>xi</strong>, <strong>yi</strong> value. The interpolated value is set to the nearest data point.</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered"><strong>bilinear</strong>&#8212;Sets the interpolated values to points along the line segments that connect <strong> X</strong> and <strong>Y</strong>.</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered"><strong>bicubic</strong>&#8212;Yields an interpolated point from a bicubic surface that covers sixteen of the closest <strong>X</strong>, <strong>Y</strong>, <strong>Z</strong> data points and guarantees that the first partial derivatives and the second-order mixed derivative of the interpolated surfaces are continuous.</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered"><strong>bicubic spline</strong>&#8212;Guarantees that the first and second partial derivatives of the cubic interpolating polynomials are continuous, even at the data points.</td></tr></table></td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Z</strong> is the 2D array of tabulated values of the dependent variable. </td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>X</strong> is the 1D array of tabulated values of the first independent variable. All interpolation methods require that <strong>X</strong> be monotonic. If <strong>X</strong> is not empty, the length of <strong>X</strong> must equal the number of columns in <strong>Z</strong>. If <strong>X</strong> is empty, this VI treats <strong>X</strong> as [0, 1, �, <em>N</em> &#8211; 1], where <em>N</em> is the number of columns in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>Y</strong> is the 1D array of tabulated values of the second independent variable. All interpolation methods require that <strong>Y</strong> be monotonic. If <strong>Y</strong> is not empty, the length of <strong>Y</strong> must equal the number of rows in <strong>Z</strong>. If <strong>Y</strong> is empty, this VI treats <strong>Y</strong> as [0, 1, �, <em>M</em> &#8211; 1], where <em>M</em> is the number of rows in <strong>Z</strong>.</td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>xi</strong> is the 1D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. </td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>yi</strong> is the 1D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are to be computed. </td></tr><tr><td class="Icon"><img src="ci32.gif"></td><td><strong>ntimes</strong> determines the locations of the interpolation points. Interpolations between each <strong>X</strong> element and each <strong>Y</strong> element are repeated <strong>ntimes</strong>. If you wire data to <strong>xi</strong> or <strong>yi</strong>, this VI ignores <strong>ntimes</strong>. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>zi</strong> is the output 2D array of interpolated values that correspond to the <strong>xi</strong>, <strong>yi</strong> independent variable values. </td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>xi used</strong> is the 2D array of values of the first independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>xi</strong>, <strong>xi used</strong> returns <strong>xi</strong>. Otherwise, <strong>xi used</strong> returns an array with rows of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in <strong>X</strong>, and the number of rows in <strong>xi used</strong> equals the number of rows in <strong>yi used</strong>.</td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>yi used</strong> is the 2D array of values of the second independent variable at which interpolated values of the dependent variable <strong>zi</strong> are computed. If you wire data to <strong>yi</strong>, <strong>yi used</strong> returns <strong>yi</strong>. Otherwise, <strong>yi used</strong> returns an array with columns of 2<sup><strong>ntimes</strong></sup> &#8211; 1 points located evenly between each two adjacent elements in <strong>Y</strong>, and the number of columns in <strong>yi used</strong> equals the number of columns in <strong>xi used</strong>.</td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Additional VI/Function Information --><h2><a name="details">Interpolate 2D Details</a></h2><p class="Body">This VI accepts tabulated <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> values (two independent variables and one dependent variable, respectively) and provides interpolated values <strong>zi</strong> that correspond to each <strong>xi</strong>, <strong>yi</strong> location. The VI looks up each value of <strong>xi</strong>, <strong>yi</strong> in <strong>X</strong>, <strong>Y</strong> and uses the relative location in <strong>X</strong>, <strong>Y</strong> to find the interpolated value <strong>zi</strong> at the relative location within <strong>Z</strong>.</p><p class="Body">This VI allows you to choose between four different interpolation methods.</p><p class="Body">In the following illustration, <strong>xi</strong> and <strong>yi</strong> are 2D arrays that specify the coordinates to be interpolated. In other words, the coordinates of <strong>zi</strong><sub><em>m</em>, <em>n</em></sub> are (<strong>xi</strong><sub><em>m</em>, <em>n</em></sub>, <strong>yi</strong><sub><em>m</em>, <em>n</em></sub>), where <em>m</em> and <em>n</em> are the indices for <strong>xi</strong>, <strong>yi</strong>, and <strong>zi</strong>. <strong>X</strong> and <strong>Y</strong> are 1D arrays that specify the coordinates of <strong>Z</strong>. <em>i</em> and <em>j</em> are the indices of <strong>X</strong> and <strong>Y</strong>, respectively. <strong>Z</strong> is the 2D array that represents the corresponding dependent variable, and the red dot specifies the position of <strong>zi</strong><sub><em>m</em>, <em>n</em></sub>.</p><img src="noloc_eps_interp_2d_a.gif"><h3>Nearest Interpolation Method</h3><p class="Body">The nearest method finds the point nearest to (<strong>xi</strong><sub><em>m</em>, <em>n</em></sub>, <strong>yi</strong><sub><em>m</em>, <em>n</em></sub>) and commits the corresponding z value in <strong>Z</strong> to <strong>zi</strong><sub><em>m</em>, <em>n</em></sub>. In the previous illustration, <strong>zi</strong><sub><em>m</em>, <em>n</em></sub> = <em>z</em><sub><em>i</em>, <em>j</em> + 1</sub>.</p><h3>Bilinear Interpolation Method</h3><p class="Body">The bilinear method is the extension of the linear method in the <a href="../gmath/Interpolate_1D.html">Interpolate 1D</a> VI. The bilinear method calculates the 1D linear interpolation twice along the x-axis and returns the interpolated values at points <em>a</em> and <em>b</em>, represented by the blue dots in the following illustration. This VI then calculates the 1D linear interpolation along the y-axis, represented by the line segment that connects <em>a</em> and <em>b</em> in the following illustration, and returns <strong>zi</strong><sub><em>m</em>, <em>n</em></sub>.</p><img src="noloc_eps_interp_2d_b.gif"><h3>Bicubic Interpolation Method</h3><p class="Body">Use the bicubic method to perform interpolation within grid rectangles. This method ensures that the inside interpolated surfaces, their first partial derivatives, and the second-order mixed derivative all are continuous.</p><p class="Body">Refer to <em>Numerical Recipes in C++</em> in the <a href="../gmath/Mathematics_References.html">Mathematics Related Documentation</a> topic for more information about the bicubic interpolation method.</p><h3>Bicubic Spline Interpolation Method</h3><p class="Body">The bicubic spline method is an extension of the cubic spline method in the Interpolate 1D VI. This method performs interpolation along one axis using the cubic spline method and then along the other axis using the same method. The bicubic spline method ensures that the first and second partial derivatives of the interpolation polynomials are continuous.</p><p class="Body">Refer to <em>Numerical Recipes in C++</em> in the <em>Mathematics Related Documentation</em> topic for more information about the bicubic spline interpolation method.</p><!--Module Specific Content--><script type="text/javascript">if (typeof(writeVarRefs)=="function"){writeVarRefs("3510");}</script><!-- Example Information --><h2><a name="examples">Example</a></h2><p class="Body">Refer to the 2D Interpolation VI in the <span class="Monospace">labview\examples\Mathematics\Interpolation</span> directory for an example of using the Interpolate 2D VI.</p><p class="Body"><a href="javascript:openVI('examples%5C%5CMathematics%5C%5CInterpolation%5C%5C2D%20Interpolation.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Open example&nbsp;<a href="javascript:findExamples(3739);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find related examples</p></div></body></HTML>