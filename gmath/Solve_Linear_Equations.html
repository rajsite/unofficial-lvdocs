<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><head><!--Generated from database. Edit in the database; do not edit this file.--><!--Poly VI id="897"--><!--LabVIEW VI path:vi.lib\Analysis\7linalg.llb\Solve Linear Equations.vi--><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252"><meta http-equiv="Content-Style-Type" content="text/css"><TITLE>Solve Linear Equations VI</TITLE><link rel="STYLESHEET" type="text/css" href="minimal.css"><script src="common.js" type="text/javascript"></script><script src="polyviselect.js" type="text/javascript"></script><script src="jquery-1.7.2.min.js" type="text/javascript"></script><script src="cssframes.js" type="text/javascript"></script><link media="print" rel="stylesheet" type="text/css" href="print.css"></head><body bgcolor="#ffffff"><noscript><p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p><hr width="100%" noshade></noscript><div id="styleDivTitle"><!-- VI or Function Name --><H1>Solve Linear Equations VI</H1><!--Owning Palette--><p class="Body"><strong>Owning Palette:</strong> <a href="../gmath/Linear_Algebra_VIs.html">Linear Algebra VIs</a></p><!--Package and Platform--><p class="Body"><strong>Requires:</strong> Full Development System</p><!-- VI/Function Description --><p class="Body">Solves a linear system AX = Y. The data types you wire to the <strong>Input Matrix</strong> and <strong>Known Vector</strong> inputs determine the polymorphic instance to use.</p><!-- Supplemental VI/Function Information --><!-- Link to Additional VI/Function Information --><p class="Body"><a href="#details">Details</a>&nbsp;&nbsp;<a href="#examples">Example</a></p><!--Instance drop-down list--><p class="Body">Use the pull-down menu to select an instance of this VI.</p><table class="Borderless">   <tr>   <td>      <select name="site" size="1" onchange="polyVISelectHandler(this)">      <option value="">Select an instance</option>      <option value="#parent">Solve Linear Equations (single right hand)</option><option value="#instance1">Solve Linear Equations (multiple right hand)</option><option value="#instance2">Solve Complex Linear Equations (single right hand)</option><option value="#instance3">Solve Complex Linear Equations (multiple right hand)</option></select>   </td>      </tr>   </table><!--Add/Find Buttons--><table class="Borderless"><tr><td><a href="javascript:placeObject(object897);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Add to the block diagram</td><td><a href="javascript:findObject(object897);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find on the palette</td></tr></table></div><div id="styleDivScrolling"><!--Parent Link Text --><h2><a name="parent">Solve Linear Equations (single right hand)</a></h2><!-- Instance 1 Note --><!-- Parent Graphic Reference --><p class="Anchor"><img src="Solve_Linear_Equations_single_right_hand.gif"></p><!-- Table of VI/Function Parameters for Parent --><table class="Borderless"><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Input Matrix</strong> is a square or rectangular, real matrix. The number of elements in the <strong>Known Vector</strong> must be equal to the rows of the <strong>Input Matrix</strong>. If the number of elements in the <strong>Known Vector</strong> does not match the rows of the <strong>Input Matrix</strong>, the VI sets the <strong>Solution Vector</strong> to an empty array and returns an error. When <strong>Input Matrix</strong> is singular, if the <strong>matrix type</strong> is General, the Solve Linear Equations VI finds the least-square solution. Otherwise, the VI returns an error.</td></tr><tr><td class="Icon"><img src="c1ddbl.gif"></td><td><strong>Known Vector</strong> is an array of known, dependent-variable values. The number of elements in the <strong>Known Vector</strong> must be equal to the rows of the <strong>Input Matrix</strong>. If the number of elements in the <strong>Known Vector</strong> does not match the rows of the <strong>Input Matrix</strong>, the VI sets the <strong>Solution Vector</strong> to an empty array and returns an error. </td></tr><tr><td class="Icon"><img src="cenum.gif"></td><td><strong>matrix type</strong> is the type of <strong>Input Matrix</strong>. Knowing the type of <strong>Input Matrix</strong> can speed up the computation of the <strong>Solution Vector</strong> and can help you to avoid unnecessary computation, which could introduce numerical inaccuracy. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered">General (default)</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered">Positive definite</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered">Lower triangular</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered">Upper triangular</td></tr></table></td></tr><tr><td class="Icon"><img src="i1ddbl.gif"></td><td><strong>Solution Vector</strong> is the solution X to AX = Y where A is the <strong>Input Matrix</strong> and Y is the <strong>Known Vector</strong>. </td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Instance 1 Link Text --><h2><a name="instance1">Solve Linear Equations (multiple right hand)</a></h2><!--LabVIEW VI Inst Path:vi.lib\Analysis\7linalg.llb\Solve Linear Equations (multiple right hand).vi--><!-- Instance 1 Note --><!-- Instance 1 Graphic Reference --><p class="Anchor"><img src="Solve_Linear_Equations_multiple_right_hand.gif"></p><!-- Table of VI/Function Parameters for Instance 1 --><table class="Borderless"><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Input Matrix</strong> is a square or rectangular, real matrix. The number of rows in the <strong>Known Matrix</strong> must be equal to the rows of the <strong>Input Matrix</strong>. If the number of rows in the <strong>Known Matrix</strong> does not match the rows of the <strong>Input Matrix</strong>, the VI sets the <strong>Solution Matrix</strong> to an empty matrix and returns an error. When<strong> Input Matrix</strong> is singular, if the <strong>matrix type</strong> is General, the VI finds the least-square solution. Otherwise, the VI returns an error.</td></tr><tr><td class="Icon"><img src="c2ddbl.gif"></td><td><strong>Known Matrix</strong> is a matrix of known, dependent-variable values. <strong>Known Matrix</strong> must have the same number of rows as <strong>Input Matrix</strong>. If the number of rows in <strong>Known Matrix</strong> and <strong>Input Matrix</strong> are not equal, the VI sets <strong>Solution Matrix</strong> to an empty matrix and returns an error. </td></tr><tr><td class="Icon"><img src="cenum.gif"></td><td><strong>matrix type</strong> is the type of <strong>Input Matrix</strong>. Knowing the type of <strong>Input Matrix</strong> can speed up the computation of the <strong>Solution Matrix</strong> and can help you to avoid unnecessary computation, which could introduce numerical inaccuracy. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered">General (default)</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered">Positive definite</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered">Lower triangular</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered">Upper triangular</td></tr></table></td></tr><tr><td class="Icon"><img src="i2ddbl.gif"></td><td><strong>Solution Matrix</strong> returns the solution X to AX = Y where A is the <strong>Input Matrix</strong> and Y is the <strong>Known Matrix</strong>. </td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Instance 2 Link Text --><h2><a name="instance2">Solve Complex Linear Equations (single right hand)</a></h2><!--LabVIEW VI Inst Path:vi.lib\Analysis\7linalg.llb\Solve Complex Linear Equations (single right hand).vi--><!-- Instance 2 Note --><!-- Instance 2 Graphic Reference --><p class="Anchor"><img src="Solve_Linear_Equations_single_right_hand.gif"></p><!-- Table of VI/Function Parameters for Instance 2 --><table class="Borderless"><tr><td class="Icon"><img src="c2dcdb.gif"></td><td><strong>Input Matrix</strong> must be a nonsingular, square or rectangular, complex matrix. A nonsingular matrix is a matrix in which no row or column contains a linear combination of any other row or column, respectively. You cannot always determine beforehand whether the matrix is singular, especially with large systems. When<strong> Input Matrix</strong> is singular, if the <strong>matrix type</strong> is General, the VI finds the least-square solution. Otherwise, the VI returns an error.</td></tr><tr><td class="Icon"><img src="c1dcdb.gif"></td><td><strong>Known Vector</strong> is an array of known, dependent-variable values. The number of elements in <strong>Known Vector</strong> must match the row size of the <strong>Input Matrix</strong>. If the number of elements in <strong>Known Vector</strong> does not match the row size of <strong>Input Matrix</strong>, the VI sets <strong>Solution Vector</strong> to an empty array and returns an error. </td></tr><tr><td class="Icon"><img src="cenum.gif"></td><td><strong>matrix type</strong> is the type of <strong>Input Matrix</strong>. Knowing the type of <strong>Input Matrix</strong> can speed up the computation of the <strong>Solution Vector</strong> and can help you to avoid unnecessary computation, which could introduce numerical inaccuracy. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered">General (default)</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered">Positive definite</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered">Lower triangular</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered">Upper triangular</td></tr></table></td></tr><tr><td class="Icon"><img src="i1dcdb.gif"></td><td><strong>Solution Vector</strong> is the solution X to AX = Y where A is the <strong>Input Matrix</strong> and Y is the <strong>Known Vector</strong>. </td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Instance 3 Link Text --><h2><a name="instance3">Solve Complex Linear Equations (multiple right hand)</a></h2><!--LabVIEW VI Inst Path:vi.lib\Analysis\7linalg.llb\Solve Complex Linear Equations (multiple right hand).vi--><!-- Instance 3 Note --><!-- Instance 3 Graphic Reference --><p class="Anchor"><img src="Solve_Linear_Equations_multiple_right_hand.gif"></p><!-- Table of VI/Function Parameters for Instance 3 --><table class="Borderless"><tr><td class="Icon"><img src="c2dcdb.gif"></td><td><strong>Input Matrix</strong> must be a nonsingular, square or rectangular, complex matrix. A nonsingular matrix is a matrix in which no row or column contains a linear combination of any other row or column, respectively. You cannot always determine beforehand whether the matrix is singular, especially with large systems. When<strong> Input Matrix</strong> is singular, if the <strong>matrix type</strong> is General, the VI finds the least-square solution. Otherwise, the VI returns an error.</td></tr><tr><td class="Icon"><img src="c2dcdb.gif"></td><td><strong>Known Matrix</strong> is a matrix of known, dependent-variable values. <strong>Known Matrix</strong> must have the same number of rows as <strong>Input Matrix</strong>. If the number of rows in <strong>Known Matrix</strong> and <strong>Input Matrix</strong> are not equal, the VI sets <strong>Solution Matrix</strong> to an empty matrix and returns an error. </td></tr><tr><td class="Icon"><img src="cenum.gif"></td><td><strong>matrix type</strong> is the type of <strong>Input Matrix</strong>. Knowing the type of <strong>Input Matrix</strong> can speed up the computation of the <strong>Solution Matrix</strong> and can help you to avoid unnecessary computation, which could introduce numerical inaccuracy. <br><br><table class="Bordered"><tr><td class = "Bordered">0</td><td class = "Bordered">General (default)</td></tr><tr><td class = "Bordered">1</td><td class = "Bordered">Positive definite</td></tr><tr><td class = "Bordered">2</td><td class = "Bordered">Lower triangular</td></tr><tr><td class = "Bordered">3</td><td class = "Bordered">Upper triangular</td></tr></table></td></tr><tr><td class="Icon"><img src="i2dcdb.gif"></td><td><strong>Solution Matrix</strong> returns the solution X to AX = Y where A is the <strong>Input Matrix</strong> and Y is the <strong>Known Matrix</strong>. </td></tr><tr><td class="Icon"><img src="ii32.gif"></td><td><strong>error</strong> returns any <a href="../lverror/Error_Code_Ranges.html">error</a> or warning from the VI. You can wire <strong>error</strong> to the <a href="../glang/Err_Cluster_from_Code.html">Error Cluster From Error Code</a> VI to convert the error code or warning into an error cluster. </td></tr></table><!-- Additional VI/Function Information --><h2><a name="details">Solve Linear Equations Details</a></h2><p class="Body">Let A be an <em>m</em>-by-<em>n</em> matrix that represents the <strong>Input Matrix</strong>, Y be the set of <em>m</em> coefficients in <strong>Known Vector</strong>, and X be the set of <em>n</em> elements in <strong>Solution Vector</strong> that solves the system</p><p class="Indent1">AX = Y</p><p class="Body">When <em>m</em> &gt; <em>n</em>, the system has more equations than unknowns, so it is an over-determined system. The solution that satisfies AX = Y might not exist, so the VI finds the least-square solution X, which minimizes ||AX &#8211; Y||. </p><p class="Body">When <em>m</em> &lt; <em>n</em>, the system has more unknowns than equations, so it is an under-determined system. It may have infinite solutions that satisfy AX = Y. The VI finds one of these solutions.</p><p class="Body">In the case of <em>m</em> = <em>n</em>, if A is a nonsingular matrix&#8212;no row or column is a linear combination of any other row or column, respectively&#8212;then you can solve the system for X by decomposing the input matrix A into its lower and upper triangular matrices, L and U, such that</p><p class="Indent1">AX = LZ = Y</p><p class="Body">and</p><p class="Indent1">Z = UX</p><p class="Body">can be an alternate representation of the original system. Notice that Z is also an <em>n</em>-element vector.</p><p class="Body">Triangular systems are easy to solve using recursive techniques. Consequently, when you obtain the L and U matrices from A, you can find Z from the LZ = Y system and X from the UX = Z system. </p><p class="Body">In the case of <em>m</em> <img src="neq.gif"> <em>n</em>, A can be decomposed to an orthogonal matrix Q and an upper triangular matrix R, so that A = QR. The linear system then can be represented by QRX = Y. You then can solve RX = QTY.</p><p class="Body">You can easily solve this triangular system to get x using recursive techniques.</p><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;You cannot always determine beforehand whether the matrix is singular, especially with large systems. The Solve Linear Equations VI detects singular matrices and returns an error, so you do not need to verify whether you have a valid system before using this VI.</td></tr></table><p class="Body">The numerical implementation of the matrix inversion is numerically intensive and, because of its recursive nature, is also highly sensitive to round-off error introduced by the floating-point numeric coprocessor. Although the computations use the maximum possible accuracy, the VI cannot always solve the system.</p><h2>Solve Complex Linear Equations</h2><p class="Body">Let A represent the <em>m</em>-by-<em>n</em> <strong>Input Matrix</strong>, Y represent the set of <em>m</em> elements in the <strong>Known Vector</strong>, and X represent the set of <em>n</em> elements in the <strong>Solution Vector</strong> that solves for the system</p><p class="Indent1">AX = Y</p><p class="Body">When <em>m</em> &gt; <em>n</em>, the system has more equations than unknowns, so it is an over-determined system. Since the solution that satisfies AX = Y may not exist, the VI finds the least-square solution X, which minimizes ||AX &#8211; Y||.</p><p class="Body">When <em>m</em> &lt; <em>n</em>, the system has more unknowns than equations, so it is an under-determined system. It might have infinite solutions that satisfy AX = Y. The VI then selects one of these solutions.</p><p class="Body">When <em>m</em> = <em>n</em>, if A is a nonsingular matrix&#8212;no row or column is a linear combination of any other row or column, respectively&#8212;then you can solve the system for X by decomposing the <strong>Input Matrix</strong> A into its lower and upper triangular matrices, L and U, such that</p><p class="Indent1">AX = LZ = Y</p><p class="Body">and</p><p class="Indent1">Z = UX</p><p class="Body">can be an alternate representation of the original system. Notice that Z is also an <em>n</em>-element vector.</p><p class="Body">Triangular systems are easy to solve using recursive techniques. Consequently, when you obtain the L and U matrices from A, you can find Z from the LZ = Y system and X from the UX = Z system.</p><p class="Body">When <em>m</em> <img src="neq.gif"> <em>n</em>, A can be decomposed to an orthogonal matrix Q, and an upper triangular matrix R, so that A = QR, and the linear system can be represented by QRX = Y. You then can solve RX = Q<sup>H</sup>Y. You can easily solve this triangular system to get X using recursive techniques.</p><table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td><strong>Note</strong>&nbsp;&nbsp;The numerical implementation of the matrix inversion is numerically intensive and, because of its recursive nature, is also highly sensitive to round-off error introduced by the floating-point numeric coprocessor. Although the computations use the maximum possible accuracy, the VI cannot always solve for the system.</td></tr></table><!--Module Specific Content--><script type="text/javascript">if (typeof(writeVarRefs)=="function"){writeVarRefs("897");}</script><!-- Example Information --><h2><a name="examples">Example</a></h2><p class="Body">Refer to the Linear Algebra Calculator VI in the <span class="Monospace">labview\examples\Mathematics\Linear Algebra</span> directory for an example of using the Solve Linear Equations VI.</p><p class="Body"><a href="javascript:openVI('examples%5C%5CMathematics%5C%5CLinear%20Algebra%5C%5CLinear%20Algebra%20Calculator.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Open example&nbsp;<a href="javascript:findExamples(3745);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a>&nbsp;Find related examples</p></div></body></HTML>