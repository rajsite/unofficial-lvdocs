<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from lvioscanhelp.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Using I/O Variables (Real-Time, Windows)</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="using_io_scan"></a><h1>Using I/O Variables (Real-Time, Windows)</h1>
<p class="Body">
				
				An I/O variable is a type of <a href="../lvconcepts/SV_Publishing_Latest_Values.html">shared variable</a> that transfers I/O data. When accessed locally, I/O variables use the <a href="scan_engine.html">NI Scan Engine</a> for single-point access to I/O data. When accessed remotely, I/O variables use the <a href="../lvconcepts/NI_PSP.html">NI Publish-Subscribe Protocol (NI-PSP)</a> for single-point or buffered access to I/O data. An I/O variable can communicate directly with a physical I/O channel or can transfer custom I/O data between an FPGA VI and a real-time (RT) VI running on the same target.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="caution.gif"></td>
<td class="Dark-Red"><strong>Caution</strong>��The NI Scan Engine does not buffer data. To avoid losing data when accessing I/O variables locally, you must read each data point before the next point arrives and avoid writing data faster than the <a href="../lvioscanhelp/scan_engine.html#timing">NI Scan Engine period</a>.</td>
</tr>
</table>
<p class="Body">The following table summarizes the use cases for I/O variables:</p>
<table class="Bordered">
<tr>
<th class="Bordered">Use</th>
<th class="Bordered">I/O Variable Type</th>
</tr>
<tr>
<td class="Bordered">Transferring scaled I/O data between the I/O hardware and a LabVIEW VI without using the LabVIEW FPGA Module</td>
<td class="Bordered"><a href="#scanned">I/O Variables for Scaled I/O Data</a></td>
</tr>
<tr>
<td class="Bordered">Transferring custom FPGA-processed I/O data between a LabVIEW FPGA VI and a LabVIEW Real-Time VI running on the same hardware device</td>
<td class="Bordered"><a href="#direct">I/O Variables for Custom FPGA I/O Data</a></td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Refer to the specific hardware device documentation for information about NI Scan Engine support.</td>
</tr>
</table><a name="standard_IOV"></a><h2>I/O Variables for Scaled I/O Data</h2>
<p class="Body">To use I/O variables for scaled I/O data, you first must connect a supported I/O device to a target with the NI Scan Engine installed and then <a href="../lvhowto/Adding_Items_Project.html">add</a> the I/O device to the target in LabVIEW project.</p>
<p class="Body">When you add a supported I/O device to a supported target in the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window, LabVIEW automatically adds an I/O variable for each I/O channel. If you physically add an I/O device to a target included in the current LabVIEW project, you must add the new I/O device to the project and <a href="#deploying">deploy</a> the corresponding I/O variables before you can use them.</p>
<p class="Body">If you physically remove an I/O device from a target that is part of the current LabVIEW project, you must delete the I/O device from the project and redeploy the target that contained the I/O device. Redeploying the target ensures that the configuration on the target reflects the project configuration. You can use the <a href="../lvdialog/system_diff.html">Project &amp; System Comparison</a> dialog box to ensure that the project and target configurations match.</p><a name="user_IOV"></a><h2>I/O Variables for Custom FPGA I/O Data (FPGA Module or Real-Time Module)</h2>
<p class="Body">
				
				If the project includes an FPGA target that supports the NI Scan Engine, you can <a href="../lvfpgaconcepts/PFI_Data_Transfer.html" class="checkLink lvfpga">create user-defined I/O variables</a> to transfer custom I/O data between FPGA VIs and RT VIs running on the same hardware device.</p>
<p class="Body">You can add user-defined I/O variables to the block diagrams of FPGA VIs and RT VIs running on the chassis that hosts the user-defined I/O variables. However, because all I/O variables are unidirectional, you must configure the direction of each user-defined I/O variable as either <strong>FPGA to Host</strong> or <strong>Host to FPGA</strong>. For example, you can acquire analog I/O data and perform an FFT on the data in an FPGA VI, use an <strong>FPGA to Host</strong> I/O variable to transfer the processed data to a control loop in an RT VI, then use a <strong>Host to FPGA</strong> I/O variable to transfer output data from the RT control loop back to the FPGA for output to the physical I/O channel.</p>
<p class="Body">You must install the LabVIEW FPGA Module to create user-defined I/O variables. However, if you have only the Real-Time Module, you can access user-defined I/O variables from RT VIs even if you do not install the LabVIEW FPGA Module. For example, a developer with the LabVIEW FPGA Module could create user-defined I/O variables and compile an FPGA bitfile that accesses those variables. Then that developer could distribute the bitfile and the LabVIEW project containing the user-defined I/O variables to another developer without the FPGA Module, who could use the project to run the bitfile on a CompactRIO chassis. In this case, the second developer could not create new user-defined I/O variables but could use the Real-Time Module to access the user-defined I/O variables created by the first developer.</p>
<p class="Body"><span class="Platform">(Windows)</span> If <a href="#network-publishing">network publishing</a> is enabled on a user-defined I/O variable, you can use the variable in any RT VI or Windows-based VI within the same LabVIEW project. For example, you can use network-published I/O variables to create a user interface VI that runs on Windows.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��User-defined I/O variables support <a href="#scanned">scanned access</a> only. You cannot use <a href="#direct">direct access</a> for user-defined I/O variables.</td>
</tr>
</table><a name="configuring"></a><h2>Configuring I/O Variables</h2>
<p class="Body">
				
			You can configure I/O variables <a href="#Interactive_Config">interactively</a> at edit-time or run-time or <a href="#Programmatic_Config">programmatically</a> at run-time. You also can use a combination of these methods. The following table summarizes the advantages and disadvantages of each method:</p>
<table class="Bordered">
<tr>
<th class="Bordered">Method</th>
<th class="Bordered">Use Case</th>
<th class="Bordered">Advantages</th>
<th class="Bordered">Disadvantages</th>
</tr>
<tr>
<td class="Bordered">Interactive</td>
<td class="Bordered">Configuring settings for I/O variables when you have access to the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window.</td>
<td class="Bordered">Requires less programming.</td>
<td class="Bordered">
<ul>
<li>Configuration settings are not visible when you view the block diagram.</li>
<li>You can configure settings for an I/O variable only on the target that hosts the variable.</li>
</ul>
</td>
</tr>
<tr>
<td class="Bordered">Programmatic</td>
<td class="Bordered">
<ul>
<li>Configuring settings for I/O variables when you do not have access to the Project Explorer window. For example, if you plan to create a stand-alone application that uses an I/O variable and you need to change configuration settings for the I/O variable while running the application, configure the I/O variable programmatically. </li>
<li>Configuring settings for an I/O variable from a computer other than the target that hosts the I/O variable. For example, if you need to configure an I/O variable on a CompactRIO target from a host computer, configure the I/O variable programmatically.</li>
</ul>
</td>
<td class="Bordered">
<ul>
<li>Configuration settings are visible when you view the block diagram.</li>
<li>You can configure I/O variables remotely.</li>
</ul>
</td>
<td class="Bordered">Requires more programming.</td>
</tr>
</table><a name="Interactive_Config"></a><h3>Configuring I/O Variables Interactively</h3>
<p class="Body">Use the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box to configure a single I/O variable or the <a href="../lvdialog/DSC_SpConfigDB.html">Multiple Variable Editor</a> window to configure multiple I/O variables simultaneously.</p>
<p class="Body">You can update the description, network, and scaling options of an I/O variable even while running a VI that uses the I/O variable. However, you cannot update the name or data type of an I/O variable at run-time.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When you add a new I/O variable or change the configuration of an I/O variable, you must <a href="#deploying">deploy</a> the variable to activate the new configuration.</td>
</tr>
</table><a name="Programmatic_Config"></a><h3>Configuring I/O Variables Programmatically</h3>
<p class="Body">Complete the following steps to use the <a href="../lvprop/DynVar_Props_Meths.html">Variable</a> properties to configure an I/O variable programmatically:</p>
<ol>
<li>Add the <a href="../lvcomm/Variable_PropNode.html">Variable Property Node</a> to the block diagram.<br><br><SPAN title=" Add to the block diagram "><a href="javascript:placeObject(object4635);"><img src="add.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Add</SPAN>�
			<SPAN title=" Find on the palette "><a href="javascript:findObject(object4635);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find</SPAN><br><br></li>
<li>Right-click the <strong>reference</strong> input and select <strong>Create�Constant</strong> from the shortcut menu.</li>
<li>Click the arrow button on the right side of the shared variable refnum constant and select <strong>Browse</strong>.</li>
<li>Use the <a href="../lvdialog/Browse_Variables.html">Browse Variable Object</a> dialog box to select the I/O variable you want to configure.</li>
<li>Right-click the shared variable refnum constant and use the <strong>Select Variable Class</strong> shortcut menu to select the class of the property you want to use.</li>
<li>Click the white area of the Variable Property Node and select the property you want to use.</li>
<li>(Optional) Use the Positioning tool to <a href="../lvhowto/Resizing_Array_Functions.html">resize</a> the Variable Property Node to display more than one property simultaneously.</li>
</ol>
<p class="Body">The following figure shows an example of programmatically configuring an I/O variable on a remote target:</p>
<p class="Anchor"><img src="loc_bd_ioprogrammaticconfig.gif"></p>
<p class="Body">In this example, the Variable Property Node specifies the current limit for a channel on a CompactRIO module by configuring the I/O variable that corresponds to that channel.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��
					If the Variable Property Node cannot connect to the remote I/O variable after five seconds, the configuration call times out. Complete the following steps to change this timeout period:
						<ol>
<li>Open the <span class="Monospace">labview\LabVIEW.ini</span> file as a text file.</li>
<li>On a new line, enter <span class="Monospace">RemoteIOVConfigurationTimeout=</span> followed by the new timeout period in number of seconds. For example, if you want to extend the timeout period to 10 seconds, enter <span class="Monospace">RemoteIOVConfigurationTimeout=10</span>.</li>
<li>Save and close the file.</li>
</ol>
				</td>
</tr>
</table><a name="deploying"></a><h2>Deploying I/O Variables</h2>
<p class="Body">To deploy I/O variables, right-click the project item that contains the I/O variables in the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window and select <strong>Deploy</strong> from the shortcut menu.</p>
<p class="Body">When you run a VI that contains I/O variable nodes, LabVIEW automatically deploys the I/O variable containers to which those I/O variables belong. This action deploys all of the I/O variables in the containers.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If an I/O driver fails to initialize, LabVIEW aborts loading all I/O variables in the project. In this case, the I/O variables might still appear in the project, but if an application attempts to access the variables, a run-time error occurs. Refer to the specific target I/O driver documentation for information about debugging I/O driver errors.</td>
</tr>
</table><a name="scaling"></a><h2>Scaling I/O Variable Values</h2>
<p class="Body">You can enable linear scaling on an I/O variable or <a href="#aliasing">alias</a> on the <a href="../lvdialog/sm_scale_page.html">Scaling</a> page of the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box. However, I/O variables do not support nonlinear scaling.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Some I/O buses implement hardware scaling. In this case, LabVIEW I/O variable scaling provides an additional scaling layer. LabVIEW does not overwrite the hardware scaling. LabVIEW uses the hardware-scaled value from the I/O bus as the raw value when calculating the software-scaled value.</td>
</tr>
</table><a name="aliasing"></a><h2>Creating I/O Aliases</h2>
<p class="Body">You can create aliases of an I/O variable to name and scale the I/O data differently in different contexts. For example, if you have an I/O variable connected to a thermocouple input, you can create a Celsius alias and a Fahrenheit alias. Then you could scale each alias and use the aliases to display the temperature in both units of measure.</p>
<p class="Body">The value of an I/O alias is linked bidirectionally to the value of the parent, so updating the value of the parent updates the value of the I/O alias, and updating the value of the I/O alias updates the value of the parent. By extension, updating any link in a chain of I/O aliases updates all other links in the chain.</p>
<h3>Creating a Single I/O Alias</h3>
<p class="Body">To create an I/O alias, right-click a target that contains I/O variables in the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window and select <strong>New�Variable</strong> from the shortcut menu to display the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a>. Enter a name for the I/O alias and select <strong>I/O Alias</strong> from the <strong>Variable Type</strong> pull-down menu. Then click the <strong>Browse</strong> button and select the existing I/O variable or I/O alias to which you want to bind the new I/O alias.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When you bind an alias to an I/O variable, ensure that the data type of the alias matches the data type of the underlying I/O variable.</td>
</tr>
</table>
<p class="Body">You can use the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window to edit the name, description, network-publishing settings, and scaling of an I/O alias. You also can use the <a href="../lvdialog/DSC_SpConfigDB.html">Multiple Variable Editor</a> window to edit multiple I/O aliases simultaneously.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You cannot deploy a library that contains both I/O aliases and other types of shared variables. You must deploy I/O aliases in a <a href="../lvconcepts/Project_Libraries.html#Project_Sublibraries">separate library</a>.</td>
</tr>
</table>
<h3>Creating Multiple I/O Aliases Simultaneously</h3>
<p class="Body">You can use the <a href="../lvdialog/DSC_Batch_Var_Creation.html">Batch Variable Creation</a> dialog box to create multiple I/O aliases simultaneously. Complete the following steps to batch create I/O aliases:</p>
<ol>
<li>Create a single I/O alias to use as a template for the batch creation process.</li>
<li>Right-click the variable library that contains the I/O alias and select <strong>Create Variables</strong> from the shortcut menu to display the <a href="../lvdialog/DSC_Batch_Var_Creation.html">Batch Variable Creation</a> dialog box.</li>
<li>Select <strong>Copy properties from</strong>, click the <strong>Browse</strong> button, and select the existing I/O alias that you want to use as a template.</li>
<li>Enter the number of I/O aliases you want to create in the <strong>Number to create</strong> field and click the <strong>OK</strong> button to create the new I/O aliases.</li>
</ol>
<p class="Body">After you complete these steps, LabVIEW automatically opens the <a href="../lvdialog/DSC_SpConfigDB.html">Multiple Variable Editor</a> window, which you can use to edit the new variables. For example, you might want to edit the <strong>Alias Path</strong> of each I/O alias to bind to a unique I/O variable.</p><a name="forcing"></a><h2>Forcing I/O Variable Values</h2>
<p class="Body">You can force the value of an I/O variable either <a href="#force_i">interactively</a> or <a href="#force_p">programmatically</a>. Forcing an I/O variable causes the associated I/O data to assume the value you specify until you unforce the variable, reboot the target, or force the variable to assume a different value. Unforcing an I/O variable returns control of the I/O value to the NI Scan Engine.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When an I/O variable is forced, each I/O variable access takes slightly longer than when the variable is not forced, which could cause a loop to run late if the loop period is not long enough to accommodate the forcing overhead.</td>
</tr>
</table><a name="force_i"></a><h3>Forcing I/O Variable Values Interactively</h3>
<p class="Body">Use the <a href="../sysman/sysman.html">NI Distributed System Manager</a> to <a href="../sysman/Forcing_IO.html">force</a> or unforce the value of an I/O variable during debugging or to manually control an I/O channel. From LabVIEW, select <strong>Tools�Distributed System Manager</strong> to launch the NI Distributed System Manager. You also can launch the Distributed System Manager by right-clicking an RT target in the <a href="../lvdialog/Project_Explorer_Window.html">Project Explorer</a> window and selecting <strong>Utilities�View in System Manager</strong>.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You can use the NI Distributed Manager <a href="../sysman/ni_acl_db.html">security settings</a> to prevent users from forcing I/O variables from within the NI Distributed System Manager.</td>
</tr>
</table><a name="force_p"></a><h3>Forcing I/O Variable Values Programmatically</h3>
<p class="Body">Use the <a href="../lvioscan/Forcing_Palette.html">Forcing</a> VIs to force and unforce I/O variables programmatically.</p>
<h3>Forcing I/O Aliases</h3>
<p class="Body">Forcing applies to aliases as well as standard I/O variables. When you force an I/O variable, you also force all associated aliases. When you force an alias, you also force the parent I/O variable and all other associated aliases.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��LabVIEW applies scaling to forced values as if the forced value were the actual value of the I/O channel. So, when you force one link in a chain of aliases, all links in the chain scale appropriately.</td>
</tr>
</table>
<h3>Forcing and Unforcing all I/O Variables on a Target Simultaneously</h3>
<p class="Body">You can use the global forcing state of a target to force and unforce all I/O variables on the target simultaneously. You can enable and disable global forcing on a target either interactively or programmatically.</p>
<p class="Body">Use the <strong>Enable Forcing</strong> and <strong>Disable Forcing</strong> buttons in the NI Distributed System Manager to enable and disable global forcing on a target interactively. Use the <a href="../lvioscan/Enable_Forcing.html">Enable Variable Forcing</a> and <a href="../lvioscan/disable_forcing.html">Disable Variable Forcing</a> VIs to enable and disable global forcing on a target programmatically.</p>
<p class="Body">Complete the following steps to force all the I/O variables on a target simultaneously:</p>
<ol>
<li>Disable forcing on the target so that you can set the desired forcing values of the I/O variables individually without individually forcing the I/O variables.</li>
<li>Set the desired forcing values for all the I/O variables on the target.</li>
<li>Enable forcing on the target to force all I/O variables on the target simultaneously.</li>
</ol><a name="network-publishing"></a><h2>Accessing I/O Variables Remotely</h2>
<p class="Body">If network-publishing is enabled on an I/O variable, you can access the I/O variable from a remote computer connected to the same network as the target that hosts the I/O variable. You can access remote I/O variables interactively using the <a href="../sysman/iov_probe.html">I/O Variable Probe</a> view in the NI Distributed System Manager. You also can access remote I/O variables programmatically <a href="../lvconcepts/SV_Reading_and_Writing.html">in a VI</a>.</p>
<p class="Body">Use the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box to enable and disable network publishing on an I/O variable. Enable network-publishing if you need to monitor I/O values on a host computer or access an I/O variable from a remote target. Use the <a href="../lvdialog/io_scan_page.html">Scan Engine</a> page to set the global network-publishing rate for all I/O variables on a target.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you do not plan to access I/O variables remotely, disable network publishing to minimize CPU overhead. When you disable network publishing on an I/O variable or I/O alias, you cannot access the variable from a VI running on another computer. However, you still can force the variable from the NI Distributed System Manager. To prevent users from forcing an I/O variable, use the System Manager <a href="../sysman/ni_acl_db.html">security settings</a>.</td>
</tr>
</table><a name="access"></a><h2>Accessing I/O Variables Locally</h2>
<p class="Body">LabVIEW adds I/O variables to a global scan engine memory map and updates the values of all I/O variables concurrently. However, for I/O variable access on the local target that hosts the I/O variable, you can configure each node to use either scanned access or direct access.</p>
<p class="Body">Complete the following steps to select the local access mode of an I/O variable node:</p>
<ol>
<li>Right-click an I/O variable node on the block diagram.</li>
<li>Select <strong>Local Access Mode</strong> from the shortcut menu</li>
<li>Select the access mode you want to use for the node.</li>
</ol>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��LabVIEW adds all I/O variables to the global scan engine memory map regardless of the access mode you use for each variable.</td>
</tr>
</table><a name="choosing_access_method"></a><h3>Selecting a Local Access Mode</h3>
<p class="Body">In general, scanned access is appropriate for groups of I/O channels with similar update rates, and direct access is appropriate for individual I/O channels that update asynchronously to the scan period. The following table summarizes when to use each I/O access method:</p>
<table class="Bordered">
<tr>
<th class="Bordered">Common Use</th>
<th class="Bordered">Access Method</th>
</tr>
<tr>
<td class="Bordered">Single-point access to I/O channels that share a common update rate</td>
<td class="Bordered"><a href="#scanned">Scanned</a></td>
</tr>
<tr>
<td class="Bordered">Single-point access to local I/O channels asynchronous to the NI Scan Engine period, such as a single write for an emergency stop output (not supported for user-defined I/O variables)</td>
<td class="Bordered"><a href="#direct">Direct</a></td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You can use direct access for I/O channels that update slower than the NI Scan Engine period. However, in such cases, scanned access typically provides the same I/O behavior more efficiently than direct access.</td>
</tr>
</table><a name="scanned"></a><h3>Scanned Access</h3>
<p class="Body">By default, LabVIEW configures I/O variable nodes to use scanned access. Use scanned access for sets of I/O channels that update at a single rate and for expansion I/O channels. Scanned access uses the scan engine memory map to perform non-blocking I/O reads and writes, as shown in the following figure:</p>
<p class="Anchor"><img src="loc_eps_ScannedAccess.gif"></p>
<p class="Body">Each time you read from an I/O variable using scanned access, the NI Scan Engine immediately returns the most recent value stored in the memory map without blocking, or waiting for a new value. During each scan, LabVIEW reads the most recent I/O value and writes that value to the NI Scan Engine memory map.</p>
<p class="Body">Each time you write to an I/O variable using scanned access, you overwrite the previous value stored in the scan engine memory map. During each scan, LabVIEW pushes the value stored in the memory map to the physical I/O channel. To prevent data loss, you must <a href="scan_engine.html#sync">synchronize</a> all I/O variable write operations to the scan period.</p><a name="direct"></a><h3>Direct Access</h3>
<p class="Body">Use direct access to read or write single-point local I/O channels asynchronously to the scan period. You can use direct access when the application needs to write a value as soon as possible. Direct access bypasses the scan engine memory map and communicates directly with the I/O device driver to perform non-blocking I/O reads and writes, as shown in the following figure:</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��User-defined I/O variables do not support direct access.</td>
</tr>
</table>
<p class="Anchor"><img src="loc_eps_ImmediateAccess.gif"></p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you use the NI Scan Engine in conjunction with the RIO Scan Interface, the hardware scan signal governs updates to I/O. If you write a value via direct access under the idle state of the hardware scan signal, the value propagates to the hardware after the idle state of the hardware scan signal ends.</td>
</tr>
</table>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The speed of direct access varies by controller, I/O module, and communication protocol. Refer to the specific hardware documentation for more information about I/O access speed.</td>
</tr>
</table><a name="id_IOV_icons"></a><h2>Interpreting I/O Variable Node Icons</h2>
<p class="Body">Each I/O variable node on the block diagram includes a glyph to indicate one of the following access methods:</p>
<table class="Bordered">
<tr>
<th class="Bordered">Access Method</th>
<th class="Bordered">Node Appearance</th>
</tr>
<tr>
<td class="Bordered">NI-PSP</td>
<td class="Bordered">
<p class="Anchor"><img src="noloc_bd_networked.gif"></p>
</td>
</tr>
<tr>
<td class="Bordered">Scanned</td>
<td class="Bordered">
<p class="Anchor"><img src="noloc_bd_scanned.gif"></p>
</td>
</tr>
<tr>
<td class="Bordered">Direct</td>
<td class="Bordered">
<p class="Anchor"><img src="noloc_bd_direct.gif"></p>
</td>
</tr>
</table>
<p class="Body"><img style="display:inline" src="back_arrow.gif"> <a href="../lvconcepts/Data_Comm.html"><em>Data Communication Methods</em> Home</a></p>
</body>
</html>