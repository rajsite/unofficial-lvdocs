<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Building_the_Block_Diagram.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Block Diagram Data Flow</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Block_Diagram_Data_Flow"></a><h1>Block Diagram Data Flow</h1>
<p class="Body">
				
				
				
				
				
				LabVIEW follows a dataflow model for running VIs. A block diagram node executes when it receives all required inputs. When a node executes, it produces output data and passes the data to the next node in the dataflow path. The movement of data through the nodes determines the execution order of the VIs and functions on the block diagram.</p>
<p class="Body">
				Visual Basic, C++, JAVA, and most other text-based programming languages follow a control flow model of program execution. In control flow, the sequential order of program elements determines the execution order of a program.</p>
<p class="Body">In LabVIEW, the flow of data rather than the sequential order of commands determines the execution order of block diagram elements. Therefore, you can create block diagrams that have simultaneous operations. For example, you can run two For Loops simultaneously and display the results on the front panel, as shown in the following block diagram.</p>
<p class="Anchor"><img src="loc_bd_parallel_for_loops.gif"></p>
<p class="Body">LabVIEW is a <a href="Multitask_Multithread_Multip.html">multitasking
				and multithreaded</a> system, running multiple execution threads and multiple VIs simultaneously.</p><a name="Data_Dependency_and_Artificial_Data_Dependency"></a><h2>Data Dependency and Artificial Data Dependency</h2>
<p class="Body">
				
				The control flow model of execution is instruction driven. Dataflow execution is data driven, or data dependent. A node that receives data from another node always executes after the other node completes execution.</p>
<p class="Body">
				Block diagram nodes not connected by wires can execute in any order. You can use <a href="Block_Diagram_Data_Flow.html#Flow-Through_Parameters">flow-through parameters</a> to control execution order when natural data dependency does not exist. You can use a <a href="sequence_structures_concepts.html">sequence structure</a> to control execution order when flow-through parameters are not available. </p><a name="Missing_Data_Dependencies"></a><h3>Missing Data Dependencies</h3>
<p class="Body">
				Do not assume left-to-right or top-to-bottom execution when no data dependency exists. Make sure you explicitly define the sequence of events when necessary by wiring the dataflow. </p>
<p class="Body">In the following block diagram, no dependency exists between the <a href="../glang/Read_File.html">Read from Binary File</a> function and the <a href="../glang/Close_File.html">Close File</a> function because the Read from Binary File function is not wired to the Close File function. This example might not work as expected because there is no way to determine which function runs first. If the Close File function runs first, the Read from Binary File function does not work.</p>
<p class="Anchor"><img src="loc_bd_nodepend.gif"></p>
<p class="Body">The following block diagram establishes a dependency by wiring an output of the Read from Binary File function to the Close File function. The Close File function does not run until it receives the output of the Read from Binary File function.</p>
<p class="Anchor"><img src="loc_bd_depend.gif"></p><a name="Flow-Through_Parameters"></a><h3>Flow-Through Parameters</h3>
<p class="Body">
				Flow-through parameters, typically a refnum or <a href="Error_Checking_and_Error_Handling.html">error cluster</a>, return the same value as the corresponding input parameter. Use these parameters to control execution order when natural data dependency does not exist. By wiring the flow-through output of the first node you want to execute to the corresponding input of the next node you want to execute, you create an artificial data dependency. Without these flow-through parameters, you must use sequence structures to ensure that data operations take place in the order you want.</p><a name="Data_Flow_and_Managing_Memory"></a><h2>Data Flow and Managing Memory</h2>
<p class="Body">
				
				Dataflow execution makes managing memory easier than the control flow model of execution. In LabVIEW, you do not allocate memory for variables or assign values to them. Instead, you create a block diagram with wires that represent the transition of data. </p>
<p class="Body">VIs and functions that generate data automatically allocate the memory for that data. When the VI or function no longer uses the data, LabVIEW deallocates the associated memory. When you add new data to an array or a string, LabVIEW allocates enough memory to manage the new data.</p>
<p class="Body">Because LabVIEW automatically handles memory management, you have less control over when memory is allocated or deallocated. If a VI works with large sets of data, you need to understand when <a href="Using_Profile_Window.html">memory allocation</a> takes place. Understanding the principles involved can help you write VIs with significantly smaller memory requirements. <a href="VI_Memory_Usage.html#Rules_for_Better_Memory_Usage">Minimizing memory usage</a> as you develop can help you increase the speed at which VIs run. </p>
</body>
</html>