<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Object_Oriented_Programming.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Developing LabVIEW Classes</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>Developing LabVIEW Classes</h1>
<p class="Body">
				
				
				
                While LabVIEW object-oriented programming is similar to other object-oriented programming languages conceptually, because LabVIEW is a dataflow graphical programming environment some differences exist in how LabVIEW manipulates and interacts with LabVIEW class data and how you can debug the class code. </p>
<p class="Body">Objects in LabVIEW are passed by value, not by reference. LabVIEW creates copies of the object following the same rules traditionally used for <a href="../lvconcepts/Grouping_Data_with.html">clusters and arrays</a>.</p><a name="Constructors"></a><h2>Constructors and Destructors</h2>
<p class="Body">
				
				
				
				
				
				
				Constructors and destructors in LabVIEW object-oriented programming are implicit. You do not have to call a constructor to initialize LabVIEW class data. LabVIEW calls a default constructor whenever LabVIEW needs to initialize a class. Initialization of a class typically occurs at a front panel control or block diagram constant. LabVIEW initializes the values of the class as the default values you set in the private data control. When LabVIEW no longer needs the LabVIEW class information, LabVIEW handles memory deallocation as it does for <a href="../lvconcepts/VI_Memory_Usage.html#Understanding_When_Memory_Is_Deallocated">clusters and arrays</a>. If you want to set another value for the class data, you must create a member VI that sets the new value. For example, if you set the default value of <strong>Number of Gears</strong> in class Vehicle to 3 when you create class Vehicle, and you want to assign a different value to <strong>Number of Gears</strong> that class Truck inherits, you must create a member VI that changes the value in class Vehicle. One option for setting a new value is to create a member VI that has no inputs but outputs a class with the value you want to assign to <strong>Number of Gears</strong>, thereby creating a block diagram constant of the class data type.</p><a name="Flatten_Unflatten_Data_Mutation"></a><h2>Flattening and Unflattening Data</h2>
<p class="Body">
				
				
				
				
				
				
				LabVIEW stores data as <a href="../lvconcepts/Flattened_Data.html">flattened data</a>. The <a href="../glang/Flatten_To_String.html">Flatten To String</a> and <a href="../glang/Unflatten_From_String.html">Unflatten From String</a> functions can handle all class data types. LabVIEW flattens and unflattens the data automatically. While all <a href="../lvconcepts/Type_Descriptors.html">type descriptors</a> retain the <em>type</em> of data for flattened data types in LabVIEW, the LabVIEW class flattened data itself retains this information as well as class version information. Because the LabVIEW class retains information pertinent to unflattening the LabVIEW class, if the LabVIEW class cannot be found because you move or delete the class, LabVIEW cannot unflatten the data and you receive an error message. Similar to the behavior LabVIEW exhibits when it encounters a missing subVI, you can open the member VI and notice LabVIEW dims the control that is missing the LabVIEW class data. When you load the LabVIEW class corresponding to the broken control, the data is unflattened and the control is no longer broken.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You also can use the <a href="../glang/Flatten_To_XML.html">Flatten To XML</a> and <a href="../glang/Unflatten_From_XML.html">Unflatten From XML</a> functions to handle class data.</td>
</tr>
</table><a name="Mutation"></a><h2>Mutating Data</h2>
<p class="Body">A LabVIEW class control reports a warning if the data in the control is written with a more recent version of the LabVIEW class than the version of the class LabVIEW has in memory. LabVIEW increments the LabVIEW class version number anytime you make changes to the data type of the private data control or the inheritance of the class. You can view the LabVIEW class version number in the <a href="../lvdialog/C_Library_Props_DB.html">Class Properties</a> dialog box. LabVIEW increments the version number of the class automatically if:</p>
<ul>
<li>the LabVIEW class inheritance changes.</li>
<li>the private data control of the LabVIEW class changes. These changes include adding, replacing, reordering, or deleting controls; changing the representation of a control; or any updates from modified type definitions.</li>
<li>the LabVIEW class loads in a new version of LabVIEW.</li>
<li>you increment the version number in the <a href="../lvdialog/C_Library_Props_DB.html">Class Properties</a> dialog box manually. You might do this to indicate a new revision of the class.</li>
</ul>
<p class="Body">If you rename a class, LabVIEW considers it a new class, deletes the mutation history of the class, and resets the version number to 1.0.0.0. LabVIEW renames the class if you do one of the following actions:</p>
<ul>
<li>Rename the class by selecting <strong>File�Save As</strong> from the pull-down menu.</li>
<li>Move the class into an owning library.</li>
<li>Move the class out of an owning library.</li>
<li>Rename the <span class="Monospace">.lvclass</span> file on disk.</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you decide to change the name back to the original class name without making any other changes, the class will not be identical to the original class because the mutation history no longer exists. For example, if you rename class Vehicle to Vehicle #1 and then change the name back to Vehicle, class Vehicle is no longer identical to the original class.</td>
</tr>
</table>
<p class="Body">
				
				
				
                            Tracking the version number of the LabVIEW class is beneficial to LabVIEW class users who develop applications using LabVIEW classes. For example, you have a LabVIEW class in an application that uses an unsigned 32-bit integer in the private data control of the class. A LabVIEW class developer can send you a version of the LabVIEW class that changes the numeric control in the private data control to a double-precision floating-point number. Because LabVIEW tracks version changes and knows how to flatten and unflatten data on all LabVIEW classes, you can replace the old version of the LabVIEW class with the new version and run the program without making changes to it. </p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you try to unflatten data from a future version of a LabVIEW class, LabVIEW returns an error. For example, this error might occur if you have data with a version number of 1.0.0.3 but the LabVIEW class in memory is version 1.0.0.2.</td>
</tr>
</table>
<p class="Body">When LabVIEW encounters an older version of the LabVIEW class, LabVIEW handles the data mutation in one of the following ways:</p>
<ul>
<li>If you remove classes from the LabVIEW class hierarchy, LabVIEW deletes the flattened data of the class you remove. For example, class C inherits from class B, which inherits from class A. If you change the inheritance of class C to inherit directly from class A, LabVIEW deletes the flattened data of class B in that instance.</li>
<li>If you add layers in the LabVIEW class hierarchy, LabVIEW inserts the class default data of the class you insert. For example, class C inherits from class A. If you change the inheritance of class C to inherit from class B, which inherits from class A, LabVIEW inserts the class default data of class B.</li>
<li>If you add an element to the private data cluster of the class at the end of the <a href="../lvhowto/ChangingtheOrderofFPanelOb.html">tabbing order</a>, LabVIEW unflattens the old data and appends the class default data.</li>
<li>If you delete an element from the private data cluster of the class and do not add any new elements, LabVIEW unflattens the old data and deletes the information about the element. </li>
<li>If you change the tabbing order of the private data cluster of the class, LabVIEW reorders the unflattened data accordingly.</li>
<li>If you add, delete, replace, or reorder the private data cluster of the class in the same edit, LabVIEW creates and executes a procedure for appropriately mutating the old data through combinations of the steps above.</li>
</ul>
<p class="Body">LabVIEW always applies mutations across multiple versions serially, for example from 1.0.0.2 to 1.0.0.6.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You cannot revert a LabVIEW class if the class version is incremented. LabVIEW does not have sufficient information to undo a change to the data in LabVIEW class controls and indicators. To revert current changes, do not save any changes. Unload the class and all VIs that reference the class and then reload from disk.</td>
</tr>
</table>
<p class="Body">Refer to the following <a href="javascript:WWW(WWW_PrsrvClassData)">support document</a> at <span class="Monospace">ni.com</span> for more information about how LabVIEW mutates data when you edit a LabVIEW class.</p><a name="casting"></a><h2>Casting LabVIEW Classes</h2>
<p class="Body">
				
				
				
				
				
				
				
				
				
               You can upcast classes using the <a href="../glang/To_More_Generic_Class.html">To More Generic Class</a> function and downcast using the <a href="../glang/To_More_Specific_Class.html">To More Specific Class</a> function. You also can use these functions for refnum data types that have an inheritance hierarchy, such as <a href="../lvhowto/Types_of_Refnum_Controls.html">VI Server Control Refnums</a>, and the functionality is identical. Using the To More Generic Class function does not change the data but it does change the type of the wire that carries the data. However, the function has no effect when the VI is running. The primary use of the To More Generic Class function is as a way of eliminating coercion dots for those programmers who have a strict code convention against such data conversions.</p>
<p class="Body">Using the To More Specific Class function leaves the data unchanged unless an error occurs. If the data on the wire at run time is not of the more specific class, the function returns an error and the output data is the default value of the wire type. The primary use of the To More Specific Class function is to do type testing on a value of a parent class. Frequently programmers connect the same parent class wire to several To More Specific Class function calls, each going to a different more specific class, and then execute different code based on which To More Specific Class function does not return an error. This is highly inefficient. If you are considering this method of testing and have permission to modify the parent class, you might <a href="../lvhowto/creating_mem_VIs.html">write a dynamic member VI</a> on the parent class and have each of the child classes override it with the functionality appropriate for each child class.</p>
<p class="Body">If, at run time, LabVIEW detects that you wired a child class object to a subVI that accepts a parent class object, LabVIEW can downcast the subVI output to a child class object automatically. Automatic downcasting does not require you to use the To More Specific Class function. However, automatic downcasting can occur only if LabVIEW can guarantee that the class object you wire to the subVI is compatible with the input the subVI accepts. For example, if you store a class object in a variant and wire the variant data to a subVI, LabVIEW cannot guarantee that the subVI contains data that belongs to the same class as the data the variant originally stored. To help LabVIEW check that the class object you wire to the subVI is compatible with the class object the subVI accepts, use the <a href="../glang/preserve_runtime_class.html">Preserve Run-Time Class</a> function. If the two objects are incompatible, the function returns an error and sets the class of the output data to the parent class the subVI accepts. You also can use this function with <a href="../glang/new_data_value_reference.html">data value references</a>. The <a href="../glang/inplace_datareference.html">Data Value Reference Read / Write Element</a> border node must preserve run-time type. You can use the Preserve Run-Time Class function to check that the class object you wire to the Data Value Reference Write node is compatible with the class object you wired to the Data Value Reference Read border node.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��LabVIEW cannot automatically downcast recursive subVIs. Automatic downcasting breaks caller VIs if they call recursive subVIs on the block diagram of dynamic dispatch VIs or inside In Place Element structures for data value references. Use the Preserve Run-Time Class function on the block diagram of the recursive subVI to check that the class object you wire to the subVI is compatible with the class object the subVI accepts. If the class objects are compatible, the caller VIs outside of the recursive cycle do not break.</td>
</tr>
</table><a name="Locking_Classes"></a><h2>Locking and Unlocking LabVIEW Classes</h2>
<p class="Body">
				
				
				
				
				
                    You can <a href="../lvhowto/Locking_Classes.html">lock LabVIEW classes</a> to prohibit LabVIEW class users from viewing the member VIs that are part of the internal implementation of the application. Locking the LabVIEW class prevents access to the private member VIs which in turn can help prevent errors being introduced to the application.
				As with <a href="../lvhowto/Library_Passwords.html">project libraries</a>, adding password protection to LabVIEW classes does not add password protection to the member VIs. <a href="../lvdialog/C_Item_Lib_Page.html">You must password protect the member VIs individually</a>.
			</p>
<p class="Body">If you lock a LabVIEW class, only the data type appears in the <a href="../lvdialog/Context_Help_Window.html">Context Help</a> window when you move the cursor over the class wire. If you move the cursor over the wire of an unlocked LabVIEW class, the <strong>Context Help</strong> window shows the private data of the class and the private data of the class for all unlocked parent classes. Similar rules apply to the information LabVIEW displays in generic probes. Refer to <a href="../lvconcepts/Using_Classes.html#Probes_in_Classes">Using Probes in LabVIEW Classes</a> for information about using generic probes with LabVIEW classes.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Notice the <a href="../lvdialog/Context_Help_Window.html">Context Help</a> window for the LabVIEW class wire and the LabVIEW class control display different information. The LabVIEW class control displays class description information for end users, while the LabVIEW class wire displays additional information about the data type for the LabVIEW class user.</td>
</tr>
</table>
<p class="Body">Because LabVIEW class users only can view the class information you make available, be sure to adequately document the LabVIEW class you develop. You can <a href="../lvhowto/adding_items_class.html">add class descriptions</a> in the <a href="../lvdialog/C_Library_Props_DB.html">Class Properties</a> dialog box and you can <a href="../lvhowto/CreatingEditing_VI_Desc.html">add member VI descriptions</a> in the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box.</p><a name="Probes_in_Classes"></a><h2>Using Probes in LabVIEW Classes</h2>
<p class="Body">
				
				
				
                        You can use <a href="../lvconcepts/Debug_Techniques.html#Types_of_Probes">generic probes and custom probes</a> to debug LabVIEW classes.</p>
<p class="Body">
				You can use generic probes on LabVIEW class wires. The generic probe on a LabVIEW class wire shows the name of the class at run time, the private class data, and the private class data for all of the parent classes. If you use the generic probe on a locked LabVIEW class, only the name of the class at run time and any unlocked private data within the class hierarchy is visible in the probe. In the following image, class Vehicle, on the left, is locked and LabVIEW does not display the private data of the class: <strong>Number of Gears</strong>, <strong>Number of Doors</strong>, <strong>Color</strong>, <strong>Make</strong>, and <strong>Model</strong>. Class Truck is not locked and LabVIEW does display its private data. Notice that LabVIEW does not display the inherited private data of class Vehicle in the generic probe for class Truck because class Vehicle is locked.</p>
<p class="Anchor"><img src="loc_bd_Main_Probes.gif"></p>
<p class="Body">
				<a href="../lvhowto/Creating_Custom_Probes.html">Creating custom default probes</a> for LabVIEW classes is useful. You only can use a custom probe on a LabVIEW class wire of the exact class type as the wire type or of an ancestor of the wire type. A LabVIEW class developer can create custom probes that are members of the class and capable of displaying the private data of the class directly. A LabVIEW class user can create a custom default probe that may display any information available using public methods of the class.</p>
<p class="Body">A class developer can <a href="../lvhowto/Custom_Probe_Classes.html">set a custom probe as the default probe</a> for a LabVIEW class user. The generic probe of a locked LabVIEW class does not allow the LabVIEW class user to access any information about the value of the data because the data is private. Creating custom probes and setting them as the default probe for a LabVIEW class allows the class developer to provide the LabVIEW class user with a default probe that displays the appropriate data after the class developer locks the class. The custom probe must be a member of the LabVIEW class for the LabVIEW developer to set it as the default probe.</p><a name="Distributing"></a><h2>Distributing a LabVIEW Class to other Developers and Users</h2>
<p class="Body">
				
				
				
				You can distribute the LabVIEW class you develop to other LabVIEW class developers and LabVIEW class users. You can distribute the class in several ways so choose the manner that most suits your needs. You can use the <a href="../lvconcepts/Building_StandAloneApps.html">Application Builder</a> to <a href="../lvhowto/develop_distribute_applications.html">create a zip file</a> to distribute the class or classes. You also can <a href="../lvconcepts/Using_Classes.html#Locking_Classes">lock the LabVIEW class</a> before you distribute it to limit the access the LabVIEW class user has to the private data and member VIs. Locking the class can help prevent users from introducing errors in the application.
			</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="tip.gif"></td>
<td><strong>Tip</strong>��You also can access LabVIEW classes through a .NET interop assembly. LabVIEW can generate a .NET class for LabVIEW classes that you specify, and you can access these .NET classes through a .NET assembly.</td>
</tr>
</table>
</body>
</html>