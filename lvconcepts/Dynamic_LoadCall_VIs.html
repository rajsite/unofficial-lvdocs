<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Programmatically_Controlling_VIs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Dynamically Loading and Calling VIs</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Dynamically_Loading_and_Calling_VIs"></a><h1>Dynamically Loading and Calling VIs</h1>
<p class="Body">
					
					
					
You can dynamically load VIs instead of using statically linked subVI calls. A statically linked subVI is one you place directly on the block diagram of a caller VI. It loads at the same time the caller VI loads.</p>
<p class="Body">
					Unlike statically linked subVIs, dynamically loaded VIs do not load until the caller VI loads them with the <a href="../glang/Open_VI_Reference.html">Open VI Reference</a>. If you have a large caller VI, you can save load time and memory by dynamically loading the VI because the VI does not load until the caller VI needs it, and you can release it from memory after the operation completes. You also can use the <a href="../lvdialog/Call_Configuration.html">VI Call Configuration</a> dialog box to <a href="../lvhowto/ConfiguringCalls.html">configure when to load the subVI</a>.</p><a name="Call_By_Reference_Nodes_and_Strictly_Typed_VI_Refnums"></a><h2>Call By Reference Nodes and Strictly Typed VI Refnums</h2>
<p class="Body">
					
					
					
					
					
					
					
Use the <a href="../glang/Call_By_Reference_Node.html">Call By Reference</a> node or the <a href="../glang/start_asynchronous_call.html">Start Asynchronous Call</a> node to dynamically call VIs. Both nodes begin a call to the subVI specified by their <strong>reference</strong> input. However, the Start Asynchronous Call node <a href="../lvconcepts/asynchronous_vi_calls.html">calls the subVI asynchronously</a> while data flow continues in the calling VI.</p>
<p class="Body">
					The Call By Reference node requires a strictly typed VI refnum. The strictly typed VI reference identifies both the VI you are calling and its connector pane. It does not create a permanent association to the VI or contain other VI information, such as the name and location. You can wire the Call By Reference node inputs and outputs just like you wire any other VI.
				</p>
<p class="Body">The following block diagram shows how to use the Call By Reference node to dynamically call the Frequency Response VI. The Call By Reference node requires the use of the <a href="../glang/Open_VI_Reference.html">Open VI Reference</a> and <a href="../glang/Close_LV_Object_Reference.html">Close Reference</a> functions, similar to the functions you use for the <a href="../glang/Property_Node.html">Property Node</a> and the <a href="../glang/Invoke_Node.html">Invoke Node</a>.</p>
<p class="Anchor"><img src="loc_bd_stypref.gif"></p>
<p class="Body">
				The VI you specify for strictly typed refnums provides only the connector pane information. That is, no permanent association is made between the refnum and the VI. In particular, avoid confusing selecting the VI connector pane with getting a refnum to the selected VI. You specify a particular VI using the <strong>vi path</strong> input on the Open VI Reference function.
			</p>
</body>
</html>