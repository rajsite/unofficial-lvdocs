<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Networking_in_LabVIEW.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Buffering Data</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Buffering_Data"></a><h1>Buffering Data</h1>
<p class="Body">
					
					
					
					If you use network-published <a href="../lvconcepts/SV_Publishing_Latest_Values.html">shared variables</a> or a <a href="../lvhowto/Writing_Live_Data_Programm.html">psp</a> or <span class="Monospace">dstp</span>
					<a href="Using_DataSocket_Technology.html#Specifying_a_URL">URL</a> to share <a href="../lvconcepts/Using_DataSocket_Technology.html#Data_Formats_Supported_by_the_DataSocket_VI_and_Functions">data</a> programmatically, LabVIEW by default writes only the most recent value to all readers. When one client writes values to the server faster than another client reads them, newer values overwrite older, unprocessed values before the clients read them. If the reader does not receive a value before receiving the following value, the data is lost. This loss of unprocessed data can occur at the server or at the client. This loss of data might not be a problem if you are reading data and you want to receive only the most recent value written to the server. However, if you want to receive every value written to the server or if lossy transfers are unacceptable, you must buffer the data on the client. Place a checkmark in the <strong>Use Buffering</strong> checkbox on the <a href="../lvdialog/network_page.html">Network</a> page of the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box to enable buffering for the shared variable.</p><a name="Client-Side_Buffering"></a><h2>Client-Side Buffering</h2>
<p class="Body">Buffering allows you to lessen the potential timing difference between the reader and writer but does not guarantee data delivery. If the data in a buffer at the server or client exceeds the buffer size, the buffer discards older values in place of newer values. You can set the size of a buffer for a shared variable on the <strong>Network</strong> page of the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box to set how many data packets the shared variable retains before overwriting old data.</p>
<p class="Body">You also can specify programmatically the maximum number of bytes and the maximum number of values, in terms of packets, that the buffer for each item can hold. National Instruments recommends that you specify both the <a href="../lvprop/DS_Buff_Max_Bytes.html">Buffer Maximum Bytes</a> and <a href="../lvprop/DS_Buff_Max_Packets.html">Buffer Maximum Packets</a> properties when you buffer data. If incoming data exceeds the maximum number of bytes or the maximum number of values, LabVIEW removes older data from the buffer to accommodate the new data.</p>
<p class="Body">When configuring buffering programmatically, wire the written data to the <a href="../glang/Set_Variant_Attribute.html">Set Variant Attribute</a> function to detect discarded values in a data stream by uniquely identifying each value in the writer and checking for discarded sequence IDs in the reader.</p>
<p class="Body">If you publish a shared variable with less than 8 kilobytes of data, it can take up to 10 milliseconds for LabVIEW to send that data over the network. The <a href="../lvcomm/flushsharedvar.html">Flush Shared Variable Data</a> VI allows you to flush the buffer immediately and eliminate this delay.</p>
<p class="Body">If you want the buffer-enabled client to receive all data, use the <a href="../lvcomm/DataSocket_Write.html">DataSocket Write</a> function to <a href="../lvhowto/Writing_Live_Data_Programm.html">write live data</a> programmatically. Writing data from the front panel can result in data loss.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Client-side buffering also applies to other protocols, such as <span class="Monospace">opc</span> and <span class="Monospace">file</span>. However, in some cases these servers might <a href="Buffering_Data.html#Server-Side_Buffering">lose data</a>.</td>
</tr>
</table>
<p class="Body">Set the <strong>mode</strong> input of the <a href="../lvcomm/DataSocket_Open.html">DataSocket Open</a> function to <strong>BufferedRead</strong> or <strong>BufferedReadWrite</strong> and use a <a href="../glang/Property_Node.html">Property Node</a> to <a href="../lvhowto/Specify_Buff_Size_Client.html">set the DataSocket properties for the size</a> of a first-in-first-out (FIFO) buffer. Doing so ensures that LabVIEW stores the values the client receives in a buffer rather than overwriting them every time the value changes.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you use DataSocket properties to set the size of a FIFO buffer, you must set the mode input of the DataSocket Open function to <strong>BufferedRead</strong> or <strong>BufferedReadWrite</strong>. Otherwise, the item at the server is not buffered for the connection.</td>
</tr>
</table>
<p class="Body">The following block diagram uses buffering programmatically.</p>
<p class="Anchor"><img src="loc_bd_buffdsex.gif"></p>
<p class="Body">You also can enable buffering when sharing data using the DataSocket functions by adding the string <span class="Monospace">?maxbytes=1000&amp;maxpackets=10</span>, to the end of the URL, where <span class="Monospace">1000</span> is the maximum number of bytes the buffer contains and <span class="Monospace">10</span> is the maximum number of packets the buffer contains.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Buffering applies when you <a href="../lvhowto/Reading_Live_Data_Programm.html">use the DataSocket Read function</a> to read data a server writes. Buffering is not available when you use <a href="../lvhowto/Subscribing_to_Front_Panel.html">front panel DataSocket data binding</a> to read data. Buffering is available for <a href="../lvconcepts/SV_FP_Binding.html">front panel data binding</a> through the <a href="../lvconcepts/NI_PSP.html">Shared Variable Engine</a> if you bind controls to shared variables with buffering enabled on the <a href="../sysman/sm_network_page.html">Network</a> page of the <a href="../lvdialog/edit_variable_db.html">Shared Variable Properties</a> dialog box.</td>
</tr>
</table><a name="Reporting_Diagnostics"></a><h3>Reporting Diagnostics Using DataSocket Properties</h3>
<p class="Body">Use the <a href="../lvprop/DS_Buff_Util_Bytes.html">Buffer Utilization (Bytes)</a> property or the <a href="../lvprop/DS_Buff_Util_Packets.html">Buffer Utilization (Packets)</a> property to <a href="../lvhowto/Monitor_Buffer_Size.html">request diagnostic information</a> about the buffers you specify. Use these properties to check the percentage of buffer in use on the client to determine whether the current buffer size is sufficient. If the value of either of these properties approaches the maximum value of the buffer, <a href="../lvhowto/Specify_Buff_Size_Client.html">increase the buffer size</a> to make sure you receive all values the server writes. You also can <a href="../lvhowto/controlling_timing.html">increase the rate</a> at which the <a href="../glang/While_Loop.html">While Loop</a> containing the DataSocket functions executes to increase the read rate.</p><a name="Server-Side_Buffering"></a><h2>Server-Side Buffering</h2>
<p class="Body">When you configure client-side buffering, servers might lose data in some cases if the server sends data faster than the network can accept. You can use server-side buffering for <a href="NI_PSP.html">NI Publish-Subscribe Protocol (NI-PSP)</a> or <span class="Monospace">dstp</span> buffering. To use NI-PSP buffering, you must connect to an existing shared variable with buffering enabled. To use <span class="Monospace">dstp</span> buffering, you also must use the DataSocket Server Manager to configure server-side buffering. Refer to the DataSocket Server Help for more information about server-side buffering for the DataSocket Server. For other protocols, refer to the server documentation for more information about server-side buffering for that server.</p>
</body>
</html>