<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Data_Storage.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Flattened Data</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Flattened_Data"></a><h1>Flattened Data</h1>
<p class="Body">
				
				
				
				
				
				
		 	 LabVIEW converts data from the format in memory to a form more suitable for writing to or reading from a file. This more suitable format is called flattened data.</p>
<p class="Body">Because LabVIEW stores strings, arrays, and paths in handles (pointers to pointers in separate regions of memory), clusters that contain these strings and arrays are noncontiguous. In general, LabVIEW stores data in tree form. For example, LabVIEW stores a cluster as a double-precision, floating-point number and a string as an 8-byte floating-point number followed by a 4-byte handle to the string. LabVIEW does not store the string data adjacent to the extended-precision, floating-point number in memory. Therefore, to write the cluster data to disk, LabVIEW must get the data from two different places. With a cluster that contains many strings, arrays, and/or paths, LabVIEW stores the data in many different places.</p>
<p class="Body">When you save data to a file, LabVIEW flattens the data into a single string before saving it. Flattening data makes the data from an arbitrarily complex cluster contiguous rather than stored in several places. When LabVIEW loads data from a file, LabVIEW must perform the reverse operation, reading a single string and unflattening it into its internal, possibly noncontiguous, form.</p>
<p class="Body">LabVIEW normalizes the flattened data to a standard form so VIs that run on any platform can use the data. LabVIEW stores flattened numeric data in big-endian form (most significant byte first), and stores flattened extended-precision, floating-point numbers as 16-byte quantities.</p>
<p class="Body">When writing data to a file for use by an application that was not created using LabVIEW or when reading data from a file produced by an application that was not created using LabVIEW, you can transform the data into little-endian (least significant byte first) or big-endian form after flattening or before unflattening. Windows-based applications typically expect numeric data to be in little-endian form.</p>
<p class="Body">Use the <a href="../glang/Flatten_To_String.html">Flatten To String</a> and <a href="../glang/Unflatten_From_String.html">Unflatten From String</a> functions to flatten and unflatten data just as LabVIEW does internally when LabVIEW saves and loads data.</p>
<p class="Body">The flattened form of a piece of data does not encode the type of the data. LabVIEW stores this information in a <a href="Type_Descriptors.html">type descriptor</a>. The Unflatten From String function requires you to wire a data type as an input so the function can decode the string properly.</p>
<p class="Body">Use the <a href="Handling_Variant_Data.html">variant data type</a> to work with data independently of data type instead of flattening the data when you write to memory and unflattening the data when you read from memory. Use the <a href="../glang/Variant_Functions.html">Variant functions</a> to create and manipulate variant data.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you use the Flatten To String function on variant data, LabVIEW will flatten the variant and all its contents, including attributes. However, if you use the Variant To Flattened String function, LabVIEW flattens only the variant and discards any attributes.</td>
</tr>
</table><a name="Booleans_and_Numerics"></a><h2>Booleans and Numeric Objects</h2>
<p class="Body">The flattened form of any numeric type and Boolean type stores the data only in big-endian format. For example, a 32-bit integer with a value of <span class="Monospace">�19</span> is flattened to <span class="Monospace">FFFF FFED</span>. A double-precision floating-point number with a value equal to <span class="Monospace">1/4</span> is flattened to <span class="Monospace">3FD0 0000 0000 0000</span>. A Boolean value of TRUE is any nonzero value. A Boolean value of FALSE is <span class="Monospace">00</span>.</p>
<p class="Body">The flattened form for extended-precision numbers is the 128-bit extended-precision, floating-point format. When you save extended-precision numbers to disk, LabVIEW stores them in this format.</p><a name="Strings_and_Paths"></a><h2>Strings and Paths</h2>
<p class="Body">Because strings and paths have variable sizes, a flattened 32-bit integer that records the length in bytes precedes the flattened form. For example, a string type with value ABC is flattened to <span class="Monospace">0000 0003 4142 43</span>. For strings, the flattened format is similar to the format the string takes in memory.</p>
<p class="Body">However, paths do not have a length value preceding them when LabVIEW stores them in memory, so this value comes from the actual size of the data in memory and prefixes the value when LabVIEW flattens the data. This length is preceded by four characters: <span class="Monospace">PTH0</span>.</p>
<p class="Body">For example, a path with value <span class="Monospace">C:\File</span> is flattened to <span class="Monospace">5054 4830 0000 000B 0000 0002 0143 0466 696C 65</span>.</p>
<p class="Body">
				<span class="Monospace">5054 4830</span> indicates <span class="Monospace">PTH0</span>. <span class="Monospace">0000 000B</span> indicates 11 bytes total. <span class="Monospace">0000</span> is the type. <span class="Monospace">0002</span> is the number of components. <span class="Monospace">0143</span> indicates the letter C as a Pascal string. <span class="Monospace">0466 696C 65</span> indicates the word <span class="Monospace">File</span> as a Pascal string.</p><a name="Arrays"></a><h2>Arrays</h2>
<p class="Body">Flattened 32-bit integers that record the size, in elements, of each of the dimensions of an array precede the data for a flattened array. The slowest varying dimension is first, followed successively by the faster varying dimensions, just as the dimension sizes are stored in memory. The flattened data follows immediately after these dimension sizes in the same order in which LabVIEW stores them in memory. The following example shows a 2D array of six 8-bit integers.</p>
<p class="Body">
				<span class="Monospace">{ {1, 2, 3}, {4, 5, 6} }</span> is flattened to <span class="Monospace">0000 0002 0000 0003 0102 0304 0506</span>.</p>
<p class="Body">The following example shows a flattened 1D array of Boolean variables.</p>
<p class="Body">
				<span class="Monospace">{T, F, T, T}</span> is flattened to <span class="Monospace">0000 0004 0100 0101</span>. The preferred value for TRUE is <span class="Monospace">01</span>.</p><a name="Clusters"></a><h2>Clusters</h2>
<p class="Body">A flattened cluster is the concatenation, in cluster order, of the flattened data of its elements. For example, a flattened cluster of a 16-bit integer of value 4 (decimal) and a 32-bit integer of value <span class="Monospace">12</span> is <span class="Monospace">0004 0000 000C</span>.</p>
<p class="Body">A flattened cluster of a string <span class="Monospace">ABC</span> and a 16-bit integer of value <span class="Monospace">4</span> is <span class="Monospace">0000 0003 4142 4300 04</span>.</p>
<p class="Body">A flattened cluster of a 16-bit integer of value <span class="Monospace">7</span>, a cluster of a 16-bit integer of value <span class="Monospace">8</span>, and a 16-bit integer of value <span class="Monospace">9</span> is <span class="Monospace">0007 0008 0009</span>.</p><a name="Waveforms"></a><h2>Waveforms</h2>
<p class="Body">LabVIEW flattens waveforms like clusters.</p><a name="Refnums"></a><h2>Refnums</h2>
<p class="Body">LabVIEW stores the majority of flattened refnums as <a href="#Booleans_and_Numerics">flattened 32-bit integers</a>, which represent an internal LabVIEW data structure.</p>
<p class="Body">You can classify the remaining refnums by their refnum <a href="Type_Descriptors.html">type code</a>.</p>
<p class="Body">Type codes 0xE, 0xF and 0x15 are refnums that store their data as a <a href="#Strings_and_Paths">flattened string</a>. This string contains the value of the refnum tag, and can be empty (4 bytes of zero).</p>
<p class="Body">Type codes 0x1A, 0X1C, and 0x1D concatenate, in the following order:</p>
<ol>
<li>A flattened string for the name in the refnum tag. This string is empty (4 bytes of zero) if the refnum does not have a tag.</li>
<li>A flattened string that contains information specific to the refnum. This string can be empty (4 bytes of zero).</li>
<li>A flattened string that contains information specific to the refnum. This string can be empty (4 bytes of zero).</li>
<li>A flattened 32-bit signed integer that contains information specific to the refnum.</li>
<li>A flattened string that contains information specific to the refnum. This string can be empty (4 bytes of zero).</li>
</ol><a name="Classes"></a><h2>Classes</h2>
<p class="Body">LabVIEW flattens a LabVIEW class according to the following general format:</p>
<table class="Bordered">
<tr>
<td class="Bordered"><em>level in hierarchy</em></td>
<td class="Bordered"><em>class name</em></td>
<td class="Bordered"><em>version list</em></td>
<td class="Bordered"><em>private data</em></td>
</tr>
</table>
<ul>
<li><em>level in hierarchy</em>�4-byte unsigned integer representing the number of levels into the class hierarchy the class occurs. For example, if this value is 2, the class has one ancestor class between itself and LabVIEW Object. 
					<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If <em>level in hierarchy</em> is 0, the object is an instance of LabVIEW Object, and LabVIEW excludes the other three fields from the string.</td>
</tr>
</table>
				</li>
<li><em>class name</em>�A sequence of Pascal strings preceded by a single byte that indicates the length of the qualified name of the class. Each Pascal string, or sequence of bytes where the first byte indicates the length of the string and the remaining bytes are the text of the string, represents one segment of the qualified name. The last Pascal string is a length byte of zero. This section of the flattened string includes enough zero pad bytes to increase the class name section to a multiple of 4 bytes.</li>
<li><em>version list</em>�A series of clusters in which each cluster is four 2-byte unsigned integers that represent a version number. The first cluster in this list represents the version of <em>class name</em>, the second is the version of its parent, and so on. This list contains one version number for each <em>level in hierarchy</em>.
					<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If <em>level in hierarchy</em> is 1 and the version is 0, the flattened data represents the default data of the class, and LabVIEW excludes the remaining field from the string.</td>
</tr>
</table>
				</li>
<li><em>private data</em>�A series of flattened clusters representing the private data of each level of the hierarchy. In reverse order of the <em>version list</em>, the first cluster in this series corresponds to the oldest ancestor class. Each flattened cluster begins with a 4-byte signed integer that represents the number of bytes in the data that follows. If this initial number is 0, the flattened cluster represents the default data for the corresponding class in the hierarchy. Otherwise, the following data uses the standard flattened cluster representation explained earlier in this topic. Each flattened cluster ends with enough pad bytes to increase the cluster to a multiple of 4 bytes.</li>
</ul>
</body>
</html>