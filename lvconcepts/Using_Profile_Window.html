<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Performance_and_Memory_Management.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Using the Profile Performance and Memory Window</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Using_the_VI_Profile_Window_to_Monitor_VI_Performance"></a><h1>Using the Profile Performance and Memory Window</h1>
<p class="Body">
					The <a href="../lvdialog/Profile.html">Profile Performance and Memory</a> window is a powerful tool for determining where your application is spending its time and how it is using memory. The <strong>Profile Performance and Memory</strong> window has an interactive tabular display of time and memory usage for each VI in your system. Each row of the table contains information for a specific VI. The time spent by each VI is divided into several categories and summarized. The <strong>Profile Performance and Memory</strong> window calculates the minimum, maximum, and average time spent per run of a VI.
				</p>
<p class="Body">
					You can use the interactive tabular display to view all or part of this information, sort it by different categories, and look at the performance data of subVIs when called from a specific VI.
				</p>
<p class="Body">
				Select <strong>Tools�Profile�Performance and Memory</strong> to display the <a href="../lvdialog/Profile.html">Profile Performance and Memory</a> window. The following illustration shows an example of the window already in use.</p>
<p class="Anchor"><img src="loc_env_profile_window.gif"></p>
<p class="Body">
				The collection of memory usage information is optional because the collection process can add a significant amount of overhead to the running time of your VIs. You must choose whether to collect this data before starting the <a href="../lvdialog/Profile.html">Profile Performance and Memory</a> window by checking the <strong>Profile memory usage</strong> checkbox appropriately. This checkbox cannot be changed once a profiling session is in progress.
			</p><a name="Viewing_the_Results"></a><h2>Viewing the Results</h2>
<p class="Body">You can choose to display only parts of the information in the table. Some basic data is always visible, but you can choose to display the statistics, details, and (if enabled) memory usage by placing or removing checkmarks in the appropriate checkboxes in the <a href="../lvdialog/Profile.html">Profile Performance and Memory</a> window.</p>
<p class="Body">Performance information also is displayed for global VIs. However, this information sometimes requires a slightly different interpretation, as described in the following category-specific sections.</p>
<p class="Body">You can view performance data for subVIs by double-clicking the name of the subVI in the tabular display. When you do this, new rows appear directly below the name of the VI and contain performance data for each of its subVIs. When you double-click the name of a global VI, new rows appear for each of the individual controls on its front panel.</p>
<p class="Body">You can sort the rows of data in the tabular display by clicking in the desired column header. The current sort column is indicated by a bold header title.</p>
<p class="Body">
				Timings of VIs do not necessarily correspond to the amount of elapsed time that it takes for a VI to complete. This is because a multithreaded execution system can interleave the execution of two or more VIs. Also, there is a certain amount of overhead not attributed to any VI, such as the amount of time taken by a user to respond to a dialog box, or time spent in a <a href="../glang/Wait_ms.html">Wait (ms)</a> function on a block diagram, or time spent to check for mouse clicks.
			</p><a name="Timing_Information"></a><h2>Timing Information</h2>
<p class="Body">When the <strong>Timing statistics</strong> checkbox contains a checkmark, you can view additional details about the timing of the VI.</p>
<p class="Body">When the <strong>Timing details</strong> checkbox contains a checkmark, you can view a breakdown of several timing categories that sum up the time spent by the VI. For VIs that have a great deal of user interface, these categories can help you determine what operations take the most time.</p><a name="Memory_Information"></a><h2>Memory Information</h2>
<p class="Body">
					If you place a checkmark in the <strong>Memory usage</strong> checkbox, which is only available if you place a checkmark in the <strong>Profile memory usage</strong> checkbox before you began the profiling session, you can view information about how your VIs are using memory. These values are a measure of the memory used by the data space for the VI and do not include the support data structures necessary for all VIs. The data space for the VI contains not just the data explicitly being used by front panel controls, but also temporary buffers the compiler implicitly created.</p>
<p class="Body">The memory sizes are measured at the conclusion of the run of a VI and might not reflect its exact, total usage. For example, if a VI creates large arrays during its run but reduces their size before the VI finishes, the sizes displayed do not reflect the intermediate larger sizes.</p>
<p class="Body">This section displays two sets of data�data related to the number of bytes used, and data related to the number of blocks used. A block is a contiguous segment of memory used to store a single piece of data. For example, an array of integers might be multiple bytes in length, but it occupies only one block. The execution system uses independent blocks of memory for arrays, strings, paths, and pictures. Large numbers of blocks in the memory heap of your application can cause an overall degradation of performance (not just execution).</p>
</body>
</html>