<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Performance_and_Memory_Management.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>VI Execution Speed</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="VI_Execution_Speed"></a><h1>VI Execution Speed</h1>
<p class="Body">
					
					
					
 Although LabVIEW compiles VIs and produces code that generally executes very quickly, you want to obtain the best performance possible when working on time-critical VIs. This section discusses factors that affect execution speed and suggests some programming techniques to help you obtain the best performance possible.</p>
<p class="Body">Examine the following items to determine the causes of slow performance:</p>
<ul>
<li>Input/Output (files, GPIB, data acquisition, networking)</li>
<li>Screen Display (large controls, overlapping controls, too many displays)</li>
<li>Memory Management (inefficient usage of arrays and strings, inefficient data structures)</li>
<li>Compiler Optimizations (choices the compiler makes to balance editor responsiveness with VI execution speed)</li>
</ul>
<p class="Body">Other factors, such as execution overhead and subVI call overhead, usually have minimal effects on execution speed.</p><a name="Input_Output"></a><h2>Input/Output</h2>
<p class="Body">
					
  Input/Output (I/O) calls generally incur a large amount of overhead. They often take much more time than a computational operation. For example, a simple serial port read operation might have an associated overhead of several milliseconds. This overhead occurs in any application that uses serial ports because an I/O call involves transferring information through several layers of an operating system.</p>
<p class="Body">The best way to address too much overhead is to minimize the number of I/O calls you make. Performance improves if you can structure the VI so that you transfer a large amount of data with each call, instead of making multiple I/O calls that transfer smaller amounts of data.</p>
<p class="Body">For example, if you are creating a data acquisition (NI-DAQmx) VI, you have two options for reading data. You can use a single-point data transfer function such as the AI Sample Channel VI, or you can use a multipoint data transfer function such as the AI Acquire Waveform VI. If you must acquire 100 points, use the AI Sample Channel VI in a loop with a Wait function to establish the timing. You also can use the AI Acquire Waveform VI with an input indicating you want 100 points.</p>
<p class="Body">You can produce much higher and more accurate data sampling rates by using the AI Acquire Waveform VI, because it uses hardware timers to manage the data sampling. In addition, overhead for the AI Acquire Waveform VI is roughly the same as the overhead for a single call to the AI Sample Channel VI, even though it is transferring much more data.</p><a name="Screen_Display"></a><h2>Screen Display</h2>
<p class="Body">
					
					
					
					Frequently updating controls on a front panel can be one of the most time-consuming operations in an application. This is especially true if you use some of the more complicated displays, such as graphs and charts. Although most indicators do not redraw when they receive new data that is the same as the old data, graphs and charts always redraw. If redraw rate becomes a problem, the best solutions are to reduce the number of front panel objects and keep the front panel displays as simple as possible. In the case of graphs and charts, you can turn off autoscaling, scale markers, anti-aliased line drawing, and grids to speed up displays.
				</p>
<p class="Body">As with other kinds of I/O, there is a certain amount of fixed overhead in the display of a control. You can pass multiple points to an indicator at one time using certain controls, such as charts. You can minimize the number of chart updates you make by passing more data to the chart each time. You can see much higher data display rates if you collect your chart data into arrays to display multiple points at a time, instead of displaying each point as it comes in.
				</p>
<p class="Body">
					When you design subVIs whose front panels are closed during execution, do not be concerned about display overhead. If the front panel is closed, you do not have the drawing overhead for controls, so graphs are no more expensive than arrays.
				</p>
<p class="Body">In multithreaded systems, you can use the <strong>Advanced�Synchronous
 Display</strong> shortcut menu item to set whether to defer updates for controls and indicators. By default, controls and indicators use asynchronous displays, which means that after the execution system passes data to front panel controls and indicators, it can immediately continue execution. At some point thereafter, the user interface system notices that the control or indicator needs to be updated, and it redraws to show the new data. If the execution system attempts to update the control multiple times in rapid succession, you might not see some of the intervening updates.</p>
<p class="Body">In most applications, asynchronous displays significantly speed up execution without affecting what the user sees. For example, you can update a Boolean value hundreds of times in a second, which is more updates than the human eye can discern. Asynchronous displays permit the execution system to spend more time executing VIs, with updates automatically reduced to a slower rate by the user interface thread.</p>
<p class="Body">If you want synchronous displays, right-click the control or indicator and select <strong>Advanced�Synchronous
 Display</strong> from the shortcut menu to place a checkmark next to the menu item.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Turn on synchronous display only when it is necessary to display every data value. Using synchronous display results in a large performance penalty on multithreaded systems.</td>
</tr>
</table>
<p class="Body">You also can use the <a href="../lvprop/Pnl_Defer_Pnl_Updts.html">Defer Panel Updates</a> property to defer all new requests for front panel updates.</p>
<p class="Body">Monitor settings and the controls that you place on a front panel also can improve the performance of a VI. Lower the color depth and resolution of your monitor and enable hardware acceleration for your monitor. Refer to the documentation for your operating system for more information about hardware acceleration. Using controls from the <strong>Classic</strong> palette instead of controls from the <strong>Modern</strong> palette also improves the performance of a VI.</p><a name="Memory_Management_Speed"></a><h2>Memory Management</h2>
<p class="Body">
					
					Consider the following suggestions to manage the <a href="VI_Memory_Usage.html">memory in a VI</a> for optimal execution speed.</p>
<ul>
<li><a href="VI_Memory_Usage.html#Avoid_Constantly_Resizing_Data">Avoid constantly resizing data</a> so that LabVIEW does not have to make copies of the data.</li>
<li><a href="VI_Memory_Usage.html#Developing_Efficient_Data_Structures">Develop efficient data structures</a> with data types that are easy to manipulate to avoid making extra copies of data.</li>
<li>Save VIs without separate compiled code in the current version of LabVIEW.</li>
</ul><a name="Compiler_Optimizations"></a><h2>Compiler Optimizations</h2>
<p class="Body">
				To improve editor responsiveness for large VIs, the LabVIEW compiler limits optimizations that could improve the execution speed of these VIs. When you finish developing a large VI, you can configure LabVIEW to <a href="../lvhowto/compiler_limiting_optimizations.html">prioritize execution speed over editor responsiveness</a>. You can also configure LabVIEW to <a href="../lvhowto/compiler_optimizing_for_execution_speed.html">apply the full set of compiler optimizations to an entire build specification</a>.
			</p><a name="Passing_Data_within_an_Application"></a><h2>Passing Data within an Application</h2>
<p class="Body">
						You can choose from many techniques to pass data within a LabVIEW application. The following list orders the efficiency of the most common ways.</p>
<ol>
<li><strong>Wires</strong>�Use <a href="../lvconcepts/Using_Wires.html">wires</a> to pass data and allow LabVIEW to control performance optimization. No other techniques are faster in a dataflow language because data has a single writer and one or more readers. </li>
<li><strong>Feedback Node</strong>�Use a <a href="../glang/Feedback_Node.html">Feedback Node</a> to store data from a previous VI or loop execution. A Feedback Node automatically appears when you wire the output of a subVI, function, or group of subVIs and functions to the input of that same VI, function, or group and enable <strong>Auto-insert Feedback Node in cycles</strong> on the <a href="../lvdialog/Block_Diagram_Options.html">Block Diagram</a> page in the <a href="../lvdialog/Options_Dialog_Box.html">Options</a> dialog box. LabVIEW enables <strong>Auto-insert Feedback Node in cycles</strong> by default. A Feedback Node holds the data from the last execution of the VI, function, or group and can pass it to the next execution or set a new initial value, depending on whether you <a href="../lvhowto/Initialize_the_Feedback_N.html">move the initializer terminal</a>. In loops, shift registers store data in the same way as the Feedback Node but require wires spanning the loop.</li>
<li><strong>Shift registers</strong>�Use <a href="../lvhowto/Creating_Shift_Registers.html">shift registers</a> if you need storage or feedback within a loop. Shift registers pass data through one outside writer and reader, and one inside writer and reader. This tight scoping on data access maximizes the efficiency of LabVIEW. You can replace shift registers with a Feedback Node to achieve the same functionality without wires spanning the loop.</li>
<li><strong>Global Variables and Functional Global Variables</strong>�Use <a href="../lvhowto/Creating_Global_Variables.html">global variables</a> for simple data and simple access. For large or complex data, a global variable reads and passes all of the data. Use <a href="Suggestions_for_Exec.html">functional global variables</a> to control how much data LabVIEW returns. </li>
</ol><a name="Using_Controls_Control_References_and_Property_Nodes_as_Variables"></a><h3>Using Controls, Control References, and Property Nodes as Variables</h3>
<p class="Body">Though you can use controls, control references, and Property Nodes to pass data between VIs, they were not designed for use as variables because they work through the user interface. Use local variables and the Value property only when performing user interface actions or when stopping parallel loops.</p>
<p class="Body">User interface actions are historically slow on computers. LabVIEW passes a double value through a wire in nanoseconds, and draws a piece of text in hundreds of microseconds to milliseconds. For example, LabVIEW can pass a 100K array through a wire in 0 nanoseconds to a few microseconds. Drawing a graph of this 100K array takes tens of milliseconds. Because controls have a user interface attached, using controls to pass data has the side effect of redrawing controls, which adds memory expense and slows performance. If the controls are hidden, LabVIEW passes the data faster, but because the control can be displayed at anytime, LabVIEW still needs to update the control. </p><a name="How_Multithreading_Affects_User_Interface_Actions"></a><h3>How Multithreading Affects User Interface Actions</h3>
<p class="Body">
				Completing user interface actions uses more memory because <a href="Multitask_Multithread_Multip.html">LabVIEW switches from the execution thread to the user interface thread</a>. For example, when you set the Value property, LabVIEW simulates a user changing the value of the control, stopping the execution thread and switching to the user interface thread to change the value. Then LabVIEW updates the operation buffer that stores data at the control and redraws the control if the front panel is open. LabVIEW then sends the data back to the execution thread in a protected area of memory called the transfer buffer. LabVIEW then switches back to the execution thread. The next time the execution thread reads from the control, LabVIEW finds the data in the transfer buffer and receives the new value for the execution buffer that stores data on the block diagram.</p>
<p class="Body">When you write to a local or global variable, LabVIEW does not switch to the user interface thread immediately. LabVIEW instead writes the value to the transfer buffer. The user interface updates at the next scheduled update time. It is possible to update a variable multiple times before a single thread switch or user interface update occurs. This is possible because variables operate solely in the execution thread.</p>
<p class="Body">Functional global variables can be more efficient than ordinary global variables because they do not use transfer buffers. Functional global variables exist only within the execution thread and do not use transfer buffers, unless you display their values on an open front panel.</p><a name="Parallel_Block_Diagrams"></a><h2>Parallel Block Diagrams</h2>
<p class="Body">
					
					
					When you have multiple block diagrams running in parallel, the execution system switches between them periodically. If some of these loops are less important than others, use the <a href="../glang/Wait_ms.html">Wait (ms)</a> function to ensure the less important loops use less time.</p>
<p class="Body">For example, consider the following block diagram.</p>
<p class="Anchor"><img src="loc_bd_parallelbd.gif"></p>
<p class="Body">There are two loops in parallel. One of the loops is acquiring data and needs to execute as frequently as possible. The other loop is monitoring user input. The loops receive equal time because of the way this program is structured. The loop monitoring the user's action has a chance to run several times a second.</p>
<p class="Body">In practice, it is usually acceptable if the loop monitoring the button executes only once every half second, or even less often. By calling the <a href="../glang/Wait_ms.html">Wait (ms)</a> function in the user interface loop, you allot significantly more time to the other loop.</p>
<p class="Anchor"><img src="loc_bd_loop.gif"></p><a name="Parallel_For_Loop_Iterations"></a><h2>Parallel For Loop Iterations</h2>
<p class="Body">
					When you use a For Loop, LabVIEW executes the loop iterations sequentially. If a <a href="../glang/For_Loop.html">For Loop</a> is computationally intensive, consider <a href="../lvhowto/Parallel_Iterations.html">running the loop iterations in parallel</a> to improve performance. Parallel loop iterations allow LabVIEW to take advantage of multiple processors to execute the For Loop faster. However, parallel loop iterations must be independent of all other iterations. Use the <a href="../lvdialog/Parallel_For_Loop_Detection_DB.html">Find Parallelizable Loops Results</a> dialog box to determine which For Loops are parallelizable. To enable parallel loop iterations, right-click a For Loop border and select <strong>Configure Iteration Parallelism</strong> from the shortcut menu to display the <a href="../lvdialog/For_Loop_Iteration_DB.html">For Loop Iteration Parallelism</a> dialog box.</p>
<p class="Body">After you enable parallel loop iterations, the parallel instances terminal <img style="display:inline" src="noloc_bd_parallel.gif"> appears below the count terminal <img style="display:inline" src="noloc_bd_count.gif">. You can use this terminal to specify the number of loop instances for LabVIEW to use as well as to identify which instance is executing a particular iteration.</p>
<p class="Body">Review the <a href="../lvhowto/Parallel_Iterations_Performance_Considerations.html">performance considerations</a> before enabling parallel For Loop iterations.</p>
<p class="Body">National Instruments recommends that you <a href="../lvhowto/Warnings.html">display warnings</a> in the <a href="../lvdialog/Error_List_Dialog_Box.html">Error list</a> window so LabVIEW can warn you when parallel loop iterations might cause problems in a VI.</p><a name="SubVI_Overhead"></a><h2>SubVI Overhead</h2>
<p class="Body">
				
				
				
					When you call a subVI, there is a certain amount of overhead associated with the call. This overhead is fairly small (on the order of tens of microseconds), especially in comparison to I/O overhead and display overhead, which can range from milliseconds to tens of milliseconds. However, this overhead can add up in some cases. For example, if you call a subVI 10,000 times in a loop, this overhead could significantly affect execution speed. In this case, you might want to consider embedding the loop in the subVI.</p>
<p class="Body">Another way to minimize subVI overhead is to turn subVIs into subroutines by selecting <a href="../lvdialog/Execution.html">Execution</a> from the <strong>Category</strong> pull-down menu in the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box and then selecting <strong>subroutine</strong> from the <strong>Priority</strong> pull-down menu. However, there are some trade-offs. Subroutines cannot display front panel data, call timing or dialog box functions, allow debugging or automatic error-handling, or multitask with other VIs. Subroutines are generally most appropriate for VIs that do not require user interaction and are short, frequently executed tasks.</p>
<p class="Body">A third way to minimize subVI overhead is to inline subVIs into their calling VIs. When you inline a subVI, LabVIEW inserts the compiled code of the subVI into the compiled code of the calling VI. If you then make changes to the subVI, LabVIEW recompiles all calling VIs of that subVI to include those changes. Essentially, inlining a subVI removes the need to call the subVI at run time. Instead, LabVIEW executes the subVI code inside the compiled code of the calling VI.</p>
<p class="Body">Inlining subVIs is most useful for small subVIs, subVIs within a loop, subVIs with unwired outputs, or subVIs you call only once. To inline a subVI, place a checkmark in the <strong>Inline subVI into calling VIs</strong> checkbox on the <a href="../lvdialog/Execution.html">Execution</a> page of the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box. You must also select <strong>Preallocated clone reentrant execution</strong> on the same page of the dialog box. LabVIEW automatically preallocates clones for each instance when it inlines the subVI.</p>
<p class="Body">A subVI that you want to inline cannot have any of the following characteristics:</p>
<ul>
<li>Contains <a href="../lvconcepts/Recursive_VIs.html">recursion</a></li>
<li>Uses <a href="../lvconcepts/Error_Checking_and_Error_Handling.html">automatic error handling</a></li>
<li>Contains certain block diagram nodes, such as <a href="../glang/Property_Node.html">Property Nodes</a> and <a href="../glang/Invoke_Node.html">Invoke Nodes</a>. These nodes generate edit-time error messages if you enable subVI inlining.</li>
<li>Allows <a href="../lvconcepts/Debug_Techniques.html">debugging</a>. You must <a href="../lvhowto/Disabling_Debugging_Tools.html">disable debugging</a> for subVIs that you want to inline.</li>
<li>Is one of the following types of VIs:
						 <ul>
<li><a href="../lvconcepts/Creating_Classes.html#Dynamic_Dispatch">Dynamic dispatch VI</a> of a LabVIEW class</li>
<li>Targeted for CGen or FPGA</li>
<li>Control VI - VIs that define a custom control or indicator</li>
<li>Polymorphic VI</li>
<li>Global variable VI</li>
<li>XControl VI</li>
<li>Method VI of an XControl Library</li>
<li>VI that can only be placed on a simulation diagram in the LabVIEW Control Design and Simulation Module</li>
</ul>
					</li>
</ul>
<p class="Body">Even if the subVI does not have any of the previous characteristics, LabVIEW does not inline the subVI into the following kinds of calls:</p>
<ul>
<li><a href="../lvconcepts/Dynamic_LoadCall_VIs.html">Dynamic</a> calls to the subVI</li>
<li>Calls to the subVI that <a href="../lvconcepts/Logging_Front_Panel_Data.html#Retrieving_Front_Panel_Data_Programmatically">enable database access</a></li>
</ul>
<p class="Body">Finally, when you inline a subVI, LabVIEW ignores any priority or preferred execution settings.</p>
<p class="Body">Refer to the VI Execution Properties VI in the <span class="Monospace">examples\Performance\VI Properties</span> for an example of the performance improvements that result from inlining a subVI.</p>
<p class="Body">
					<a href="javascript:openVI('examples%5C%5CPerformance%5C%5CVI%20Properties%5C%5CVI%20Execution%20Properties.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		
					<a href="javascript:findExamples(3096);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples</p><a name="Shared_Variable_Overhead"></a><h2>Shared Variable Overhead</h2>
<p class="Body">
				
				Network-published shared variables incur significant CPU and memory overhead. If your application uses a large number of network-published shared variables, consider using the Simple Messaging Reference Library (STM) instead. Refer to the <a href="javascript:WWW(WWW_STMLIB)">support document</a> at <span class="Monospace">ni.com</span> to learn more about STM.</p>
<p class="Body">If you need to send a continuous stream of data from one computing device to one other computing device, use the <a href="../lvcomm/NS_NetworkStreamsPalette.html">Network Streams</a> functions.</p><a name="Unnecessary_Computation_in_Loops"></a><h2>Unnecessary Computation in Loops</h2>
<p class="Body">
					Avoid putting a calculation in a loop if the calculation produces the same value for every iteration. Instead, move the calculation out of the loop and pass the result into the loop.</p>
<p class="Body">For example, examine the following block diagram.</p>
<p class="Anchor"><img src="noloc_bd_calcin.gif"></p>
<p class="Body">The result of the division is the same every time through the loop; therefore you can increase performance by moving the division out of the loop, as shown in the following block diagram.</p>
<p class="Anchor"><img src="noloc_bd_calcout.gif"></p>
<p class="Body">Refer to the following block diagram.</p>
<p class="Anchor"><img src="loc_bd_globalin.gif"></p>
<p class="Body">If you know the value of the global variable is not going to be changed by another concurrent block diagram or VI during this loop, this block diagram wastes time by reading from the global variable and writing to the global every time through the loop.</p>
<p class="Body">If you do not require the global variable to be read from or written to by another block diagram during this loop, you might use the following block diagram instead.</p>
<p class="Anchor"><img src="loc_bd_globalout.gif"></p>
<p class="Body">Notice that the shift registers must pass the new value from the subVI to the next iteration of the loop. The following block diagram shows a common mistake some beginning users make. Since there is no shift register, the results from the subVI never pass back to the subVI as its new input value.</p>
<p class="Anchor"><img src="loc_bd_noshift.gif"></p>
</body>
</html>