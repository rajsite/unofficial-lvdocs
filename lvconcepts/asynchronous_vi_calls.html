<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Programmatically_Controlling_VIs.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Asynchronously Calling VIs</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>Asynchronously Calling VIs</h1>
<p class="Body">
						
					When you make a standard call to a target VI with either a subVI node or the <a href="../glang/Call_By_Reference_Node.html">Call By Reference</a> node, data flow stops at that node until the target VI returns its results, at which point data flow continues from the output terminals of the node.</p>
<p class="Body">In contrast, an asynchronous call to a subVI starts execution of the subVI while allowing data flow to continue in the calling VI. You might want to call subVIs asynchronously when the calling VI does not require the results of the subVI immediately. In those cases, the asynchronous call can drastically improve the execution time of the calling VI by allowing the subVI to run in parallel with the calling VI. Refer to the following list for examples of programming scenarios that benefit from asynchronous VI calls:</p>
<ul>
<li>Delegating work to subVIs while continuing to run</li>
<li>Dividing work for a single task among multiple instances of the same target VI, especially when you cannot know until run time how many instances the task requires</li>
<li>Launching complex user interfaces whose components are controlled by separate VIs that must run in parallel and collect results simultaneously</li>
</ul><br><br>Refer to the Benchmarking Asynchronous Calls VI in the <span class="Monospace">labview\examples\Application Control\VI Server\Asynchronous Call By Reference</span> directory for a comparison of several synchronous and asynchronous approaches to the same task.<br><br><a href="javascript:openVI('examples%5C%5CApplication%20Control%5C%5CVI%20Server%5C%5CAsynchronous%20Call%20By%20Reference%5C%5CBenchmarking%20Asynchronous%20Calls.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		<a href="javascript:findExamples(3072);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples<a name="overview"></a><h2>Overview of Constructing an Asynchronous VI Call</h2>
<p class="Body">In LabVIEW, all asynchronous VI calls consist of a combination of the following steps.</p>
<ol>
<li><strong>Prepare a VI reference to be called asynchronously</strong>�You prepare a VI reference for asynchronous execution when you obtain the reference with the <a href="../glang/Open_VI_Reference.html">Open VI Reference</a> function and include one of the asynchronous option flags (<span class="Monospace">0x80</span> or <span class="Monospace">0x100</span>) as part of the <a href="../glang/Open_VI_Reference.html#options">options input</a>. This step allows LabVIEW to allocate resources for the asynchronous call.</li>
<li><strong>Start the asynchronous VI call</strong>�Wire the VI reference to the <a href="../glang/start_asynchronous_call.html">Start Asynchronous Call</a> node to start the execution of the target VI. While the target VI runs, data flow continues in the calling VI.</li>
<li><strong>(Optional) Collect the results of the asynchronous VI call</strong>�If your application requires the outputs of a target VI that it calls asynchronously, wire the VI reference to the <a href="../glang/wait_on_asynchronous_call.html">Wait On Asynchronous Call</a> node to collect the results. The Wait On Asynchronous Call node waits until the associated subVI finishes executing or until the Wait On Asynchronous Call node <a href="../glang/wait_on_asynchronous_call.html#timeout">times out</a>.</li>
<li><strong>Close the VI reference</strong>�Use the <a href="../glang/Close_LV_Object_Reference.html">Close Reference</a> function to inform LabVIEW that you are finished using the VI reference. LabVIEW then can free the associated resources.</li>
</ol><a name="types"></a><h2>Types of Asynchronous VI Calls</h2>
<p class="Body">To make an asynchronous VI call, you must determine which of the following usage models applies to your use case. Refer to the following topics for more information about implementing each model:</p>
<ul>
<li><a href="../lvhowto/acbr_call_and_forget.html">Call-and-forget</a>�A calling VI starts the execution of a subVI but does not require outputs from the subVI. </li>
<li><a href="../lvhowto/acbr_call_and_collect.html">Call-and-collect</a>�A calling VI starts the execution of a subVI and needs to collect the results at a later time.</li>
</ul><br><br>You can use either of these usage models to <a href="../lvhowto/acbr_call_clones.html">asynchronously start multiple calls to the same VI for parallel execution</a>.<a name="pool"></a><h2>How LabVIEW Manages Asynchronous VI Calls: The Asynchronous Call Pool</h2>
<p class="Body">While most use cases for asynchronously calling VIs do not require knowledge of how LabVIEW manages asynchronous VI calls, understanding the asynchronous call pool can help you control performance and design deterministic applications. When you prepare a VI reference to run asynchronously by including one of the asynchronous option flags as part of the <strong>options</strong> input of the Open VI Reference function, LabVIEW creates a pool of data spaces that track data for individual calls to that VI. Because LabVIEW associates a pool of data spaces rather than a single data space to a VI reference, you can start multiple asynchronous calls with the same VI reference. Every time you use the Start Asynchronous Call node to start an asynchronous call with the VI reference, LabVIEW reserves one of the data spaces in the pool. When the VI finishes running, LabVIEW stores its outputs in the data space and marks the VI call as complete. If a Wait On Asynchronous Call node is waiting on the outputs of the called VI, LabVIEW returns the results from the data space, thereby freeing the data space for another call to the same VI.</p>
<h3>Performance Impact of the Asynchronous Call Pool</h3>
<p class="Body">For each VI reference, LabVIEW creates one data space in the asynchronous call pool for each CPU core on the target computer. If you start more simultaneous calls to the target VI than there are available data spaces, LabVIEW increases the size of the call pool by allocating more data spaces. 
Because the process of allocating data spaces does not take a deterministic amount of time, the calling VI might experience an unpredictable delay at any Start Asynchronous Call node that triggers an allocation.  						</p><a name="deterministic"></a><h3>Avoiding Unpredictable Delays at the Start Asynchronous Call Node</h3>
<p class="Body">To avoid unpredictable delays in VIs that must run on a real-time operating system, preallocate the number of data spaces in the call pool for a given VI reference by calling the <a href="../lvprop/VI_PopulateAsyncCallPool.html">Populate Asynchronous Call Pool</a> method before starting any asynchronous calls. Preallocating the data spaces limits delays to the beginning of the program instead of allowing delays to occur at the Start Asynchronous Call node.</p>
<p class="Body">Refer to the Populating the Asynchronous Call Pool VI in the <span class="Monospace">labview\examples\Application Control\VI Server\Asynchronous Call By Reference</span> directory for more information about how the asynchronous call pool affects performance.<br>
						<br>
						<a href="javascript:openVI('examples%5C%5CApplication%20Control%5C%5CVI%20Server%5C%5CAsynchronous%20Call%20By%20Reference%5C%5CPopulating%20the%20Asynchronous%20Call%20Pool.vi');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		
						<a href="javascript:findExamples(3072);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples
						</p><a name="multiple"></a><h3>Impact of Asynchronous Call Pool on Collecting Outputs from Multiple Calls to the Same VI</h3>
<p class="Body">
								
						
						When you want to collect the results of an asynchronous VI call, you must pass the reference to the called VI to the Wait On Asynchronous Call node. Because the Wait On Asynchronous Call node receives a reference to a VI rather than a reference to a specific data space, the node cannot collect the outputs of a specific call to the referenced VI. Instead, the node returns the outputs of any finished call to that VI. Refer to the following block diagram for a further explanation of this behavior.</p>
<p class="Anchor"><img src="loc_bd_acbr_join_oddities.gif"></p>
<p class="Body">As the labels suggest, when multiple Wait On Asynchronous Call nodes rely on the same VI reference, you cannot predict which node will return the outputs of a particular call to that VI reference. In the previous diagram, the top Wait On Asynchronous Call node is capable of returning the outputs of <strong>Start Asynchronous Call 2</strong> even though it is wired to <strong>Start Asynchronous Call 1</strong>. If you want to make multiple calls to the same VI but need to keep the Start Asynchronous Call node paired with a specific Wait On Asynchronous Call node, use either of the following solutions:</p>
<ul>
<li>Create a unique VI reference to the target VI for every asynchronous call that you want to make to it. If a Wait On Asynchronous Call node shares a unique VI reference with a Start Asynchronous Call node, the two nodes are guaranteed to refer to the same instance of the VI. This solution is similar to <a href="../lvhowto/acbr_call_and_collect.html#multiple">collecting outputs from multiple calls to unique VI references</a>.</li>
<li>Modify the target VI to accept a unique number or string as an input and return the same identifier as an output. When you call the target VI asynchronously, compare the identifier that you pass to a particular Start Asynchronous Call node to the identifier that the Wait On Asynchronous Call node returns. If they match, you know which call the Wait On Asynchronous Call node returned.</li>
</ul>
</body>
</html>