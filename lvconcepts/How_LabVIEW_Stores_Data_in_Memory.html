<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Data_Storage.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>How LabVIEW Stores Data in Memory</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="How_LabVIEW_Stores_Data_in_Memory"></a><h1>How LabVIEW Stores Data in Memory</h1>
<p class="Body">			
			
			LabVIEW stores data in memory for controls, indicators, wires, and other objects depending on the data type of the object.</p><a name="Boolean_Data"></a><h2>Boolean Data</h2>
<p class="Body">LabVIEW stores Boolean data as 8-bit values. If the value is zero, the Boolean value is FALSE. Any nonzero value represents TRUE.</p><a name="Byte_Integer"></a><h2>Byte Integer</h2>
<p class="Body">Byte integer numbers have an 8-bit format, signed and unsigned.</p><a name="Word_Integer"></a><h2>Word Integer</h2>
<p class="Body">Word integer numbers have a 16-bit format, signed and unsigned.</p><a name="Long_Integer"></a><h2>Long Integer</h2>
<p class="Body">Long integer numbers have a 32-bit format, signed and unsigned.</p><a name="Quad_Integer"></a><h2>Quad Integer</h2>
<p class="Body">Quad integer numbers have a 64-bit format, signed and unsigned.</p><a name="Fixed_Point"></a><h2>Fixed-Point</h2>
<p class="Body">Fixed-point numbers have a 64-bit format, signed and unsigned. LabVIEW signs extend fixed-point numbers to 64 bits even when the extended bits are not significant.</p><a name="Single"></a><h2>Single</h2>
<p class="Body">Single-precision floating-point numbers have a 32-bit IEEE single-precision format.</p>
<p class="Anchor"><img src="loc_eps_fig1a.gif"></p><a name="Double"></a><h2>Double</h2>
<p class="Body">Double-precision floating-point numbers have a 64-bit IEEE double-precision format.</p>
<p class="Anchor"><img src="loc_eps_fig2a.gif"></p><a name="Extended"></a><h2>Extended</h2>
<p class="Body">Extended-precision floating-point numbers have an 80-bit IEEE extended-precision format.
			</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��In some cases, extended-precision floating-point numbers can have a 64-, 96-, and 128-bit IEEE extended-precision format depending on the computer processor. Most Intel and AMD processors use an 80-bit format.</td>
</tr>
</table>
<p class="Anchor"><img src="loc_eps_fig3.gif"></p><a name="Complex_Single"></a><h2>Complex Single</h2>
<p class="Body">Complex single-precision floating-point numbers consist of real and imaginary values in 32-bit IEEE single-precision format.</p>
<p class="Anchor"><img src="loc_eps_fig6.gif"></p><a name="Complex_Double"></a><h2>Complex Double</h2>
<p class="Body">Complex double-precision floating-point numbers consist of real and imaginary values in 64-bit IEEE double-precision format.</p>
<p class="Anchor"><img src="loc_eps_fig7.gif"></p><a name="Complex_Extended"></a><h2>Complex Extended</h2>
<p class="Body">Complex extended-precision floating-point numbers consist of real and imaginary values in IEEE extended-precision format.</p>
<p class="Anchor"><img src="loc_eps_fig8.gif"></p>
<p class="Body">For floating point and complex numbers, s is the sign bit (0 for positive, 1 for negative), exp is the biased exponent (base 2), and mantissa is a number in the [0,1] range.</p><a name="Time_Stamp"></a><h2>Time Stamp</h2>
<p class="Body">LabVIEW stores a time stamp as a cluster of two quad integers, a signed integer and an unsigned integer. The signed integer (64 bits) represents the time-zone-independent number of complete seconds that have elapsed since 12:00 a.m., Friday, January 1, 1904, Universal Time [01-01-1904 00:00:00]. The unsigned integer (64 bits) represents the fractions of seconds.</p>
<p class="Anchor"><img src="loc_eps_fig11.gif"></p>
<p class="Body">Refer to the following <a href="javascript:WWW(WWW_TIMESTAMP)">support document</a> at <span class="Monospace">ni.com</span> for more information about time stamps.</p><a name="Arrays"></a><h2>Arrays</h2>
<p class="Body">LabVIEW stores arrays as handles, or pointers to pointers, that contain the size of each dimension of the array in 32-bit integers followed by the data. If the handle is 0, the array is empty. Because of alignment constraints of certain platforms, a few bytes of padding might follow the dimension size so that the first element of the data is correctly aligned. If you write a shared library that uses a LabVIEW array, you might need to <a href="../lvexcodeconcepts/Array_and_String_Options.html">adjust the size of the handle</a>.
			</p>
<p class="Body">The following illustration shows a 1D array of single-precision floating-point numbers. The decimal numbers to the left represent the byte offsets of locations in memory where the array begins.</p>
<p class="Anchor"><img src="loc_eps_fig12.gif"></p>
<p class="Body">The following illustration shows a 4D array of 16-bit integers.</p>
<p class="Anchor"><img src="loc_eps_fig13.gif"></p>
<p class="Body">
				In LabVIEW, 1D and 2D arrays are aligned in memory. This aids in performance for linear algebra operations and operations involving the matrix data type.</p><a name="Strings"></a><h2>Strings</h2>
<p class="Body">LabVIEW stores strings as pointers to a structure that contains a 4-byte length value followed by a 1D array of byte integers (8-bit characters), as shown in the following illustration. If the handle, or the pointer to the structure, is NULL, LabVIEW treats the string as an empty string, which is the same as a string with length value of zero. Because LabVIEW uses the length value and not a terminating character to determine the end of the string, you can embed all characters that include the NULL character, or ASCII character 0, in the string at any point. When passing LabVIEW strings to external code that expects a C string, the embedded NULL characters cause the code to interpret the string as terminating at the first NULL character.</p>
<p class="Anchor"><img src="loc_eps_fig14.gif"></p><a name="Paths"></a><h2>Paths</h2>
<p class="Body">
			A LabVIEW path is a pointer to an opaque data structure that contains a path type and path components. The path type is 0 for an absolute path, 1 for a relative path, and 3 for a Universal Naming Convention (UNC) path. A UNC path occurs on Windows only and has <span class="Monospace">\\&lt;machine name&gt;\&lt;share name&gt;\</span> rather than a drive letter as its first component. Any other value of path type indicates an invalid path.</p>
<p class="Body">
				Use the following functions to access information about a path:
				</p>
<ul>
<li><span class="Monospace">FDepth()</span></li>
<li><span class="Monospace">FDirName()</span></li>
<li><span class="Monospace">FIsAPath()</span></li>
<li><span class="Monospace">FIsAPathOfType()</span></li>
<li><span class="Monospace">FIsEmptyPath()</span></li>
<li><span class="Monospace">FNamePtr()</span></li>
<li><span class="Monospace">FVolName()</span></li>
</ul>
<p class="Body">
				Use the following functions to add elements to a path:
				</p>
<ul>
<li><span class="Monospace">FAddPath()</span></li>
<li><span class="Monospace">FAppendName()</span></li>
</ul>
<p class="Body">		
				Use the following functions to create a new path:
				</p>
<ul>
<li><span class="Monospace">FNotAPath()</span></li>
<li><span class="Monospace">FPathCpy()</span></li>
<li><span class="Monospace">FEmptyPath()</span></li>
<li><span class="Monospace">FMakePath()</span></li>
<li><span class="Monospace">FRelPath()</span></li>
</ul>
<p class="Body">
				Use the <span class="Monospace">FDestroyPath()</span> function to dispose of a path.
				</p>
<p class="Body">
				Use the following functions to convert a path to or from a textual form:
				</p>
<ul>
<li><span class="Monospace">FFileSystemStringToPath()</span></li>
<li><span class="Monospace">FPathToFileSystemDSString()</span></li>
<li><span class="Monospace">FPathToText()</span></li>
<li><span class="Monospace">FTextToPath()</span></li>
<li><span class="Monospace">ConvertPathToPlatformIndependentText()</span></li>
<li><span class="Monospace">ConvertPlatformIndependentTextToPath()</span></li>
</ul>
<p class="Body">
				Use the following functions to compare two paths:
				</p>
<ul>
<li><span class="Monospace">FPathCmp()</span></li>
<li><span class="Monospace">FPathCmpLexical()</span></li>
</ul>
<h3>Related Information</h3>
<p class="Body"><a href="../lvexcodeconcepts/LabVIEW_Manager_Routines.html">Using LabVIEW Manager Functions in Shared Libraries</a></p><a name="Clusters"></a><h2>Clusters</h2>
<p class="Body">LabVIEW stores cluster elements of varying data types according to the cluster order. You can view and <a href="../lvhowto/Modifying_Cluster_Element.html">modify the cluster order</a> by right-clicking the cluster border and selecting <strong>Reorder Controls In Cluster</strong> from the shortcut menu. LabVIEW stores scalar data directly in the cluster, and it stores arrays, strings, and paths indirectly in the cluster. Because of alignment constraints of certain platforms, LabVIEW might add some bytes of padding to the end of a cluster in an array so that the beginning of the next cluster is aligned correctly. If you write a shared library that uses an array of clusters, you must account for this padding if you <a href="../lvexcodeconcepts/Array_and_String_Options.html">adjust the size of the handle</a> to the array.</p>
<p class="Body">	
			The memory layout of a cluster depends on the platform you are running. LabVIEW may add padding between cluster elements so that those elements are aligned to certain address boundaries. Address boundaries relate to the concept of natural alignment. A piece of data is aligned on its�natural�boundary if the address at which it begins is a multiple of the size of the data. For example, a 4-byte integer is aligned naturally if it begins at an address which is a multiple of four. Most compilers have an upper limit on this boundary at which the restriction is relaxed. For instance, an 8-byte integer may be aligned on a 4-byte boundary. For the platforms on which LabVIEW runs, the alignment constraints are as follows:
			</p>
<ul>
<li><span class="Platform">(Windows 32-bit and Phar Lap ETS)</span> Data is aligned only to 1-byte boundaries.</li>
<li><span class="Platform">(macOS 32-bit and Linux 32-bit)</span> Data is aligned to 4-byte boundaries except for doubles. A double is aligned to 8-byte boundaries.</li>
<li><span class="Platform">(macOS 64-bit and Linux 64-bit)</span> Data is aligned naturally up to 8-byte boundaries.</li>
<li><span class="Platform">(Windows 64-bit and VxWorks)</span> Data is aligned naturally up to 8-byte boundaries.</li>
</ul>
<p class="Body">
				On all platforms, clusters adopt the alignment of their most restrictively aligned element.
			</p>
<p class="Body">
				The following tables represent a cluster that contains a 16-bit integer, a double-precision floating-point number, an extended-precision floating-point number, an array, and an 8-bit unsigned integer. Each row contains the memory address and its corresponding element and element size.</p>
<ul>
<li><span class="Platform">(Windows 32-bit and Phar Lap ETS)</span> Because data is aligned only to 1-byte boundaries, the memory address of the next cluster is 17.<br><br>
			<table class="Bordered">
<tr>
<th class="Bordered">Memory Address</th>
<th class="Bordered">Element</th>
<th class="Bordered">Size (bytes)</th>
</tr>
<tr>
<td class="Bordered">0:</td>
<td class="Bordered">I16 integer</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">2:</td>
<td class="Bordered">EXT float</td>
<td class="Bordered">10</td>
</tr>
<tr>
<td class="Bordered">12:</td>
<td class="Bordered">Handle to Array</td>
<td class="Bordered">4</td>
</tr>
<tr>
<td class="Bordered">16:</td>
<td class="Bordered">U8 integer</td>
<td class="Bordered">1</td>
</tr>
</table>
			</li>
<li><span class="Platform">(macOS 32-bit and Linux 32-bit)</span> Because apart from doubles, data is aligned to 4-byte boundaries, LabVIEW adds 3 bytes of padding after the U8 integer so that the memory address of the next cluster is 20. Because a double is aligned to 8-byte boundaries, LabVIEW adds 4 bytes of padding after the U64 integer so that the memory address of the double is 32.<br><br>
					<table class="Bordered">
<tr>
<th class="Bordered">Memory Address</th>
<th class="Bordered">Element</th>
<th class="Bordered">Size (bytes)</th>
</tr>
<tr>
<td class="Bordered">0:</td>
<td class="Bordered">I16 integer</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">2:</td>
<td class="Bordered">EXT float</td>
<td class="Bordered">10</td>
</tr>
<tr>
<td class="Bordered">12:</td>
<td class="Bordered">Handle to Array</td>
<td class="Bordered">4</td>
</tr>
<tr>
<td class="Bordered">16:</td>
<td class="Bordered">U8 integer</td>
<td class="Bordered">1</td>
</tr>
<tr>
<td class="Bordered">17:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">3</td>
</tr>
<tr>
<td class="Bordered">20:</td>
<td class="Bordered">U64 integer</td>
<td class="Bordered">8</td>
</tr>
<tr>
<td class="Bordered">28:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">4</td>
</tr>
<tr>
<td class="Bordered">32:</td>
<td class="Bordered">Double</td>
<td class="Bordered">8</td>
</tr>
</table>
				</li>
<li><span class="Platform">(Windows 64-bit, macOS 64-bit, and Linux 64-bit)</span> Because data is aligned naturally up to 8-byte boundaries, LabVIEW adds 7 bytes of padding after the U8 integer so that the memory address of the next cluster is 32.<br><br>
					<table class="Bordered">
<tr>
<th class="Bordered">Memory Address</th>
<th class="Bordered">Element</th>
<th class="Bordered">Size (bytes)</th>
</tr>
<tr>
<td class="Bordered">0:</td>
<td class="Bordered">I16 integer</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">2:</td>
<td class="Bordered">EXT float</td>
<td class="Bordered">10</td>
</tr>
<tr>
<td class="Bordered">12:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">4</td>
</tr>
<tr>
<td class="Bordered">16:</td>
<td class="Bordered">Handle to Array</td>
<td class="Bordered">8</td>
</tr>
<tr>
<td class="Bordered">24:</td>
<td class="Bordered">U8 integer</td>
<td class="Bordered">1</td>
</tr>
<tr>
<td class="Bordered">25:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">7</td>
</tr>
</table>
				</li>
<li><span class="Platform">(VxWorks)</span> Because data is aligned naturally up to 8-byte boundaries, LabVIEW adds 7 bytes of padding after the U8 integer so that the memory address of the next cluster is 40. Note that VxWorks implements EXT float as long double.<br><br>
					<table class="Bordered">
<tr>
<th class="Bordered">Memory Address</th>
<th class="Bordered">Element</th>
<th class="Bordered">Size (bytes)</th>
</tr>
<tr>
<td class="Bordered">0:</td>
<td class="Bordered">I16 integer</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">2:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">6</td>
</tr>
<tr>
<td class="Bordered">8:</td>
<td class="Bordered">EXT float</td>
<td class="Bordered">16</td>
</tr>
<tr>
<td class="Bordered">24:</td>
<td class="Bordered">Handle to Array</td>
<td class="Bordered">8</td>
</tr>
<tr>
<td class="Bordered">32:</td>
<td class="Bordered">U8 integer</td>
<td class="Bordered">1</td>
</tr>
<tr>
<td class="Bordered">33:</td>
<td class="Bordered">Padding</td>
<td class="Bordered">7</td>
</tr>
</table>
				</li>
</ul>
<p class="Body">
				LabVIEW stores clusters embedded within other clusters directly in line and with no indirection. LabVIEW stores only arrays, strings, and paths indirectly.
			</p>
<p class="Body">The following illustration shows two different clusters that store data the same way.</p>
<p class="Body">
				<img style="display:inline" src="loc_fp_fig19.gif">
				<img style="display:inline" src="loc_eps_fig20.gif">
			</p><a name="Waveform"></a><h2>Waveform</h2>
<p class="Body">LabVIEW stores waveforms like clusters.</p><a name="Refnum"></a><h2>Refnum</h2>
<p class="Body">LabVIEW stores refnums as signed 32-bit integers.</p><a name="Variant"></a><h2>Variant</h2>
<p class="Body">LabVIEW stores variants as handles to a LabVIEW internal data structure. Variant data is made up of 4 bytes.</p>
<h3>Related Concepts</h3>
<p class="Body"><a href="../lvconcepts/Flattened_Data.html">Flattened Data</a></p>
<p class="Body"><a href="../lvconcepts/Type_Descriptors.html">Type Descriptors</a></p>
<p class="Body"><a href="../lvconcepts/Old_Type_Descriptors.html">Type Descriptors in LabVIEW 7.x and Earlier</a></p>
</body>
</html>