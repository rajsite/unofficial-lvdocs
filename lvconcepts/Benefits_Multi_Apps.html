<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Using_LV_to_Create_Multithrded_VIs_for_Max_Perf.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Benefits of Multithreaded Applications</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Benefits_of_Multithreaded_Applications"></a><h1>Benefits of Multithreaded Applications</h1>
<p class="Body">
				
				
Applications that take advantage of multithreading have numerous benefits, including the following:</p>
<ul>
<li>More efficient CPU use</li>
<li>Better system reliability</li>
<li>Improved performance on multiprocessor computers</li>
</ul><a name="More_Efficient_CPU_Use"></a><h2>More Efficient CPU Use</h2>
<p class="Body">In many LabVIEW applications, you make synchronous acquisition calls to an instrument or data acquisition device. Such calls often take some time to complete. In a single-threaded application, a synchronous call such as this effectively blocks, or prevents, any other task within the LabVIEW application from executing until the acquisition completes. In LabVIEW, multithreading prevents this blocking. While the synchronous acquisition call runs on one thread, other parts of the program that do not depend on the acquisition, such as data analysis and file I/O, run on different threads. Thus, execution of the application progresses during the acquisition instead of stalling until the acquisition completes.</p>
<p class="Body">In this way, a multithreaded application maximizes the efficiency of the processor because the processor does not sit idle if any thread of the application is ready to run. Any program that reads and writes from a file, performs I/O, or polls the user interface for activity can benefit from multithreading simply because you can use the CPU more efficiently during these synchronous activities.</p><a name="Better_System_Reliability"></a><h2>Better System Reliability</h2>
<p class="Body">By separating the program onto different execution threads, you can prevent other operations in your program from adversely affecting important operations. The most common example is the effect the user interface can have on more time-critical operations. Many times, screen updates or responses to user events can decrease the execution speed of the program. For example, when someone moves a window, resizes it, or opens another window, the program execution effectively stops while the processor responds to that user interface event.</p>
<p class="Body">In a LabVIEW multithreaded application, user interface operations are separated onto a dedicated user interface thread, and the data acquisition, analysis, and file I/O portions of the program can run on different threads. By giving the user interface thread a lower priority than other more time-critical operations, you can ensure that the user interface operations do not prevent the CPU from executing more important operations, such as collecting data from a computer-based instrument. Giving the user interface lower priority improves the overall system reliability, including data acquisition and processing, the performance of LabVIEW, and the performance of the computer as a whole, by ensuring that data is not lost because an operator moves a window, for example.</p>
<p class="Body">Another example where multithreading provides better system reliability is when you perform high-speed data acquisition and display the results. Screen updates are often slow relative to other operations, such as continuous high-speed data acquisition. If you attempt to acquire large amounts of data at high speed in a single-threaded application and display all that data in a graph, the data buffer may overflow because the processor is forced to spend too much time on the screen update. When the data buffer overflows, you lose data.</p>
<p class="Body">However, in a LabVIEW multithreaded application with the user interface separated on its own thread, the data acquisition task can reside on a different, higher priority thread. In this scenario, the data acquisition and display run independently so the acquisition can run continuously and send data into memory without interruption. The display runs as fast as it can, drawing whatever data it finds in memory at execution time. The acquisition thread preempts the display thread so you do not lose data when the screen updates.</p><a name="Improved_Performance_on_Multiprocessor_Computers"></a><h2>Improved Performance on Multiprocessor Computers</h2>
<p class="Body">One of the most promising benefits of multithreading is that it can harness the power of multiprocessor computers. Many high-end computers today offer two or more processors for additional computation power. Multithreaded applications are poised to take maximum advantage of those computers. In a multithreaded application where several threads are ready to run simultaneously, each processor can run a different thread. In a multiprocessor computer, the application can attain true parallel task execution, thus increasing overall system performance.</p>
<p class="Body">In contrast, single-threaded applications can run on only a single processor, thus preventing them from taking advantage of the multiple processors to improve performance. Therefore, to achieve maximum performance from multithreaded operating systems and/or multiprocessor machines, an application must be multithreaded.</p>
</body>
</html>