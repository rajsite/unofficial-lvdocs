<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Loops_and_Structures.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>In Place Element Structures: Increasing Memory Efficiency</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>In Place Element Structures: Increasing Memory Efficiency</h1>
<p class="Body">
				
				
				
				Use the In Place Element structure to control how the LabVIEW compiler performs common operations more efficiently than traditional LabVIEW programming methods and to increase memory and VI efficiency. Many LabVIEW operations require LabVIEW to copy and maintain data values in memory, thereby decreasing execution speed and increasing memory usage.</p>
<p class="Body">The In Place Element structure uses border nodes, or nodes that are attached to the border of the In Place Element structure, to perform operations on data. When you move or delete a border node, LabVIEW automatically moves or deletes the corresponding node on the opposite side of the structure.</p>
<p class="Body">The In Place Element structure can execute common LabVIEW operations more efficiently than traditional LabVIEW programming methods.</p>
<p class="Body">The following block diagram shows a situation in which you can use the In Place Element structure to improve the execution and memory efficiency of a VI.</p>
<p class="Anchor"><img src="loc_bd_index_array_before.gif"></p>
<p class="Body">In the previous block diagram, LabVIEW indexes an array of 32-bit unsigned integers, increments the third element of the array, and replaces the element in the same location of the array. To replace the new value in the same array, the Replace Array Subset function requires you to wire the array and array index values to the <strong>array</strong> and <strong>index</strong> inputs of the function. When you run the VI, LabVIEW makes a new copy of the array element and stores the copy in memory.</p>
<p class="Body">Use the In Place Element structure to avoid making extra copies of the array element, as shown in the following block diagram.</p>
<p class="Anchor"><img src="loc_bd_index_array_after.gif"></p>
<p class="Body">In the previous block diagram, the Array Index / Replace Elements border node of the In Place Element structure indexes an array of 32-bit unsigned integers, increments the third element of the array, and replaces the element in the same location in the array, similar to the first block diagram example. However, in this instance, LabVIEW does not have to create or store extra copies of the element in memory.</p>
<p class="Body">The In Place Element structure requires you to replace each indexed element of the array in the array with the node on the right side of the structure. Because the structure requires you to replace the array element and the LabVIEW compiler knows which element to replace, LabVIEW does not have to create or store extra copies of the array elements in memory.</p>
<h2>Related information</h2>
<p class="Body"><a href="../glang/In_Place_Element_Structure.html">In Place Element Structure</a></p>
<p class="Body"><a href="../glang/Replace_Array_Subset.html">Replace Array Subset Function</a></p>
<p class="Body"><a href="../glang/inplace_array.html">Array Index/Replace Elements Border Node</a></p>
<p class="Body"><a href="../lvconcepts/VI_Memory_Usage.html">VI Memory Usage</a></p>
</body>
</html>