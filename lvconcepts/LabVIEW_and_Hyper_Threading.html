<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Using_LV_to_Create_Multithrded_VIs_for_Max_Perf.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Multiprocessing and Hyperthreading in LabVIEW</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="LabVIEW_and_Hyper-Threading"></a><h1>Multiprocessing and Hyperthreading in LabVIEW</h1>
<p class="Body">
				
				
				
				A hyperthreaded computer has a single processor but acts as a computer with a multiprocessor. <span class="Platform">(Windows)</span> Hyperthreading is a feature of some versions of the Intel Pentium 4 and later. When you launch the Windows Task Manager on a hyperthreaded computer and click the <strong>Performance</strong> tab, the Windows Task Manager displays the usage history for two CPUs. <span class="Platform">(macOS)</span> Launch the Activity Monitor to check performance.</p>
<p class="Body">A hyperthreaded processor acts like multiple processors embedded on the same microchip. Some of the resources on the chip are duplicated, such as the register set. Other resources are shared, such as the execution units and the cache. Some resources, such as the buffers that store micro operations, are partitioned, with each logical processor receiving a portion.</p>
<p class="Body">Optimizing an application to take advantage of hyperthreading is similar to optimizing an application for a multiprocessor system, also known as a multi-core, multiple CPU, or SMP system, but there are some differences. For example, a hyperthreaded computer shares the execution units, and a dual-processor computer contains two complete sets of execution units. Therefore, any application that is limited by floating-point execution units performs better on the multiprocessor computer because you do not have to share the execution units. The same principle applies with cache contention. If two threads try to access the cache, the performance is better on a multiprocessor computer, where each processor has its own full-size cache.</p><a name="LabVIEW_Execution_Overview"></a><h2>LabVIEW Execution Overview</h2>
<p class="Body">
				
				The LabVIEW execution system is already built for multiprocessing. In text-based programming languages, to make an application multithreaded, you have to create multiple threads and write code to communicate among those threads. LabVIEW, however, can recognize opportunities for multithreading in VIs, and the execution system handles multithreading communications for you.</p>
<p class="Body">The following example takes advantage of the LabVIEW multithreaded execution system.</p>
<p class="Anchor"><img src="loc_bd_twoloops.gif"></p>
<p class="Body">In this VI, LabVIEW recognizes that it can execute the two loops independently, and in a multiprocessing or hyperthreaded environment, often simultaneously.</p><a name="Primes_Parallelism_Example"></a><h2>Primes Parallelism Example</h2>
<p class="Body">
				
				The following example calculates prime numbers greater than two.</p>
<p class="Anchor"><img src="loc_bd_primesloop.gif"></p>
<p class="Body">The block diagram evaluates all the odd numbers between three and <strong>Num Terms</strong> and determines if they are prime. The inner For Loop returns TRUE if any number divides the term with a zero remainder.</p>
<p class="Body">The iterations of the outer For Loop do not depend on each other. If the iterations of a For Loop can execute in any order, you can <a href="../lvconcepts/VI_Execution_Speed.html#Parallel_For_Loop_Iterations">enable loop iteration parallelism</a> on the For Loop to improve performance. In this example, the outer For Loop is a good candidate for iteration parallelism because it performs a significant amount of computation per iteration.</p>
<p class="Body">To enable parallelism on this VI, right-click the For Loop and select <strong>Configure Iteration Parallelism</strong> from the shortcut menu. This action displays the <a href="../lvdialog/For_Loop_Iteration_DB.html">For Loop Iteration Parallelism</a> dialog box.</p>
<p class="Body">On a multiprocessor computer, parallel loop iterations allow LabVIEW to take advantage of multiple processors to execute the For Loop faster. The parallel version of this example is more efficient because LabVIEW can simultaneously execute different codes.</p>
<p class="Anchor"><img src="loc_bd_primesenableloop.gif"></p>
<p class="Body">Notice that these two example VIs do not include code for explicit thread management. The LabVIEW dataflow programming paradigm allows the LabVIEW execution system to run the parallel loop instances in different threads.</p><a name="Programming_for_Hyper-Threaded_or_Multiprocessor_Systems"></a><h2>Programming for Hyperthreaded or Multiprocessor Systems</h2>
<p class="Body">
				
				
				Optimizing the performance of an application for a hyperthreaded computer is nearly identical to doing so for a multiprocessor computer. However, differences exist because a hyperthreaded computer shares some resources between the two logical processors, such as the cache and execution units. If you think a shared resource on a hyperthreaded computer limits an application, test the application with an advanced sampling performance analyzer, such as the Intel VTune.</p>
</body>
</html>