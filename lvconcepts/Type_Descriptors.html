<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Data_Storage.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Type Descriptors</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Type_Descriptors"></a><h1>Type Descriptors</h1>
<p class="Body">LabVIEW associates each wire and terminal on the block diagram with a data type. LabVIEW keeps track of this type with a structure in memory called a <em>type descriptor</em>. A type descriptor is a sequence of 32-bit integers that can describe any data type in LabVIEW. Numeric values are written in hexadecimal format, unless otherwise noted.</p>
<p class="Body">A type can be aggregate, meaning it can consist of different types. For example, in an array of Booleans, the array is a type, and its Boolean elements are another type. In LabVIEW, all type descriptors for such complex types are stored in a list.</p><a name="Observable_Formats"></a><h2>Observable Formats</h2>
<p class="Body">You can observe type descriptors in different formats using the <a href="../glang/Flatten_To_String.html">Flatten To String</a> function or the <a href="../glang/Variant_to_Flattened_Str.html">Variant To Flattened String</a> function.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The format in which LabVIEW stores type descriptors changed in LabVIEW 8.0. LabVIEW 7.<em>x</em> and earlier <a href="../lvconcepts/Old_Type_Descriptors.html">store type descriptors in 16-bit flat representation</a>. LabVIEW 8.0 and later store type descriptors in 32-bit flat representation. The information for LabVIEW 7.<em>x</em> and earlier applies if you use the <strong>Convert 7.x Data</strong> mode of the Flatten To String function. The following information applies to LabVIEW 8.0 or later. NI recommends that you use the <a href="../lvconcepts/Handling_Variant_Data.html">variant</a> data type to avoid any conflicts these format changes might cause.</td>
</tr>
</table>
<p class="Body">When you use the Flatten To String function to flatten variant data, LabVIEW flattens the variant and all its contents, including attributes. Using this function, the type descriptor save buffer has the following format:</p>
<table class="Borderless">
<tr>
<td><span class="Monospace">32 bits</span></td>
<td><span class="Monospace">nTDs</span><br><span class="Monospace">TDs</span></td>
</tr>
<tr>
<td><span class="Monospace">var size</span></td>
<td><span class="Monospace">nTypesUsed</span></td>
</tr>
<tr>
<td><span class="Monospace">var size</span></td>
<td><span class="Monospace">TypesUsed</span></td>
</tr>
</table>
<table class="Borderless">
<tr>
<td>where</td>
<td><span class="Monospace">nTDs</span></td>
<td>is the number of elemental type descriptors contained in the buffer</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">TDs</span></td>
<td>is the list of <span class="Monospace">nTDs</span> type descriptors</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">var size</span></td>
<td>is the variable size and stored in a variable number, either 16-bits or 32-bits, depending on the value being represented. If the value is less than 32768, it is stored in two bytes. If the value is greater than or equal to 32768, it is stored in four bytes with the high bit set to one.</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">nTypesUsed</span></td>
<td>is the actual number of type descriptors types being used by the entity referencing the buffer</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">TypesUsed</span></td>
<td>is the list of indexes for all the types of <span class="Monospace">TDs</span> being used</td>
</tr>
</table>
<p class="Body">When you use the Variant To Flattened String function, LabVIEW flattens only the variant and discards any attributes. Using this function, a type descriptor has the following format:</p>
<p class="Body"><span class="Monospace">[size][type code][type specific info][name (if applicable)]</span></p>
<table class="Borderless">
<tr>
<td>where</td>
<td><span class="Monospace">[size]</span></td>
<td>is the first word, in bytes, and includes the size word. The minimum value of <span class="Monospace">[size]</span> is 4. You can append a name (a Pascal string) to any type descriptor, which increases the value of <span class="Monospace">[size]</span> by the length of the name rounded up to a multiple of two. The size is 16 bits.</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">[type code]</span></td>
<td>is the second word. LabVIEW reserves the high-order byte of the type code for internal use. When comparing two type descriptors for equality, you should ignore this byte. Two type descriptors are equal even if the high-order bytes of the type codes are not. The type code is 16 bits.</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">[type specific info]</span></td>
<td>is additional information about the type descriptor. Arrays and clusters are structured or aggregate data types because they include references to other types. For example, the cluster type contains additional information about the type of each of its elements.</td>
</tr>
<tr>
<td></td>
<td><span class="Monospace">[name]</span></td>
<td>is a Pascal string. Name may or may not be present.</td>
</tr>
</table>
<p class="Body">The type code encodes the actual type information, such as single-precision or extended-precision, floating-point number, as listed in the following table. These type code values might change in future versions of LabVIEW.</p><a name="Data_Types"></a><h2>Data Types</h2>
<p class="Body">The following table lists numeric and non-numeric data types, type codes, and type descriptors. The minimum value of <span class="Monospace">[size]</span> appears before the type code. Information on the possible values of <span class="Monospace">[type specific info]</span> appears after the type code for some data types.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Name may be appended to any type descriptor. Name is a Pascal string.</td>
</tr>
</table>
<table class="Bordered">
<tr>
<th class="Bordered">
						Data Type
					</th>
<th class="Bordered">
						Type Descriptor (numbers in hexadecimal)
					</th>
</tr>
<tr>
<td class="Bordered">8-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>01</td>
</tr>
<tr>
<td class="Bordered">16-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>02</td>
</tr>
<tr>
<td class="Bordered">32-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>03</td>
</tr>
<tr>
<td class="Bordered">64-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>04</td>
</tr>
<tr>
<td class="Bordered">Unsigned 8-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>05</td>
</tr>
<tr>
<td class="Bordered">Unsigned 16-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>06</td>
</tr>
<tr>
<td class="Bordered">Unsigned 32-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>07</td>
</tr>
<tr>
<td class="Bordered">Unsigned 64-bit Integer</td>
<td class="Bordered">0004 <em>xx</em>08</td>
</tr>
<tr>
<td class="Bordered">Single-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>09</td>
</tr>
<tr>
<td class="Bordered">Double-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>0A</td>
</tr>
<tr>
<td class="Bordered">Extended-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>0B</td>
</tr>
<tr>
<td class="Bordered">Complex Single-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>0C</td>
</tr>
<tr>
<td class="Bordered">Complex Double-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>0D</td>
</tr>
<tr>
<td class="Bordered">Complex Extended-Precision, Floating-Point Number</td>
<td class="Bordered">0004 <em>xx</em>0E</td>
</tr>
<tr>
<td class="Bordered">Enumerated 8-bit Integer</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>15 <em>&lt;k&gt;</em><em>&lt;k pstrs&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Enumerated 16-bit Integer</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>16 <em>&lt;k&gt;</em><em>&lt;k pstrs&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Enumerated 32-bit Integer</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>17 <em>&lt;k&gt;</em><em>&lt;k pstrs&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Single-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>19 <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Double-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>1A <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Extended-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>1B <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Complex Single-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>1C <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Complex Double-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>1D <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Complex Extended-Precision Physical Quantity</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>1E <em>&lt;k&gt;</em><em>&lt;k base-exp&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Boolean</td>
<td class="Bordered">0004 <em>xx</em>21</td>
</tr>
<tr>
<td class="Bordered">String</td>
<td class="Bordered">0008 <em>xx</em>30 <em>&lt;dim&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Path</td>
<td class="Bordered">0008 <em>xx</em>32 <em>&lt;dim&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Picture</td>
<td class="Bordered">0008 <em>xx</em>33 <em>&lt;dim&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Array</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>40 <em>&lt;k dims&gt;</em><em>&lt;element type descriptor&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Cluster</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>50 <em>&lt;k elems&gt;</em><em>&lt;element type descriptors&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Waveform</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>54 <em>&lt;waveform type&gt;</em><em>&lt;element type descriptors&gt;</em></td>
</tr>
<tr>
<td class="Bordered">Refnum</td>
<td class="Bordered"><em>&lt;nn&gt;</em> &lt;refnum type code&gt;</td>
</tr>
<tr>
<td class="Bordered">Variant</td>
<td class="Bordered"><em>&lt;nn&gt;</em><em>xx</em>53</td>
</tr>
<tr>
<td class="Bordered" colspan="2"><em>nn</em> = length; <em>xx</em> = reserved by LabVIEW; <em>k</em> = number; <em>k pstrs</em> = number of Pascal strings; <em>k base-exp</em> = number of <a href="../lvconcepts/Old_Type_Descriptors.html#Physical_Quantity">base-exponent pairs</a>; <em>k dims</em> = number of dimensions; <em>k elems</em> = number of elements; <em>dim</em> is a 32-bit integer.</td>
</tr>
</table>
<p class="Body">The minimum value in the size field of a type descriptor is 4, as shown in the previous table. However, any type descriptor can have a name (a Pascal string) appended, in which case the size field is larger by the length of the name (as a Pascal string) rounded up to a multiple of two.</p><a name="Enumerated_8-Bit_Integer"></a><h2>Enumerated 8-Bit Integer</h2>
<p class="Body">In the following example of an enumerated 8-bit integer without a name for the items <span class="Monospace">am</span>, <span class="Monospace">fm</span>, and <span class="Monospace">fm stereo</span>, each group of characters represents a 16-bit word expressed in hexadecimal notation.</p>
<p class="Body">0016 0015 0003 0261 6D02 666D 0966 6D20 7374 6572 656F</p>
<p class="Body">The type descriptor has the following words:</p>
<ul>
<li>0016�indicates 22 bytes total</li>
<li>0015�indicates the type code for an enumerated 8-bit integer</li>
<li>0003�indicates there are three items</li>
<li>0261 6D02 666D 0966 6D20 7374 6572 656F�indicates the type code specific information. For example, 0261 6D is the ASCII encoding for <span class="Monospace">am</span> with the 02 prefix indicating the size of the string in hexadecimal.</li>
</ul>
<p class="Body">If the same enumerated 8-bit integer was named <span class="Monospace">radio</span>, its type descriptor can be interpreted as:</p>
<p class="Body">001C 4015 0003 0261 6D02 666D 0966 6D20 7374 6572 656F 0572 6164 696F</p>
<p class="Body">Below is a comparison of the two descriptors:</p>
<table class="Bordered">
<tr>
<td class="Bordered" colspan="2">
<p class="Anchor"><img src="type_descriptors_comparison.gif"></p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Anchor"><img src="callout_1.gif"></p>
</td>
<td class="Bordered">Different lengths</td>
</tr>
<tr>
<td class="Bordered">
<p class="Anchor"><img src="callout_2.gif"></p>
</td>
<td class="Bordered">Identical type codes</td>
</tr>
<tr>
<td class="Bordered">
<p class="Anchor"><img src="callout_3.gif"></p>
</td>
<td class="Bordered">Identical representation of enum values</td>
</tr>
<tr>
<td class="Bordered">
<p class="Anchor"><img src="callout_4.gif"></p>
</td>
<td class="Bordered">Name, <span class="Monospace">radio</span> as Pascal string</td>
</tr>
</table><a name="Physical_Quantity"></a><h2>Physical Quantity</h2>
<p class="Body">In the following example of a double-precision physical quantity with units m/s, each group of characters represents a 16-bit word expressed in hexadecimal notation.</p>
<p class="Body">000E 001A 0002 0002 FFFF 0003 0001</p>
<p class="Body">The type descriptor has the following words:</p>
<ul>
<li>000E�indicates 14 bytes total</li>
<li>001A�indicates the type code for a double-precision physical quantity</li>
<li>0002�indicates two base-exponent pairs</li>
<li>0002�denotes the seconds base index</li>
<li>FFFF (-1)�indicates the exponent of seconds</li>
<li>0003�denotes the meters base index</li>
<li>0001�indicates the exponent of meters</li>
</ul>
<p class="Body">LabVIEW stores all physical quantities internally in terms of base units, regardless of the units used to display them.</p>
<p class="Body">The following table shows the nine bases LabVIEW uses and their representation by indexes 0 through 8.</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Quantity Name
					</th>
<th class="Bordered">
						Unit
					</th>
<th class="Bordered">
						Abbreviation
					</th>
<th class="Bordered">
						Base Value
					</th>
</tr>
<tr>
<td class="Bordered">plane angle</td>
<td class="Bordered">
							radian</td>
<td class="Bordered">
							rad</td>
<td class="Bordered">
							0</td>
</tr>
<tr>
<td class="Bordered">solid angle</td>
<td class="Bordered">
							steradian</td>
<td class="Bordered">
							sr</td>
<td class="Bordered">
							1</td>
</tr>
<tr>
<td class="Bordered">time</td>
<td class="Bordered">
							second</td>
<td class="Bordered">
							s</td>
<td class="Bordered">
							2</td>
</tr>
<tr>
<td class="Bordered">length</td>
<td class="Bordered">
							meter</td>
<td class="Bordered">
							m</td>
<td class="Bordered">
							3</td>
</tr>
<tr>
<td class="Bordered">mass</td>
<td class="Bordered">
							kilogram</td>
<td class="Bordered">
							kg</td>
<td class="Bordered">
							4</td>
</tr>
<tr>
<td class="Bordered">electric current</td>
<td class="Bordered">
							ampere</td>
<td class="Bordered">
							A</td>
<td class="Bordered">
							5</td>
</tr>
<tr>
<td class="Bordered">thermodynamic temperature</td>
<td class="Bordered">
							kelvin</td>
<td class="Bordered">
							K</td>
<td class="Bordered">
							6</td>
</tr>
<tr>
<td class="Bordered">amount of substance</td>
<td class="Bordered">
							mole</td>
<td class="Bordered">
							mol</td>
<td class="Bordered">
							7</td>
</tr>
<tr>
<td class="Bordered">luminous intensity</td>
<td class="Bordered">
							candela</td>
<td class="Bordered">
							cd</td>
<td class="Bordered">
							8</td>
</tr>
</table><a name="String_Path_and_Pict_Data_Types"></a><h2>String, Path, and Picture Data Types</h2>
<p class="Body">The string, path, and picture data types have a 32-bit length, similar to the array dimension size. However, the only value currently encoded is hexadecimal FFFFFFFF, which indicates variable sized. Currently, all strings, paths, and pictures are variable size. The actual length is stored with the data.</p><a name="Array_and_Cluster_Data_Types"></a><h2>Array and Cluster Data Types</h2>
<p class="Body">The array and cluster data types each have their own type code. They also contain additional information about the data types of their elements and the dimensionality for arrays or number of elements for clusters.</p><a name="Array"></a><h3>Array</h3>
<p class="Body">The type code for an array is 40. The type descriptor for an array has the following format:</p>
<p class="Body"><em>&lt;nn&gt;</em> <em>xx</em>40 <em>&lt;k dims&gt;</em> <em>&lt;element type descriptor&gt;</em></p>
<p class="Body">Consider the following example of a type descriptor for a 1D array of double-precision, floating-point numbers, where each group of characters represents a 16-bit word expressed in hexadecimal notation:</p>
<p class="Body">000E 0040 0001 FFFF FFFF 0004 000A <span class="Monospace">[type specific info]</span></p>
<p class="Body">The type descriptor has the following words:</p>
<ul>
<li>000E�indicates 12 bytes total, which is the length of the entire type descriptor including the element type index</li>
<li>0040�indicates the type code for an array</li>
<li>0001�indicates one dimension, the number of dimensions in the array</li>
<li>FFFF FFFF�indicates the size of the dimension, which is variable-sized. LabVIEW stores the actual dimension size, which is always greater than or equal to zero, with the data.</li>
<li>0004 000A�indicates the type descriptor for the element. The element type can be any type except an array. In this example, the elements are double-precision, floating-point numbers and have the following words:
					<ul>
<li>0004�indicates 4 bytes, which is the size of the element</li>
<li>000A�indicates the type code for a double-precision, floating point number</li>
</ul>
				</li>
</ul>
<p class="Body">The following is the format of the type descriptor save buffer for this example:</p>
<table class="Bordered">
<tr>
<td class="Bordered">
						Number of type descriptors
					</td>
<td class="Bordered">
						0000 0002
					</td>
<td class="Bordered">
						The number of unique type descriptors is 2.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 0
					</td>
<td class="Bordered">
						0004 000A
					</td>
<td class="Bordered">
						The first type descriptor is for the double-precision, floating-point number.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 1
					</td>
<td class="Bordered">
						000E 0040 0001 FFFF FFFF
					</td>
<td class="Bordered">
						The second type descriptor is for the array. 000E is the length of the entire type descriptor, including the element type index. The array is variable sized, so the dimension is FFFFFFFF.
					</td>
</tr>
<tr>
<td class="Bordered">
						Number of types used
					</td>
<td class="Bordered">
						0002
					</td>
<td class="Bordered">
						The total number of types used is 2.
					</td>
</tr>
<tr>
<td class="Bordered">
						Types used
					</td>
<td class="Bordered">
						0000 0001
					</td>
<td class="Bordered">
						The types used are 0 and 1.
					</td>
</tr>
</table>
<p class="Body">Consider the following example of a type descriptor for a 2D array of Boolean values:</p>
<p class="Body">0012 0040 0002 FFFF FFFF FFFF FFFF 0004 0021 <span class="Monospace">[type specific info]</span></p>
<p class="Body">The type descriptor has the following words:</p>
<ul>
<li>0012�indicates 18 bytes total, which is the length of the entire type descriptor including the element type index</li>
<li>0040�indicates the type code for an array</li>
<li>0002�indicates two dimensions, the number of dimensions in the array</li>
<li>FFFF FFFF (-1)�indicates the size of the first dimension, which is variable-sized</li>
<li>FFFF FFFF (-1)�indicates the size of the second dimension, which is variable-sized</li>
<li>0004 0021�indicates the type descriptor for the element. In this example, the elements are Boolean and have the following words:
					<ul>
<li>0004�indicates 4 bytes, which is the size of the element</li>
<li>0021�indicates the type code for a Boolean</li>
</ul>
</li>
</ul>
<p class="Body">The following is the format of the type descriptor save buffer for this example:</p>
<table class="Bordered">
<tr>
<td class="Bordered">
						Number of type descriptors
					</td>
<td class="Bordered">
						0000 0002
					</td>
<td class="Bordered">
						The number of unique type descriptors is 2.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 0
					</td>
<td class="Bordered">
						0004 0021
					</td>
<td class="Bordered">
						The first type descriptor is for the Boolean.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 1
					</td>
<td class="Bordered">
						0012 0040 0002 FFFF FFFF FFFF FFFF
					</td>
<td class="Bordered">
						The second type descriptor is for the array. 0012 is the length of the entire type descriptor, including the element type index. The array is variable sized, so the dimension is FFFFFFFF.
					</td>
</tr>
<tr>
<td class="Bordered">
						Number of types used
					</td>
<td class="Bordered">
						0002
					</td>
<td class="Bordered">
						The total number of types used is 2.
					</td>
</tr>
<tr>
<td class="Bordered">
						Types used
					</td>
<td class="Bordered">
						0000 0001
					</td>
<td class="Bordered">
						The types used are 0 and 1.
					</td>
</tr>
</table><a name="Cluster"></a><h3>Cluster</h3>
<p class="Body">The type code for a cluster is 50. The type descriptor for a cluster has the following format:</p>
<p class="Body"><em>&lt;nn&gt;</em> <em>xx</em>50 <em>&lt;k elems&gt;</em> <em>&lt;element type descriptors&gt;</em></p>
<p class="Body">Consider the following example of a type descriptor for a cluster containing two integers, a signed 16-bit integer and an unsigned 32-bit integer, where each group of characters represents a 16-bit word expressed in hexadecimal notation:</p>
<p class="Body">000E 0050 0002 0004 0002 0004 0007</p>
<p class="Body">The type descriptor has the following words:</p>
<ul>
<li>000E�indicates 14 bytes total</li>
<li>0050�indicates the type code for a cluster</li>
<li>0002�indicates two elements, the number of elements in the cluster</li>
<li>0004 0002�indicates the type descriptor of the first element, a signed 16-bit integer:
					<ul>
<li>0004�indicates 4 bytes</li>
<li>0002�indicates the type code for a signed 16-bit integer</li>
</ul>
</li>
<li>0004 0007�indicates the type descriptor of the second element, an unsigned 32-bit integer:
					<ul>
<li>0004�indicates 4 bytes</li>
<li>0007�indicates the type code for an unsigned 32-bit integer</li>
</ul>
</li>
</ul>
<p class="Body">The following is the format of the type descriptor save buffer format:</p>
<table class="Bordered">
<tr>
<td class="Bordered">
						Number of type descriptors
					</td>
<td class="Bordered">
						0000 0003
					</td>
<td class="Bordered">
						The number of unique type descriptors is 3.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 0
					</td>
<td class="Bordered">
						0004 0002
					</td>
<td class="Bordered">
						The first type descriptor is for the signed 16-bit integer.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 1
					</td>
<td class="Bordered">
						0004 0007
					</td>
<td class="Bordered">
						The second type descriptor is for the unsigned 32-bit integer.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 2
					</td>
<td class="Bordered">
						000E 0050 0002
					</td>
<td class="Bordered">
						The third type descriptor is for the cluster. 000E is the length of the entire type descriptor, including the cluster type index.
					</td>
</tr>
<tr>
<td class="Bordered">
						Number of types used
					</td>
<td class="Bordered">
						0003
					</td>
<td class="Bordered">
						The total number of types used is 3.
					</td>
</tr>
<tr>
<td class="Bordered">
						Types used
					</td>
<td class="Bordered">
						0000 0001 0002
					</td>
<td class="Bordered">
						The types used are 0, 1, and 2.
					</td>
</tr>
</table>
<p class="Body">Because array and cluster type descriptors contain other type descriptors, they might become deeply nested.</p>
<p class="Body">Note that duplicate types are not included in the type list. The following example is a type descriptor list of a 1D array of double-precision, floating-point numbers and a cluster with one double-precision, floating-point number.</p>
<table class="Bordered">
<tr>
<td class="Bordered">
						Number of type descriptors
					</td>
<td class="Bordered">
						0000 0003
					</td>
<td class="Bordered">
						The number of unique type descriptors is 3.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 0
					</td>
<td class="Bordered">
						0005 000A 00
					</td>
<td class="Bordered">
						The first type descriptor is for the element type and appears exactly as it does for a scalar of the same type.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 1
					</td>
<td class="Bordered">
						000C 0040 0001 FFFF FFFF 0000
					</td>
<td class="Bordered">
						The second type descriptor is for the array. 000C is the length of the entire type descriptor, including the element type index. The array is variable sized, so the dimension is FFFFFFFF.
					</td>
</tr>
<tr>
<td class="Bordered">
						Type descriptor 2
					</td>
<td class="Bordered">
						0008 0050 0001 0002
					</td>
<td class="Bordered">
						The third type descriptor is for the cluster. 0008 is the length of the entire type descriptor, including the cluster type index. The cluster contains one element by the type at index 2.
					</td>
</tr>
<tr>
<td class="Bordered">
						Number of types used
					</td>
<td class="Bordered">
						0003
					</td>
<td class="Bordered">
						The total number of types used is 4.
					</td>
</tr>
<tr>
<td class="Bordered">
						Types used
					</td>
<td class="Bordered">
						0000 0001 0000 0002
					</td>
<td class="Bordered">
						The types used are 0, 1, 0, and 2.
					</td>
</tr>
</table>
<p class="Body">Note that the type referenced in the cluster at index 2 must be looked up in the types used array to make sense. The second element in types used is 0, which corresponds to type descriptor 0.</p><a name="Waveform"></a><h2>Waveform</h2>
<p class="Body">The type code for a waveform is 54. A word that contains the type of waveform immediately follows the type code. The type descriptor of the cluster of the waveforms elements follows this word. There are five categories of waveforms:</p>
<ul>
<li>Analog</li>
<li>Digital</li>
<li>Digital Data</li>
<li>Time Stamp</li>
<li>Dynamic</li>
</ul><a name="Analog_Waveform"></a><h3>Analog Waveform</h3>
<p class="Body">The following table lists the types of analog waveforms.</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Type
					</th>
<th class="Bordered">
						Subtype Code
					</th>
</tr>
<tr>
<td class="Bordered">8-bit signed</td>
<td class="Bordered">14</td>
</tr>
<tr>
<td class="Bordered">16-bit signed</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">32-bit signed</td>
<td class="Bordered">15</td>
</tr>
<tr>
<td class="Bordered">64-bit signed</td>
<td class="Bordered">19</td>
</tr>
<tr>
<td class="Bordered">Double-Precision</td>
<td class="Bordered">3</td>
</tr>
<tr>
<td class="Bordered">Single-Precision</td>
<td class="Bordered">5</td>
</tr>
<tr>
<td class="Bordered">Extended-Precision</td>
<td class="Bordered">10</td>
</tr>
<tr>
<td class="Bordered">8-bit unsigned</td>
<td class="Bordered">11</td>
</tr>
<tr>
<td class="Bordered">16-bit unsigned</td>
<td class="Bordered">12</td>
</tr>
<tr>
<td class="Bordered">32-bit unsigned</td>
<td class="Bordered">13</td>
</tr>
<tr>
<td class="Bordered">64-bit unsigned</td>
<td class="Bordered">20</td>
</tr>
<tr>
<td class="Bordered">Complex Single-Precision</td>
<td class="Bordered">16</td>
</tr>
<tr>
<td class="Bordered">Complex Double-Precision</td>
<td class="Bordered">17</td>
</tr>
<tr>
<td class="Bordered">Complex Extended-Precision</td>
<td class="Bordered">18</td>
</tr>
</table>
<p class="Body">For example, consider a double-precision waveform, where each group of characters represents a 16-bit word expressed in hexadecimal notation:</p>
<p class="Body">0006 0054 0003 <span class="Monospace">//size of waveform, waveform type code, and double-precision subtype code 3</span></p>
<p class="Body">0080 0050 0005 <span class="Monospace">//size of cluster, cluster code, and number of elements</span></p>
<p class="Body">&lt;type descriptor of time stamp&gt;</p>
<p class="Body">&lt;type descriptor of <em>dt</em>&gt;</p>
<p class="Body">&lt;type descriptor of array of element type&gt;</p>
<p class="Body">&lt;type descriptor of unused error cluster&gt;</p>
<p class="Body">&lt;type descriptor of attributes&gt;</p>
<p class="Body">The type descriptor of the other types of analog waveforms is similar to the double-precision waveform. The difference is a different type for the array element and a different subtype.</p>
<h3>Digital Waveform and Digital Data</h3>
<p class="Body">The digital waveform is the only type of waveform that has a subtype code 8.</p>
<p class="Body">For example, consider the following, where each group of characters represents a 16-bit word expressed in hexadecimal notation:</p>
<p class="Body">00B6 0054 0008 <span class="Monospace">//size of digital waveform, waveform type code, and subtype code 8</span></p>
<p class="Body">&lt;type descriptor of time stamp&gt;</p>
<p class="Body">&lt;type descriptor of <em>dt</em>&gt;</p>
<p class="Body">&lt;type descriptor of digital data&gt;</p>
<p class="Body">&lt;type descriptor of unused error cluster&gt;</p>
<p class="Body">&lt;type descriptor of attributes&gt;</p>
<h3>Digital Data</h3>
<p class="Body">Digital data is the only data type with a waveform type code and a subtype code of 7.</p>
<p class="Body">For example, consider the following where each group of characters represents a 16-bit word expressed in hexadecimal notation:</p>
<p class="Body">003E 0054 0007 <span class="Monospace">//size of digital data, waveform type code, and subtype code 7</span></p>
<p class="Body">&lt;type descriptor of transitions&gt;</p>
<p class="Body">&lt;type descriptor of data&gt;</p>
<h3>Time Stamp</h3>
<p class="Body">The time stamp has a subtype code of 6. The time stamp is a 128-bit fixed-point number with a 64-bit radix. LabVIEW stores a time stamp as a cluster of four integers where the first two signed integers (64 bits) represent the number of whole seconds after 12:00 a.m., Friday, January 1, 1904, Universal Time [01-01-1904 00:00:00]. The next two unsigned integers (64 bits) represent the fractions of seconds. Refer to the following <a href="javascript:WWW(WWW_TIMESTAMP)">support document</a> at <span class="Monospace">ni.com</span> for more information about time stamps. In the text below, each group of characters represents a 16-bit word expressed in hexadecimal notation.</p>
<p class="Body">001C 0054 0006 <span class="Monospace">//size of time stamp, waveform type code, and time stamp subtype code 6</span></p>
<p class="Body">&lt;type descriptor of an analog waveform&gt;</p>
</body>
</html>