<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Using_LV_to_Create_Multithrded_VIs_for_Max_Perf.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Pipelining for Systems with Multiple CPUs</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="pipelining"></a><h1>Pipelining for Systems with Multiple CPUs</h1>
<p class="Body">
				
				
				The primary advantage of a multiple-CPU system, also known as multi-core, multiprocessor, or SMP system, is that multiple threads can execute in parallel. Therefore, it is difficult to take advantage of a multiple processor system when an application consists mainly of a single sequential process. However, you can take advantage of multiple CPUs to improve the throughput of a sequential process by implementing a pipelined architecture. A pipeline takes advantage of parallel execution on multiple CPUs while preserving sequential dataflow.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Pipelining an application requires data transfer between CPUs, which takes more time than simply passing data to the next operation on a single CPU. Therefore, implementing a pipeline increases the speed of the VI only if the time saved through parallel processing exceeds the time spent transferring data between CPUs.</td>
</tr>
</table><a name="pipeline_implementation"></a><h2>Pipeline Implementation</h2>
<p class="Body">To implement a pipeline in an LabVIEW VI, divide the code into discrete steps or subVIs. For example, you can divide a complex sequential process into two discrete steps by wrapping the first half of the process in one subVI and the second half in another subVI. The following block diagram shows a standard sequential architecture on the left and a pipelined architecture on the right.</p>
<p class="Anchor"><img src="loc_bd_Pipelining_After.gif"></p>
<p class="Body">The architecture on the left does not take advantage of multiple CPUs because LabVIEW runs both subVIs in a single execution thread that must execute sequentially on a single CPU, as shown in the following illustration.</p>
<p class="Anchor"><img src="loc_eps_Serial_Compare.gif"></p>
<p class="Body">However, when you wire the subVIs together through shift registers, LabVIEW pipelines the subVIs. Now, when the VI runs on a system with more than one CPU, the subVIs execute in parallel, as shown in the following illustration.</p>
<p class="Anchor"><img src="loc_eps_Pipeline_Compare.gif"></p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When you implement a pipeline, ensure that the stages of the pipeline do not use shared resources. Simultaneous requests for a shared resource impede parallel execution and diminish the performance benefit of a multiple-CPU system.</td>
</tr>
</table>
<p class="Body">If the CPUs executing the stages of the pipeline do not need to execute other tasks and you want to maximize CPU utilization, you can attempt to balance the stages of the pipeline so that each stage takes roughly the same time to execute. When one pipeline stage takes longer to execute than another, the CPU running the shorter stage must wait while the longer stage finishes executing.</p><a name="pipeline_dataflow"></a><h2>Pipeline Dataflow</h2>
<p class="Body">Pipelining takes advantage of parallel processing while preserving sequential dataflow dependencies. In the previous example, subVI A processes input 1 during the first iteration of the loop, while subVI B processes the default value of the shift register, yielding an invalid output. During the second loop iteration, subVI A processes input 2 while subVI B processes the output of subVI A from the first loop iteration. Notice that the output from subVI B does not become valid until the pipeline fills. Once the pipeline is full, all subsequent loop iterations yield valid output, with a constant lag of one loop iteration.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You must use caution to prevent undesired behavior due to the invalid outputs that occur at the beginning of pipelined execution. For example, you can use a Case structure to enable actuators only after <em>N</em> Timed Loop iterations elapse.</td>
</tr>
</table>
<p class="Body">In general, the output of the final pipeline stage lags behind the input by the number of stages in the pipeline, and the output is invalid for each loop iteration until the pipeline fills. The number of stages in a pipeline is called the pipeline depth, and the latency of a pipeline, measured in loop iterations, corresponds to its depth. For a pipeline of depth <em>N</em>, the result is invalid until the <em>N</em>th loop iteration, and the output of each valid loop iteration lags behind the input by <em>N</em>�1 loop iterations.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The number of pipeline stages that can execute in parallel is limited to the number of available CPUs.</td>
</tr>
</table><a name="pipeline_TL"></a><h2>Pipelining with Timed Loops</h2>
<p class="Body">
				<span class="Platform">(Real-Time, Windows)</span> If you want to target each pipeline stage to a particular CPU, you can implement a pipeline using Timed Loops. You cannot use shift registers in a Timed Loop to implement a pipeline because LabVIEW maps each Timed Loop to a single thread. To implement a pipeline with Timed Loops, you must place each pipeline stage in a parallel Timed Loop and pass data between the Timed Loops using a <a href="../glang/Create_Queue.html">queue</a>, <a href="../glang/Local_Variable.html">local</a> variable, or <a href="../glang/Global_Variable.html">global</a> variable.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Implementing a pipeline using local or global variables can be difficult. Local and global variables do not wait for new data to become available, which can result in skipped inputs and repeated outputs from the same input.</td>
</tr>
</table>
<table class="checkFile lvrthelp">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Refer to the <a href="../lvrtconcepts/Pipeline_RT.html">LabVIEW Real-Time Module Help</a> for information about using pipelines in RT applications.</td>
</tr>
</table>
</body>
</html>