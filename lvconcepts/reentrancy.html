<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Performance_and_Memory_Management.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Reentrancy: Allowing Simultaneous Calls to the Same SubVI</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Simultaneously_Calling_SubVIs_from_Multiple_Places"></a><h1>Reentrancy: Allowing Simultaneous Calls to the Same SubVI</h1>
<p class="Body">
					
					
					
					
					
					
						By default, LabVIEW configures VIs for <em>non-reentrant execution</em>. In non-reentrant execution, when a VI is called as a subVI simultaneously by other VIs, only one of those calls can enter and execute the subVI at a time. LabVIEW ensures that callers of the non-reentrant subVI take turns using the subVI. A non-reentrant VI has only a single data space to store the parameters of its callers, any temporary values computed during execution, and any state that the non-reentrant VI maintains between calls. However, if you configure a VI for <em>reentrant execution</em>, LabVIEW can enter and execute the reentrant VI simultaneously from all callers. In reentrant execution, LabVIEW allocates multiple instances, or <em>clones</em>, of the data space so that each <em>call site</em>, or usage of the subVI on the block diagram of the caller, can execute simultaneously, in parallel, such that each call site uses a separate clone.</p>
<table class="checkFile lvfpga">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��
					<span class="Platform">(FPGA Module)</span> FPGA VIs are <a href="../lvfpgaconcepts/fpga_determine_RE_NRE_subVI.html">reentrant by default</a>.</td>
</tr>
</table><a name="Types_of_Reentrant_Execution"></a><h3>Types of Reentrant Execution</h3>
<p class="Body">
							
					LabVIEW provides the following types of reentrant VIs:</p>
<ul>
<li><strong>Non-reentrant execution</strong>�LabVIEW allocates a single data space for use by all instances of the subVI.</li>
<li><strong>Shared clone reentrant execution</strong>�LabVIEW allocates a pool of clones, initially populated with one clone, to share amongst callers. When a caller calls a shared clone VI, it pulls a clone from the pool and returns the clone when the call finishes executing. If the pool is empty when a caller calls a shared clone VI, LabVIEW creates a new clone for that call and places the clone in the pool when execution finishes, thereby expanding the clone pool.</li>
<li><strong>Preallocated clone reentrant execution</strong>�LabVIEW allocates a separate, non-shareable, clone for each use of the subVI.</li>
</ul>
<p class="Body">To configure the reentrancy settings for a VI, refer to the <a href="../lvdialog/Execution.html">Execution</a> page of the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box.</p><a name="Choosing_Type_of_Reentrant_Execution"></a><h3>Choosing Which Type of Reentrant Execution to Use</h3>
<table class="Bordered">
<tr>
<th class="Bordered">Usage Considerations</th>
<th class="Bordered">Non-reentrant</th>
<th class="Bordered">Shared Clone Reentrancy</th>
<th class="Bordered">Preallocated Clone Reentrancy</th>
</tr>
<tr>
<td class="Bordered">Ability to maintain state, such as in uninitialized shift registers</td>
<td class="Bordered">Maintains a single instance of the data space and uses its state across all call sites.</td>
<td class="Bordered">Does <em>not</em> maintain state�Each call site pulls the data space of a clone randomly from the pool of clones. Call sites may end up sharing state.</td>
<td class="Bordered">Maintains state for each call site�Each call site has its own separate and specific clone.</td>
</tr>
<tr>
<td class="Bordered">Determinism for multiple, simultaneous calling VIs</td>
<td class="Bordered">Call sites might wait in line behind other simultaneous callers�The time required for an instance of a subVI to begin executing varies with how many other instances are scheduled to execute before it.</td>
<td class="Bordered">Possible waiting�Call sites may need to wait for LabVIEW to create a new clone if the pool of clones is empty. When the pool is not empty, pulling a clone and returning the clone to the pool can introduce non-deterministic delays.</td>
<td class="Bordered">No waiting�LabVIEW allocates a clone for each call site prior to execution. This allows deterministic memory usage and execution speed.</td>
</tr>
<tr>
<td class="Bordered">Call overhead when no simultaneous calling VIs exist</td>
<td class="Bordered">Medium�LabVIEW must check for simultaneous callers.</td>
<td class="Bordered">Highest�LabVIEW must atomically pull clones from and return clones to the pool of clones. Calls may need to wait for LabVIEW to add a clone to the pool.</td>
<td class="Bordered">Lowest�LabVIEW already preallocates a clone to each call site.</td>
</tr>
<tr>
<td class="Bordered">Memory usage</td>
<td class="Bordered">Lowest�LabVIEW allocates only a single data space for the subVI.</td>
<td class="Bordered">Medium�LabVIEW must allocate clones only for the maximum number of instances running simultaneously.</td>
<td class="Bordered">Highest�LabVIEW must allocate a clone for each instance of the subVI.</td>
</tr>
</table>
<table class="checkFile lvfpga">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��
					<span class="Platform">(FPGA Module)</span> Shared clone reentrant VIs and preallocated clone reentrant VIs behave the same when used in FPGA VIs.</td>
</tr>
</table><a name="dynamicallyCallingReentrantVIs"></a><h3>Asynchronously Calling Multiple Instances of a Reentrant VI</h3>
<p class="Body">Refer to the <a href="../lvhowto/acbr_call_clones.html">Asynchronously Calling Multiple Instances of a VI for Parallel Execution</a> topic for information about asynchronously calling reentrant VIs.</p><a name="viewingFrontPanels"></a><h3>Viewing the Front Panel of the Clone of a Reentrant VI</h3>
<p class="Body">Each clone has an individual front panel. To view the front panel while the clone is not running, double-click the instance of the subVI whose panel you want to view. You can also set the reentrant VI to <a href="../lvhowto/Opening_SubVI_Front_Panels.html">open the front panel during execution</a>. The title bar of the subVI contains <span class="Monospace">(clone)</span> to indicate that it is a clone rather than the original VI. To access the original VI from the clone, select <strong>View�Browse Relationships�Reentrant Items</strong>. You can also use the <a href="../lvprop/VI_Open_Front_Panel.html">Front Panel:Open</a> method within the subVI to programmatically open the front panel of each clone when it runs. The title bar of the subVI contains <span class="Monospace">(clone)</span> to indicate that it is a clone of the source VI.</p>
<p class="Body">You can interact with the front panel of a reentrant VI similarly to the front panel of a non-reentrant VI, particularly in the following ways:</p>
<ul>
<li>Configuring an <a href="../glang/Event_Structure.html">Event</a> structure to handle events for front panel objects</li>
<li>Using the front panel as a <a href="../lvhowto/Loading_Panel_in_Subpanel.html">subpanel</a></li>
<li>Using properties and methods to <a href="../lvhowto/Prog_Controlling_FP_Objs.html">configure controls and indicators</a></li>
</ul><a name="Examples_of_Reentrant_Execution"></a><h3>Examples of Reentrant Execution</h3>
<p class="Body">The following two sections describe examples of reentrant VIs that wait and do not share data. </p><a name="Using_a_VI_that_Waits"></a><h4>Ensuring Simultaneous Execution of SubVI Instances</h4>
<p class="Body">
				
				The following block diagram alerts the user when both his <strong>Lunch Time</strong> and his <strong>Break Time</strong> arrive. However, the reentrancy setting of the Alarm Timer VI is critical for producing accurate results.</p>
<p class="Anchor"><img src="loc_bd_break_timer.gif"></p>
<table class="Borderless">
<tr>
<td><img style="display:inline" src="noloc_eps_callout_1.gif"></td>
<td>The user specifies a <strong>Lunch Time</strong> and a <strong>Break Time</strong>. For the purposes of this example, assume <strong>Lunch Time</strong> is 12:00pm and <strong>Break Time</strong> is 10:00am.</td>
</tr>
<tr>
<td><img style="display:inline" src="noloc_eps_callout_2.gif"></td>
<td>The Alarm Timer VI waits until the specified input time. Because the instances of the Alarm Timer VI appear in parallel parts of the diagram, it is impossible to predict which instance executes first. For the purposes of this example, assume the <strong>Lunch Time</strong> timer executes first.</td>
</tr>
</table>
<p class="Body">If the Alarm Timer VI is configured for non-reentrant execution, the <strong>Break Time</strong> timer cannot begin running until 12:00pm because it must wait for the <strong>Lunch Time</strong> timer to finish executing. This delay prevents the <strong>Break Time</strong> timer from triggering an alarm at 10:00am. Therefore, to ensure that both instances of the subVI can execute simultaneously and trigger their alarms at the appropriate time, you must configure the Alarm Timer VI to use one of the types of reentrant execution.</p><a name="Using_a_Storage_VI_Not_Meant_to_Share_Its_Data"></a><h4>Storing Data between Multiple Calls to Each Instance of a SubVI</h4>
<p class="Body">To maintain state between calls to a subVI from a specific call site, you must use preallocated clone reentrant execution. For example, you create a VI, ExpAvg, that calculates a running exponential average of the last four data points that have been passed to the VI. LabVIEW can maintain the most recent four data points as state in an uninitialized shift register in a single iteration While Loop.</p>
<p class="Body">Another VI uses the ExpAvg subVI to calculate the running average of two data acquisition channels. The VI monitors the voltages at two points in a process and displays the exponential running average on a strip chart. The block diagram of the VI contains two instances of the ExpAvg subVI. The calls alternate � one for Channel 0, and one for Channel 1. Assume Channel 0 runs first. If the ExpAvg subVI is not reentrant, the call for Channel 1 uses the average computed by the call for Channel 0, and the call for Channel 0 uses the average computed by the call for Channel 1. By making the ExpAvg subVI reentrant, each call can run independently without sharing the data.</p><a name="Reentrant_Exec_in_Timed_Structs"></a><h3>Overriding Reentrancy Settings for SubVIs in Timed Structures</h3>
<p class="Body">
				<span class="Platform">(Real-Time, Windows)</span> You can configure LabVIEW to either preallocate or share clones of a shared-clone reentrant VI within a <a href="../lvconcepts/CON_Timed_Structures.html">Timed Loop or Timed Sequence</a> structure. For example, if you place a shared-clone reentrant VI inside of a Timed Loop or Timed Sequence structure, you can set the structure to preallocate clones for instances of the reentrant VI you call within the structure. Instances of the reentrant VI that you call outside the structure continue to share clones. To set the allocation of a VI within a Timed Loop or a Timed Sequence structure, right-click the structure, select <strong>Shared Clone Allocation</strong>, and select one of the following:</p>
<ul>
<li>
					<strong>Automatic</strong>�LabVIEW decides whether to set the structure as <strong>Preallocate</strong> or <strong>Allocate As Needed</strong> based on the context of the structure. LabVIEW will append the shortcut menu item with text that indicates the setting LabVIEW chooses. For example, if LabVIEW chooses <strong>Preallocate</strong>, the menu item becomes <strong>Automatic (Preallocate)</strong>.</li>
<li>
					<strong>Preallocate</strong>�LabVIEW creates a clone VI for each call to the reentrant VI within the structure. The Timed Loop or Timed Sequence structure displays an <img style="display:inline" src="noloc_env_preallocate.gif"> icon to indicate that LabVIEW is preallocating clones for any reentrant VI in the structure.</li>
<li>
					<strong>Allocate As Needed</strong>�LabVIEW does not create a clone VI until you make a call to the reentrant VI within the structure. The Timed Loop or Timed Sequence structure displays an <img style="display:inline" src="noloc_env_pooled.gif"> icon to indicate that LabVIEW is sharing clones for any reentrant VI in the structure.</li>
</ul><a name="Debugging_Reentrant_VIs"></a><h3>Debugging Reentrant VIs</h3>
<p class="Body">
				
				
						To allow debugging on a reentrant VI, select <strong>File�VI Properties</strong> to display the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box, select <strong>Execution</strong> from the pull-down menu, and place a checkmark in the <strong>Allow debugging</strong> checkbox.</p>
<p class="Body">To debug a specific instance of a VI with preallocated clones, open that instance of the subVI. Although you cannot edit the clone VI, you can use the block diagram of the clone for debugging purposes. For example, you can set <a href="../lvhowto/Breakpoints.html">breakpoints</a>, use <a href="../lvhowto/Using_the_Probe_Tool.html">probes</a>, enable <a href="../lvhowto/Execution_Highlighting.html">execution highlighting</a>, and <a href="../lvhowto/Single_Step_Mode.html">single-step</a> through execution.</p>
<p class="Body">To debug an instance of a VI that shares clones, apply breakpoints, probes, and execution highlighting within the source VI, not within the clone VI. Clone VIs do not maintain these settings across calls.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��When you debug applications and shared libraries, you cannot debug reentrant panels that an <a href="../glang/Open_VI_Reference.html">Open VI Reference</a> function creates. You also cannot debug reentrant panels that are entry points to LabVIEW-built shared libraries.</td>
</tr>
</table>
</body>
</html>