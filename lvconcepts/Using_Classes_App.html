<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Object_Oriented_Programming.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Using LabVIEW Classes and Interfaces in an Application</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>Using LabVIEW Classes and Interfaces in an Application</h1>
<p class="Body">
				
				
				
				
				LabVIEW classes and interfaces are user-defined data types. LabVIEW class and interface developers create and distribute these data types. The LabVIEW class or interface user does not need to know how to create a LabVIEW class or interface, but rather how to use the data type a class or interface defines in an application, what information is available to them in debugging code that uses LabVIEW classes or interfaces, and how a new version of the LabVIEW class or interface might affect the application the programmer has built.
			</p><a name="Creating_Class_Instance"></a><h2>Creating an Instance of a Class or Interface</h2>
<p class="Body">
				
				
				
				The LabVIEW class or interface does not need to be in the project. You can <a href="../lvhowto/Creating_Subpalettes.html">add the LabVIEW class or interface to the palette</a> so you can easily find and drag the class or interface to the block diagram or front panel window. To create an instance of the LabVIEW class or interface you receive or <a href="../lvhowto/creating_lv_classes.html">create</a>, place the class library file (<span class="Monospace">.lvclass</span>) as a control or constant on the front panel or block diagram on which you want to use it. You can use a LabVIEW user-defined data type similarly to other <a href="../lvconcepts/Block_Diagram_Objects.html#Control_and_Indicator_Data_Types">LabVIEW data types</a>.</p>
<p class="Body">Using the <a href="../lvdialog/Class_Browser.html">Class Browser window</a>, you can <a href="../lvhowto/Class_Browser_New.html">place member VIs</a> of the LabVIEW class or interface on the block diagram.</p><a name="Coercing_Classes_and_Interfaces"></a><h2>Coercing LabVIEW Classes and Interfaces</h2>
<p class="Body">LabVIEW coerces classes and interfaces to the nearest common parent class or interface with the following rules:</p>
<ul>
<li>If the input classes and interfaces are unrelated, LabVIEW coerces the inputs to LabVIEW Object.</li>
<li>If the input classes and interfaces have only one common parent, whether it is a class or interface, LabVIEW coerces the inputs to the common parent.</li>
<li>If the input classes and interfaces have multiple common parents, among which one is a class, LabVIEW coerces the inputs to the common parent class. To force LabVIEW to coerce the inputs to a common parent interface, cast one of the inputs to the desired parent type using the <a href="../glang/To_More_Generic_Class.html">To More Generic Class</a> function.</li>
<li>If the input classes and interfaces have multiple common parents that are all interfaces, LabVIEW breaks the VI. To force LabVIEW to coerce the inputs to a common parent interface, cast one of the inputs to the desired parent type using the <a href="../glang/To_More_Generic_Class.html">To More Generic Class</a> function.</li>
</ul><a name="Using_Context_Help"></a><h2>Using Context Help and Probes with Locked LabVIEW Classes or Interfaces</h2>
<p class="Body">The LabVIEW class or interface developer may <a href="../lvconcepts/Using_Classes.html#Locking_Classes">lock the LabVIEW class or interface</a> when he or she distributes the class or interface. If the LabVIEW class or interface developer locks the LabVIEW class or interface, the <a href="../lvdialog/Context_Help_Window.html">Context Help</a> window only displays the data type of the class or interface and the description of the class if the developer provides one. LabVIEW also only displays the data type of the class or interface in the <a href="../lvconcepts/Using_Classes.html#Probes_in_Classes">generic probe on a locked class or interface</a>. You can create a <a href="../lvhowto/Creating_Custom_Probes.html">non-member custom probe for a LabVIEW class or interface</a>, however the non-member custom probe only can display the public interface of the class or interface. The LabVIEW class or interface developer also can set a <a href="../lvhowto/Custom_Probe_Classes.html">custom default probe</a> for the class or interface to provide specialized class or interface information for debugging. Work with the LabVIEW class or interface developer to provide the appropriate amount of documentation or probe information necessary for working with the LabVIEW class or interface.</p><a name="Dynamic_VIs_Using_Classes"></a><h2>Dynamic Dispatch VIs</h2>
<p class="Body">Some member VIs of a LabVIEW class or interface can be dynamic dispatching. Dynamic dispatch methods are similar to polymorphic VIs. Where polymorphic VIs decide which VI to call depending upon the data type you wire to it, dynamic dispatch methods wait until run time to decide which member VI in the class hierarchy to call depending on the data that arrives at the input. Because a LabVIEW class or interface wire can carry data of its own type or data of any child type, LabVIEW determines which member VI in the class hierarchy to execute at run time. You can double-click dynamic dispatch member VI on the block diagram to view the particular VI that is on the block diagram. To view the other dynamic dispatch member VIs in the class hierarchy, you must view each individual VI in the class hierarchy.</p><a name="Mutating_Data"></a><h2>Mutating Data</h2>
<p class="Body">
				Tracking the version number of the LabVIEW class or interface is beneficial to LabVIEW class users who develop applications using LabVIEW classes or interfaces. For example, you have a LabVIEW class in an application that uses an unsigned 32-bit integer in the private data control of the class. A LabVIEW class developer can send you a version of the LabVIEW class that changes the numeric control in the private data control to a double-precision floating-point number. Because LabVIEW tracks version changes and knows how to flatten and unflatten data on all LabVIEW classes, you can replace the old version of the LabVIEW class with the new version and run the program without making changes to it. </p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you try to unflatten data from a future version of a LabVIEW class, LabVIEW returns an error. For example, this error might occur if you have data with a version number of 1.0.0.3 but the LabVIEW class in memory is version 1.0.0.2.</td>
</tr>
</table>
</body>
</html>