<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Building_the_Block_Diagram.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Numeric Data</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Numeric_Data"></a><h1>Numeric Data</h1>
<p class="Body">
				
						LabVIEW represents numeric data as <a href="../lvhowto/Floating_Point_Numbers.html">floating-point numbers</a>, <a href="../lvhowto/Fixed_Point_Numbers.html">fixed-point numbers</a>, <a href="../lvhowto/Integers.html">integers</a>, <a href="../lvhowto/Unsigned_Integers.html">unsigned integers</a>, and <a href="../lvhowto/Complex_Numbers.html">complex numbers</a>.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The difference among the numeric data types is the number of bits they use to <a href="../lvconcepts/How_LabVIEW_Stores_Data_in_Memory.html">store data</a> and the data values they represent.</td>
</tr>
</table>
<p class="Body">Certain data types also provide extended configuration options. For example, you can associate physical units of measure with floating-point data, including complex numbers, and you can <a href="../lvhowto/configure_fxp.html">configure the encoding and range</a> for fixed-point data.</p><a name="Numeric_Units_and_Strict_Type_Checking"></a><h2>Associating Numeric Units with Floating-Point Numbers</h2>
<p class="Body">
				
				
				
				
				You can <a href="../lvhowto/Numeric_Units.html">associate physical units of measure</a>, such as meters or kilometers/second, with any numeric control or indicator that has floating-point representation.
			</p>
<p class="Body">Units for a control appear in a separate owned label, called the unit label. Display the unit label by right-clicking the control and selecting <strong>Visible Items�Unit Label</strong> from the shortcut menu. Right-click the unit label and select <strong>Build Unit String</strong> from the shortcut menu to edit the unit label.</p>
<p class="Body">When LabVIEW displays the unit label, you can enter a unit using <a href="../lvhowto/Available_Units_in_LabVIEW.html">standard abbreviations</a> such as <span class="Monospace">m</span> for meters, <span class="Monospace">ft</span> for feet, <span class="Monospace">s</span> for seconds, and so on.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��You cannot use units in Formula Nodes.</td>
</tr>
</table><a name="Units_and_Strict_Type_Checking"></a><h3>Units and Strict Type Checking</h3>
<p class="Body">
				
				
				When you associate units with an object, you can wire only objects that have compatible units. LabVIEW uses strict type checking to verify that units are compatible. If you wire two objects with incompatible units, LabVIEW returns an error. For example, LabVIEW returns an error if you wire an object with mile as its unit type to an object with liter as its unit type, because a mile is a unit of distance and a liter is a unit of volume.</p>
<p class="Body">The following VI shows wiring objects with compatible units. In this VI, LabVIEW automatically scales the <strong>distance</strong> indicator to display kilometers instead of meters because kilometers is the unit for the indicator.</p>
<p class="Anchor"><img src="loc_fp_compat.gif"></p>
<p class="Anchor"><img src="loc_bd_compat.gif"></p>
<p class="Body">An error occurs in the following VI because <strong>distance</strong> has a unit type of seconds. To correct the error, change seconds to a unit of distance, such as kilometers, as shown in the previous VI.</p>
<p class="Anchor"><img src="loc_fp_incompat.gif"></p>
<p class="Anchor"><img src="loc_bd_incompat.gif"></p>
<p class="Body">Some VIs and functions are ambiguous with respect to units. You cannot use these VIs and functions with other terminals that have units. For example, the <a href="../glang/Increment.html">Increment</a> function is ambiguous with respect to units. If you use distance units, the Increment function cannot tell whether to add one meter, one kilometer, or one foot. Because of this ambiguity, you cannot use the Increment function and other functions that increment or decrement values with data that have associated units.</p>
<p class="Body">To avoid ambiguity in this example, use a numeric constant with the proper unit and the <a href="../glang/Add.html">Add</a> function to create your own increment unit function, as shown in the following block diagram.</p>
<p class="Anchor"><img src="loc_bd_incunit.gif"></p><a name="Using_FXP"></a><h2>Fixed-Point Data Type</h2>
<p class="Body">
				
				The fixed-point data type is a numeric data type that represents a set of rational numbers using binary digits, or bits. Unlike the <a href="../lvhowto/Floating_Point_Numbers.html">floating-point</a> data type, which allows the precision and range of the data to vary, you can configure fixed-point numbers to always use a specific number of integer and fractional bits.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��To represent a rational number using the fixed-point data type, the denominator of the rational number must be reducible to a power of 2, because the binary number system is a base-2 number system.</td>
</tr>
</table>
<p class="Body">Use the fixed-point data type when you do not need the dynamic range of floating-point representation or when you want to work with a target that does not support floating-point arithmetic.</p>
<table class="checkFile lvfpga">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��
				<span class="Platform">(FPGA Module)</span> Refer to <a href="../lvfpgaconcepts/FPGAFixedPoint.html">Using the Fixed-Point Data Type</a> for more information about using the fixed-point data type on an FPGA target. Evaluate your usage of <a href="../lvfpgaconcepts/Decide_Data_Type.html">numeric data types</a> to determine which data type best suits your design.</td>
</tr>
</table>
<h3>Representing Rational Numbers with the Fixed-Point Data Type</h3>
<p class="Body">A fixed-point number has a fixed number of integer and fractional bits. The integer bits appear to the left of the binary point, and the fractional bits appear to the right of the binary point. Because you can specify the exact number of bits you want to use, the binary point, which is the binary equivalent of the decimal point, has a fixed position.</p>
<p class="Body">For example, you can configure LabVIEW to represent the rational number 0.5 as a fixed-point number with 8 total bits and 4 integer bits.</p>
<table class="Bordered">
<tr>
<th class="Bordered">Rational Number</th>
<th class="Bordered">Fixed-Point Equivalent</th>
</tr>
<tr>
<td class="Bordered">0.5</td>
<td class="Bordered">0000.1000</td>
</tr>
</table>
<p class="Body">You also can configure LabVIEW to represent the same rational number as a fixed-point number with 16 total bits and 8 integer bits.</p>
<table class="Bordered">
<tr>
<th class="Bordered">Rational Number</th>
<th class="Bordered">Fixed-Point Equivalent</th>
</tr>
<tr>
<td class="Bordered">0.5</td>
<td class="Bordered">00000000.10000000</td>
</tr>
</table>
<p class="Body">Fixed-point numbers differ from floating-point numbers in that floating-point numbers allow the number of integer and fractional bits to vary when you perform an operation on the floating-point number. In other words, the binary point can move, or float, in a floating-point number.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you do not specify the exact number of bits you want to use to represent the fixed-point equivalent of a rational number, LabVIEW adjusts the number of bits to avoid data loss, if possible. LabVIEW cannot handle numbers longer than 64 bits. </td>
</tr>
</table><a name="FXP_configuration"></a><h3>Configuring Fixed-Point Numbers</h3>
<p class="Body">
				
				To set a number to fixed-point representation, right-click the numeric object and select <strong>Representation</strong> from the shortcut menu to change the data type of the object. You can <a href="../lvhowto/configure_fxp.html">configure the encoding</a> for fixed-point numbers. You also can specify whether to <a href="../lvhowto/configure_fxp.html">include an overflow status</a> with fixed-point numbers and how <a href="../glang/Numeric_Functions.html">Numeric</a> functions handle <a href="../lvconcepts/numeric_data.html#FXP_overflow">overflow and rounding</a> conditions for fixed-point numbers. To configure a fixed-point number, right-click a constant, control, indicator, or Numeric function and select <strong>Properties</strong> from the shortcut menu to display the <strong>Numeric Properties</strong>, <strong>Numeric Constant Properties</strong>, or <strong>Numeric Node Properties</strong> dialog box.</p><a name="encoding_length_intlength"></a><h4>Encoding</h4>
<p class="Body">Specify the binary encoding of a fixed-point number when you want the number to conform to a certain bit size.</p>
<ul>
<li>
					<strong>Signed</strong>�The option that determines whether the fixed-point data is signed. If you select signed, the sign bit is always the first bit in the bit string that represents the data.</li>
<li>
					<strong>Unsigned</strong>�The option that determines whether the fixed-point data is unsigned.</li>
<li>
					<strong>Word length</strong>�The total number of bits in the bit string that LabVIEW uses to represent all possible values of the fixed-point data. LabVIEW accepts a maximum word length of 64 bits. Certain targets might <a href="../lvhowto/cr_fixed_point.html">limit data to smaller word lengths</a>. If you open a VI on a target and the VI contains fixed-point data with larger word lengths than the target can accept, the VI contains broken wires. Refer to the documentation for a target to determine the maximum word length the target accepts.</li>
<li>
					<strong>Integer word length</strong>�The number of integer bits in the bit string that LabVIEW uses to represent all possible values of the fixed-point data, or, given an initial position to the left or right of the most significant bit, the number of bits to shift the binary point to reach the most significant bit. The integer word length can be larger than the word length, and can be positive or negative.</li>
</ul>
<p class="Body">LabVIEW displays this configuration in the following format in the <a href="../lvdialog/Context_Help_Window.html">Context Help</a> window when you move the cursor over a wire that carries fixed-point data:</p>
<p class="Body">
				<span class="Monospace-Bold">&lt;<em>encoding</em>, <em>word length</em>, <em>integer word length</em>&gt;</span>
			</p>
<p class="Body">For example:</p>
<p class="Body">
				<span class="Monospace-Bold">&lt;s, 16, 8&gt;</span> is a signed, 16-bit number with eight integer bits. The following image represents a signed number with a word length of 16 and an integer word length of 8.</p>
<p class="Anchor"><img src="noloc_eps_16_bit_word.gif"></p>
<table class="Bordered">
<tr>
<td class="Bordered">1</td>
<td class="Bordered">Word length (16 bits)</td>
</tr>
<tr>
<td class="Bordered">2</td>
<td class="Bordered">Integer word length (8 bits)</td>
</tr>
<tr>
<td class="Bordered">3</td>
<td class="Bordered">Sign bit</td>
</tr>
<tr>
<td class="Bordered">4</td>
<td class="Bordered">Binary point</td>
</tr>
</table>
<h4>Long or Negative Integer Word Lengths</h4>
<p class="Body">If the integer word length is larger than the word length, LabVIEW does not store the integer bits that exceed the word length. The following image represents a number with a word length of 8 and an integer word length of 10.</p>
<p class="Anchor"><img src="noloc_eps_iwl_long.gif"></p>
<table class="Bordered">
<tr>
<td class="Bordered">1</td>
<td class="Bordered">Word length (8 bits)</td>
</tr>
<tr>
<td class="Bordered">2</td>
<td class="Bordered">Integer word length (10 bits)</td>
</tr>
<tr>
<td class="Bordered">3</td>
<td class="Bordered">Integer bits not stored</td>
</tr>
<tr>
<td class="Bordered">4</td>
<td class="Bordered">Binary point</td>
</tr>
</table>
<p class="Body">If the integer word length is negative, LabVIEW does not store any integer bits and also does not store the number of fractional bits equal to the negative number, starting from the binary point. The following image represents a number with a word length of 8 and an integer word length of �2.</p>
<p class="Anchor"><img src="noloc_eps_iwl_negative.gif"></p>
<table class="Bordered">
<tr>
<td class="Bordered">1</td>
<td class="Bordered">Word length (8 bits)</td>
</tr>
<tr>
<td class="Bordered">2</td>
<td class="Bordered">Word length minus Integer word length (8 bits minus �2 bits)</td>
</tr>
<tr>
<td class="Bordered">3</td>
<td class="Bordered">Fractional bits not stored</td>
</tr>
<tr>
<td class="Bordered">4</td>
<td class="Bordered">Binary point</td>
</tr>
</table><a name="Range"></a><h4>Range</h4>
<p class="Body">LabVIEW calculates the range and delta for a fixed-point number according to the values you specify for the encoding of the fixed-point number.</p>
<ul>
<li>
					<strong>Minimum</strong>�The minimum value for the fixed-point data range.</li>
<li>
					<strong>Maximum</strong>�The maximum value for the fixed-point data range.</li>
<li>
					<strong>Delta</strong>�The increment between numbers within the specified range.</li>
</ul>
<p class="Body">LabVIEW expresses this configuration in the following format in the <a href="../lvdialog/Context_Help_Window.html">Context Help</a> window when you move the cursor over a wire that carries fixed-point data:</p>
<p class="Body">
				<span class="Monospace-Bold">[<em>Minimum</em>, <em>Maximum</em>]:<em>Delta</em></span>
			</p>
<p class="Body">For example:</p>
<p class="Body">
				<span class="Monospace-Bold">[�4, 4]:1</span> has a minimum value of �4, a maximum value of 4, and a delta of 1.</p><a name="FXP_arith"></a><h3>Fixed-Point Arithmetic</h3>
<p class="Body">
				
				When you perform an arithmetic operation on fixed-point numbers for which you specified a word length, the position of the binary point does not change from the position you specify before you run the VI. This behavior contrasts with floating-point numbers, where the position of the binary point or decimal point can shift at run time due to an arithmetic operation. If the result of an arithmetic operation requires a larger word length than the fixed-point configuration allows, you might lose data from the result of the operation.</p>
<p class="Body">LabVIEW adjusts the word length of output values of <a href="../glang/Numeric_Functions.html">Numeric</a> functions to avoid data loss, if possible. However, LabVIEW cannot avoid data loss if the word length required to represent the output value exceeds the maximum you specify or the LabVIEW maximum of 64 bits. To <a href="../lvhowto/configure_fxp_ops.html">configure output settings</a> for a Numeric function, right-click the function and select <strong>Properties</strong> from the shortcut menu to display the <strong>Numeric Node Properties</strong> dialog box.</p><a name="FXP_overflow"></a><h3>Overflow and Rounding</h3>
<p class="Body">
				
				
				Overflow and rounding conditions can occur when you perform an arithmetic operation on fixed-point numbers or when you use the <a href="../glang/to_fixed_point.html">To Fixed-Point</a> function to convert numeric data to fixed-point data. LabVIEW configures the outputs of Numeric functions to avoid overflow or rounding of fixed-point data, if possible. However, LabVIEW cannot avoid overflow or rounding under certain conditions.</p>
<p class="Body">
				For example, if you wire fixed-point values to Numeric functions such as <a href="../glang/Add.html">Add</a>, <a href="../glang/Subtract.html">Subtract</a>, <a href="../glang/Multiply.html">Multiply</a>, and <a href="../glang/Square.html">Square</a>, LabVIEW increases the word length of the output value to accommodate the result of the operation by default. This behavior is similar to the behavior of floating-point values. However, if avoiding overflow or rounding requires an output value that exceeds the maximum word length that LabVIEW accepts or the maximum word length that you specify, overflow or rounding conditions can occur. LabVIEW accepts a maximum word length of 64 bits.
			</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��If you wire fixed-point values to the <a href="../glang/Divide.html">Divide</a> function, the <a href="../glang/Reciprocal.html">Reciprocal</a> function, or the <a href="../glang/Square_Root.html">Square Root</a> function, rounding conditions always occur because the precision of the results can be infinite.</td>
</tr>
</table>
<p class="Body">Other conditions where overflow or rounding can occur include <a href="../lvhowto/cr_fixed_point.html">type cycles and values that you cannot represent</a> exactly in a  base-2 number system.</p><a name="overflow"></a><h4>Overflow</h4>
<p class="Body">Overflow occurs when the result of an operation is outside the range of values that the output type can represent. You can select between the following overflow modes to handle overflow:</p>
<ul>
<li>
					<strong>Saturate</strong>�If the value is greater than the maximum value in the desired range of the output type, LabVIEW coerces, or rounds, the value to the specified maximum. If the value is less than the minimum value in the desired range of the output type, LabVIEW coerces the value to the specified minimum.</li>
<li>
					<strong>Wrap</strong>�If the value is outside the desired range of the output type, LabVIEW discards significant bits of the value until the value is in the desired range of the output type. This option requires the output value to fit the encoding you specify. You cannot specify a desired range if you select this option, because LabVIEW automatically sets the range to fit the encoding.</li>
</ul>
<table class="checkFile lvfpgaconcepts">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��Typically, the Saturate mode requires additional hardware resources on an <a href="../lvfpgaconcepts/FPGAFixedPoint.html">FPGA</a>.</td>
</tr>
</table>
<p class="Body">To determine whether overflow occurs, you can <a href="../lvhowto/configure_fxp.html">configure a fixed-point number</a> to include an overflow status. When you include an overflow status in a fixed-point number, LabVIEW allocates additional storage space to track whether the fixed-point number is the result of an operation that overflowed. After you configure a fixed-point number to include an overflow status, you can <a href="../lvhowto/show_ov_led_fxp.html">display an overflow status LED</a> on fixed-point controls, constants, and indicators. This LED lights up when the overflow status of the fixed-point number is TRUE. You also can use the <a href="../glang/fxp_overflow.html">Fixed-Point Overflow?</a> function to determine the overflow status of a fixed-point number. Use the <a href="../glang/fxp_fxns.html">Fixed-Point</a> functions to manipulate the overflow status of a fixed-point number.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��LabVIEW does not check for underflow conditions on fixed-point numbers.</td>
</tr>
</table>
<p class="Body">When you use the <a href="../glang/Comparison_Functions.html">Comparison</a> functions to compare fixed-point numbers, LabVIEW ignores the overflow status and compares only the numbers. For example, if you use the <a href="../glang/Equal.html">Equal?</a> function to compare a fixed-point value of 1.5 with an overflow status of TRUE to a fixed-point value of 1.5 with no overflow status, LabVIEW returns TRUE.</p>
<p class="Body">To <a href="../lvhowto/configure_fxp_ops.html">configure output settings</a> for a Numeric function, right-click the function and select <strong>Properties</strong> from the shortcut menu to display the <strong>Numeric Node Properties</strong> dialog box. You can use this dialog box to configure how LabVIEW handles overflow and rounding conditions.</p><a name="FXP_quantization"></a><h4>Rounding</h4>
<p class="Body">
				
				Rounding occurs when the precision of the input value or the result of an operation is greater than the precision of the output type. LabVIEW coerces the input value to a value with the same precision as the output type. For example, assume the output type can represent the successive values <em>s</em> and <em>t</em>. If the result of an operation is the value <em>x</em>, and <em>x</em> is between <em>s</em> and <em>t</em> such that <em>s</em>&lt;<em>x</em>&lt;<em>t</em>, rounding occurs because the output type cannot represent <em>x</em> exactly.</p>
<p class="Body">You can select from the following rounding modes to handle rounding:</p>
<ul>
<li>
					<strong>Truncate</strong>�Rounds the value down to the nearest value that the output type can represent. LabVIEW discards the least significant bits of the value. This rounding mode has the best performance but also produces the least accurate output values.
							<br><br>For example, if the output value <em>x</em> falls between the successive values <em>s</em> and <em>t</em> such that
					<br><br><em>s</em>&lt;<em>x</em>&lt;<em>t</em>,
					<br><br>LabVIEW sets <em>x</em> to equal <em>s</em>.
				</li>
<li>
					<strong>Round-Half-Up</strong>�Rounds the value to the nearest value that the output type can represent. If the value to round is exactly between two valid values, this mode rounds the value up to the higher of the two valid values. LabVIEW adds half a least significant bit to the output value and then truncates the value. This rounding mode produces more accurate output values than truncate but also has a larger impact on performance.
							<br><br>For example, if the output value <em>x</em> falls between the successive values <em>s</em> and <em>t</em> such that
					<br><br><em>s</em>&lt;<em>x</em>&lt;<em>t</em>,
					<br><br>LabVIEW sets <em>x</em> to equal the closer of <em>s</em> or <em>t</em>. If <em>x</em> is exactly between <em>s</em> and <em>t</em>, LabVIEW selects <em>t</em>.
				</li>
<li>
					<strong>Round-Half-Even</strong>�Rounds the value to the nearest value that the output type can represent. If the value to round is exactly between two valid values, LabVIEW checks the bit of the value that becomes the least significant bit after rounding. If the bit is 0, this mode rounds the value to the lower of the two values that the output type can represent. If the bit is not 0, this mode rounds the value to the higher of the two values. This rounding mode has the largest impact on performance but produces more accurate output values than truncate. This mode also neutralizes the bias towards higher values that can occur when you perform multiple rounding operations that use the round-half-up mode. This is the default rounding mode.	<br><br>For example, if the output value <em>x</em> falls between the successive values <em>s</em> and <em>t</em> such that
					<br><br><em>s</em>&lt;<em>x</em>&lt;<em>t</em>,
					<br><br>LabVIEW sets <em>x</em> to equal the closer of <em>s</em> or <em>t</em>. If <em>x</em> is exactly between <em>s</em> and <em>t</em>, select <em>s</em> if the least significant bit after rounding is 0. Select <em>t</em> if the least significant bit after rounding is not 0.
				</li>
</ul>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The performance impact of any rounding mode is minimal. However, the performance impact can be significant if you run a VI that handles overflow on a target such as FPGA.</td>
</tr>
</table>
<p class="checkFile lvfpgaconcepts Body">Refer to <a href="../lvfpgaconcepts/FPGAFixedPoint.html">Using the Fixed-Point Data Type</a> for more information about performance impact on an FPGA.</p>
</body>
</html>