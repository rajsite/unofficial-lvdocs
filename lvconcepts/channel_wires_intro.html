<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from channel_wires.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Communicating Data between Parallel Sections of Code Using Channel Wires</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><h1>Communicating Data between Parallel Sections of Code Using Channel Wires</h1>
<p class="Body">
					
					
					
					
					
					
					
					
					
					A channel wire is a wire in LabVIEW that expresses an asynchronous communication between two parallel sections of code without forcing an execution order. Using a channel wire is similar to using a refnum or a variable that one loop writes into and the other loop reads from. Instead of using a refnum or a variable, you represent the data transfer graphically as a wire.</p>
<p class="Body">The following figure illustrates that you can use channel wires to build your block diagram to achieve the same functionality as using queue refnums.</p>
<p class="Anchor"><img src="loc_bd_channel_vs_queue.gif"></p>
<p class="Body">Every channel wire must have at least two endpoints: a writer and a reader. Endpoints are places in the code that exchange data. Writer endpoints write data to the channel. Reader endpoints read data from the channel. By connecting the writer endpoint to the reader endpoint using a channel wire, you enable asynchronous data communication between parallel sections of code.</p>
<p class="Body">LabVIEW provides the following channel templates that you can use to build applications. Each template expresses a different communications protocol. You can choose from the following templates based on your communications and application needs:</p>
<table class="Bordered">
<tr>
<th class="Bordered">LabVIEW</th>
<th class="Bordered">Real-Time Module</th>
<th class="Bordered">FPGA Module*</th>
</tr>
<tr>
<td class="Bordered"><a href="../glang/channel_stream.html">Stream</a><br><a href="../glang/channel_tag.html">Tag</a><br><a href="../glang/channel_messenger.html">Messenger</a><br><a href="../glang/channel_accumulator.html">Accumulator Tag</a><br><a href="../glang/channel_event_messenger.html">Event Messenger</a><br><a href="../glang/channel_hsstream.html">High Speed Stream</a><br><a href="../glang/channel_lossy_stream.html">Lossy Stream</a><br><a href="../glang/channel_one_element_stream.html">One Element Stream</a><br></td>
<td class="Bordered"><a href="../glang/channel_stream.html">Stream</a><br><a href="../glang/channel_tag.html">Tag</a><br><a href="../glang/channel_messenger.html">Messenger</a><br><a href="../glang/channel_accumulator.html">Accumulator Tag</a><br><a href="../glang/channel_event_messenger.html">Event Messenger</a><br><a href="../glang/channel_hsstream.html">High Speed Stream</a><br><a href="../glang/channel_lossy_stream.html">Lossy Stream</a><br><a href="../glang/channel_one_element_stream.html">One Element Stream</a><br><a href="../lvrtvihelp/channel_rt_stream.html" class="checkLink lvrtvihelp">Real Time Stream</a><br></td>
<td class="Bordered"><a href="../lvfpga/channel_stream_fpga.html" class="checkLink lvfpga">Stream</a><br><a href="../lvfpga/channel_tag_fpga.html" class="checkLink lvfpga">Tag</a><br><a href="../lvfpga/channel_accumulator_fpga.html" class="checkLink lvfpga">Accumulator Tag</a><br><a href="../lvfpga/channel_lossy_stream_fpga.html" class="checkLink lvfpga">Lossy Stream</a><br><a href="../lvfpga/channel_one_element_stream_fpga.html" class="checkLink lvfpga">One Element Stream</a><br></td>
</tr>
<tr>
<td colspan="3">*For each supported channel template, the FPGA Module supports only a subset of the endpoints.</td>
</tr>
</table>
<p class="Body">You can create a channel writer endpoint or a channel reader endpoint by right-clicking a terminal or a wire and selecting <strong>Create�Channel Writer</strong> or <strong>Create�Channel Reader</strong>. In the Select Channel Endpoint dialog box that appears, you can switch between writer or reader endpoints by clicking <strong>Switch Read/Write</strong>. When you create an endpoint from a terminal, you instantiate the channel template with that data type as its transmission type.</p>
<p class="Body">All Stream channels are not forkable, which means they connect a single writer endpoint to a single reader endpoint. All the other channels are forkable to allow multiple writers or multiple readers on the same channel.</p><a name="understanding_lifetime_of_channels"></a><h2>Understanding the Lifetime of Channels</h2>
<p class="Body">The calling block diagram of a channel governs the channel execution. A calling block diagram is the lowest level block diagram that contains all endpoints of a channel or all the nodes that call those endpoints.</p>
<p class="Body">A channel initializes when its calling block diagram begins running. A channel closes when the <strong>last element?</strong> or <strong>abort</strong> input on one of its endpoints is TRUE. If a channel closes, it ignores further writes to the channel. The channel reinitializes when its calling block diagram begins another run. A calling block diagram can be a structure node, the top-level block diagram of a VI, or a higher level block diagram that calls the current top-level VI.</p>
<p class="Body">In the following figure, the calling block diagram of the channel is the top-level diagram of this VI. The channel initializes when the calling block diagram begins running, which means the channel initializes each time the top-level VI begins running or each time the top-level VI is called as a subVI.</p>
<p class="Anchor"><img src="loc_bd_channel_wires_lifetime1.gif"></p>
<p class="Body">In the following figure, the calling block diagram of the channel is the While Loop. The channel initializes when the While Loop begins running, which means the channel initializes on each iteration of the While Loop.</p>
<p class="Anchor"><img src="loc_bd_channel_wires_lifetime2.gif"></p>
<p class="Body">In the following figure, the calling block diagram of the channel is not the top-level VI but is higher than the current top-level block diagram. The channel initializes when the higher level block diagram begins running, which means the channel initializes each time the higher level block diagram begins running or each time the higher level block diagram is called as a subVI. The channel does not act upon the iterations of the While Loop to initialize because the While Loop does not contain all the endpoints of the channel.</p>
<p class="Anchor"><img src="loc_bd_channel_wires_lifetime3.gif"></p>
<p class="Body">In all the channel instances above, the Write endpoint writes the first three values to the channel but ignores the final two values because the <strong>last element?</strong> input is TRUE when the number of elements left unwritten in the array equals to 2.</p><a name="advantages_of_channels"></a><h2>Advantages of Channel Wires Compared to Refnums and Variables</h2>
<p class="Body">Using channel wires provides the following benefits:</p>
<ul>
<li>Channel wires do not require you to create and destroy refnums like queues.</li>
<li>Channel wires require fewer nodes on the block diagram than queues.</li>
<li>Channel wires show where the data flows to and from, which makes them more visible and easier to debug than refnums and variables.</li>
<li>Channel wires can incorporate stop and abort signals with your data, which makes your application less error prone than creating such signals using refnums and variables.</li>
<li>Channel wires allow you to create co-routines that fill the role of <em>closures</em> in other programming languages. Refer to the <span class="Monospace">labview\examples\Channels\Replacing The Function At The Heart Of An Algorithm At Run Time\Replacing The Function At The Heart Of An Algorithm At Run Time.lvproj</span> for an example of using channel wires to create co-routines.
			<br><br>
				<a href="javascript:openProj('examples%5C%5CChannels%5C%5CReplacing%20The%20Function%20At%20The%20Heart%20Of%20An%20Algorithm%20At%20Run%20Time%5C%5CReplacing%20The%20Function%20At%20The%20Heart%20Of An%20Algorithm%20At%20Run%20Time.lvproj');"><img src="open.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Open example�
		
				<a href="javascript:findExamples(3097);"><img src="find.gif" border="0" style="padding-bottom: 4px; vertical-align: middle"></a> Find related examples</li>
</ul>
</body>
</html>