<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Using_LV_to_Create_Multithrded_VIs_for_Max_Perf.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Multithreading Programming Examples</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Multithreading_Programming_Examples"></a><h1>Multithreading Programming Examples</h1>
<p class="Body">
				
				In Example 1, a data acquisition program in C creates and synchronizes the separate threads for acquiring, processing, and displaying the data by using events. Managing the threads and events comprises much of the main program. If the program needs additional threads, you must determine if they can be synchronized in the same way as the current simple program, if synchronization is even necessary, or if you must code another synchronization event structure to incorporate the additional tasks.</p><a name="Example_1_Multithreaded_Data_Acquisition_Program_in_C"></a><h2>Example 1: Multithreaded Data Acquisition Program in C</h2>
<p class="Code"><span class="Monospace">#include &lt;windows.h&gt;
 </span></p>
<p class="Code"><span class="Monospace">#include &lt;winbase.h&gt;
 </span></p>
<p class="Code"><span class="Monospace">#include &lt;stdio.h&gt;
			</span></p>
<p class="Code"><span class="Monospace">#include "nidaq.h"����������������/* for NI-DAQ function prototypes */
			</span></p>
<p class="Code"><span class="Monospace">#include "nidaqcns.h"�������������/* for NI-DAQ constants */
 </span></p>
<p class="Code"><span class="Monospace">#include "nidaqerr.h"�������������/* for NI-DAQ error codes */
 </span></p>
<p class="Code"><span class="Monospace">#include "dsp.h"������������������/* for Analysis prototype */
 </span></p>
<p class="Code"><span class="Monospace">// Global buffers to transfer data between threads.
 </span></p>
<p class="Code"><span class="Monospace">#define kNPts 1024</span></p>
<p class="Code"><span class="Monospace">static i16 gAcquireOut[kNPts];����// acquire
 </span></p>
<p class="Code"><span class="Monospace">static double gProcessArr[kNPts];�// process
 </span></p>
<p class="Code"><span class="Monospace">static double gSaveArr[kNPts];����// save
 </span></p>
<p class="Code"><span class="Monospace">// Acquire and Save helper functions.</span></p>
<p class="Code"><span class="Monospace">int InitAcquire(void);
 </span></p>
<p class="Code"><span class="Monospace">void FinishAcquire(void);
 </span></p>
<p class="Code"><span class="Monospace">int InitSave(void);
 </span></p>
<p class="Code"><span class="Monospace">void FinishSave(void);
 </span></p>
<p class="Code"><span class="Monospace">// Structure passed to each thread.</span></p>
<p class="Code"><span class="Monospace">typedef struct {
 </span></p>
<p class="Code"><span class="Monospace">�������int kind;
 </span></p>
<p class="Code"><span class="Monospace">�������HANDLE doneEvent;
 </span></p>
<p class="Code"><span class="Monospace">�������HANDLE waitEvent;
 </span></p>
<p class="Code"><span class="Monospace">} SyncRec;</span></p>
<p class="Code"><span class="Monospace">// List of threads.</span></p>
<p class="Code"><span class="Monospace">enum { kAcquireThread, kProcessThread, kDisplayThread, kChildren };</span></p>
<p class="Code"><span class="Monospace">// Thread synchronization process and the actual work procedure.</span></p>
<p class="Code"><span class="Monospace">DWORD WINAPI ThreadShell(LPVOID arg);</span></p>
<p class="Code"><span class="Monospace">void DoAcquire(void);</span></p>
<p class="Code"><span class="Monospace">void DoProcess(void);</span></p>
<p class="Code"><span class="Monospace">void DoSave(void);</span></p>
<p class="Code"><span class="Monospace">volatile BOOL gExitThreads = FALSE;</span></p>
<p class="Code"><span class="Monospace">volatile int gAcqFailed = 0;������// set to TRUE if the acquisition failed</span></p>
<p class="Code"><span class="Monospace">volatile int gProcessFailed = 0;��// set to TRUE if the process failed</span></p>
<p class="Code"><span class="Monospace">volatile int gSaveFailed = 0;�����// set to TRUE if the save failed</span></p>
<p class="Code"><span class="Monospace">main()</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������int i, j, k;
 </span></p>
<p class="Code"><span class="Monospace">�������char buf[256];
 </span></p>
<p class="Code"><span class="Monospace">�������DWORD id;
 </span></p>
<p class="Code"><span class="Monospace">�������HANDLE shellH, evArr[kChildren];
 </span></p>
<p class="Code"><span class="Monospace">�������SyncRec kidsEv[kChildren];
 </span></p>
<p class="Code"><span class="Monospace">�������printf("Initializing acquire\n");
 </span></p>
<p class="Code"><span class="Monospace">�������// Create synchronization events and threads.
 </span></p>
<p class="Code"><span class="Monospace">�������for (i = 0; i &lt; kChildren; i++) {
 </span></p>
<p class="Code"><span class="Monospace">��������������// Set info for this thread.
 </span></p>
<p class="Code"><span class="Monospace">��������������kidsEv[i].kind = i;
 </span></p>
<p class="Code"><span class="Monospace">��������������evArr[i] = kidsEv[i].doneEvent
 = CreateEvent(NULL, FALSE, FALSE, NULL);
 </span></p>
<p class="Code"><span class="Monospace">��������������kidsEv[i].waitEvent = CreateEvent(NULL,
 FALSE, FALSE, NULL);
 </span></p>
<p class="Code"><span class="Monospace">��������������shellH = CreateThread(NULL, 0,
 ThreadShell, &amp;kidsEv[i], 0, &amp;id);
 </span></p>
<p class="Code"><span class="Monospace">��������������if (! (kidsEv[i].doneEvent &amp;&amp; kidsEv[i].waitEvent &amp;&amp; shellH)) {
 </span></p>
<p class="Code"><span class="Monospace">���������������������printf("Couldn't create events and threads\n");</span></p>
<p class="Code"><span class="Monospace">���������������������ExitProcess(1);</span></p>
<p class="Code"><span class="Monospace">��������������}
 </span></p>
<p class="Code"><span class="Monospace">�������}
 </span></p>
<p class="Code"><span class="Monospace">�������if (InitAcquire() &amp;&amp; InitSave()) {
 </span></p>
<p class="Code"><span class="Monospace">��������������printf("Starting acquire\n");</span></p>
<p class="Code"><span class="Monospace">��������������for (j = 0; (j &lt; 10) &amp;&amp;
 !gAcqFailed &amp;&amp; !gProcessFailed &amp;&amp; !gSaveFailed;</span></p>
<p class="Code"><span class="Monospace">�����������������j++) {
 </span></p>
<p class="Code"><span class="Monospace">���������������������// Tell children to stop waiting.</span></p>
<p class="Code"><span class="Monospace">���������������������for (i = 0; i &lt; kChildren; i++)</span></p>
<p class="Code"><span class="Monospace">����������������������������SetEvent(kidsEv[i].waitEvent);</span></p>
<p class="Code"><span class="Monospace">���������������������// Wait until all children are done.</span></p>
<p class="Code"><span class="Monospace">���������������������WaitForMultipleObjects(kChildren, evArr, TRUE, INFINITE);</span></p>
<p class="Code"><span class="Monospace">���������������������// Main thread coordination goes here...</span></p>
<p class="Code"><span class="Monospace">���������������������// Copy from process buffer to save buffer.</span></p>
<p class="Code"><span class="Monospace">���������������������memcpy(gSaveArr, gProcessArr, sizeof(gSaveArr));</span></p>
<p class="Code"><span class="Monospace">���������������������// Copy from acquire buffer to process buffer.</span></p>
<p class="Code"><span class="Monospace">���������������������for (k = 0; k &lt; kNPts; k++)</span></p>
<p class="Code"><span class="Monospace">����������������������������gProcessArr[k] = (double) gAcquireOut[k];
 </span></p>
<p class="Code"><span class="Monospace">��������������}
 </span></p>
<p class="Code"><span class="Monospace">��������������printf("Acquire finished\n");
 </span></p>
<p class="Code"><span class="Monospace">�������}
 </span></p>
<p class="Code"><span class="Monospace">�������// Tell children to stop executing.
 </span></p>
<p class="Code"><span class="Monospace">�������gExitThreads = TRUE;
 </span></p>
<p class="Code"><span class="Monospace">�������// Release children from wait.
 </span></p>
<p class="Code"><span class="Monospace">�������for (i = 0; i &lt; kChildren; i++)
 </span></p>
<p class="Code"><span class="Monospace">��������������SetEvent(kidsEv[i].waitEvent);
 </span></p>
<p class="Code"><span class="Monospace">�������// Clean up.
 </span></p>
<p class="Code"><span class="Monospace">�������FinishAcquire();
 </span></p>
<p class="Code"><span class="Monospace">�������FinishSave();
 </span></p>
<p class="Code"><span class="Monospace">�������// Do (minimal) error reporting.
 </span></p>
<p class="Code"><span class="Monospace">�������if (gAcqFailed)
 </span></p>
<p class="Code"><span class="Monospace">��������������printf("Acquire of data failed\n");
 </span></p>
<p class="Code"><span class="Monospace">�������if (gProcessFailed)
 </span></p>
<p class="Code"><span class="Monospace">��������������printf("Processing of data failed\n");
 </span></p>
<p class="Code"><span class="Monospace">�������if (gSaveFailed)
 </span></p>
<p class="Code"><span class="Monospace">��������������printf("Saving data failed\n");
 </span></p>
<p class="Code"><span class="Monospace">�������// Acknowledge finish.
 </span></p>
<p class="Code"><span class="Monospace">�������printf("Cleanup finished. Hit &lt;ret&gt; to end...\n");
 </span></p>
<p class="Code"><span class="Monospace">�������gets(buf);
 </span></p>
<p class="Code"><span class="Monospace">�������return 0;
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">/*</span></p>
<p class="Code"><span class="Monospace">A shell for each thread to handle all the event</span></p>
<p class="Code"><span class="Monospace">synchronization. Each thread knows what to do by</span></p>
<p class="Code"><span class="Monospace">the kind field in SyncRec structure.</span></p>
<p class="Code"><span class="Monospace">*/</span></p>
<p class="Code"><span class="Monospace">DWORD WINAPI ThreadShell(LPVOID arg)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������SyncRec *ev = (SyncRec *) arg;
 </span></p>
<p class="Code"><span class="Monospace">�������DWORD res;
 </span></p>
<p class="Code"><span class="Monospace">�������while (1) {
 </span></p>
<p class="Code"><span class="Monospace">��������������// Wait for main thread to tell
 us to go.
 </span></p>
<p class="Code"><span class="Monospace">��������������res = WaitForSingleObject(ev-&gt;waitEvent,
 INFINITE);
 </span></p>
<p class="Code"><span class="Monospace">��������������if (gExitThreads) break;
 </span></p>
<p class="Code"><span class="Monospace">��������������// Call work procedure.
 </span></p>
<p class="Code"><span class="Monospace">��������������switch (ev-&gt;kind) {
 </span></p>
<p class="Code"><span class="Monospace">���������������������case kAcquireThread: DoAcquire(); break;</span></p>
<p class="Code"><span class="Monospace">���������������������case kProcessThread: DoProcess(); break;</span></p>
<p class="Code"><span class="Monospace">���������������������case kDisplayThread: DoSave(); break;</span></p>
<p class="Code"><span class="Monospace">���������������������default:</span></p>
<p class="Code"><span class="Monospace">����������������������������printf("Unknown thread kind!\n");</span></p>
<p class="Code"><span class="Monospace">����������������������������ExitProcess(2);
 </span></p>
<p class="Code"><span class="Monospace">��������������}
 </span></p>
<p class="Code"><span class="Monospace">��������������// Let main thread know we're done.
 </span></p>
<p class="Code"><span class="Monospace">��������������SetEvent(ev-&gt;doneEvent);
 </span></p>
<p class="Code"><span class="Monospace">�������}
 </span></p>
<p class="Code"><span class="Monospace">�������return 0;
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">// DAQ Section ---------------------------------------------------</span></p>
<p class="Code"><span class="Monospace">#define kBufferSize (2*kNPts)</span></p>
<p class="Code"><span class="Monospace">static i16 gAcquireBuffer[kBufferSize] = {0};</span></p>
<p class="Code"><span class="Monospace">static i16 gDevice = 1;</span></p>
<p class="Code"><span class="Monospace">static i16 gChan = 1;</span></p>
<p class="Code"><span class="Monospace">#define kDBModeON 1</span></p>
<p class="Code"><span class="Monospace">#define kDBModeOFF 0</span></p>
<p class="Code"><span class="Monospace">#define kPtsPerSecond 0</span></p>
<p class="Code"><span class="Monospace">/*</span></p>
<p class="Code"><span class="Monospace">Initialize the acquire. Return TRUE if we succeeded.</span></p>
<p class="Code"><span class="Monospace">*/</span></p>
<p class="Code"><span class="Monospace">int InitAcquire(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������i16 iStatus = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������i16 iGain = 1;
 </span></p>
<p class="Code"><span class="Monospace">�������f64 dSampRate = 1000.0;
 </span></p>
<p class="Code"><span class="Monospace">�������i16 iSampTB = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������u16 uSampInt = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������i32 lTimeout = 180;
 </span></p>
<p class="Code"><span class="Monospace">�������int result = 1;
 </span></p>
<p class="Code"><span class="Monospace">�������/*
 </span></p>
<p class="Code"><span class="Monospace">�������This sets a timeout limit (#Sec * 18ticks/Sec) so that if there
 </span></p>
<p class="Code"><span class="Monospace">�������is something wrong, the program won't hang on the DAQ_DB_Transfer
 </span></p>
<p class="Code"><span class="Monospace">�������call.
 </span></p>
<p class="Code"><span class="Monospace">�������*/
 </span></p>
<p class="Code"><span class="Monospace">�������iStatus = Timeout_Config(gDevice, lTimeout);
 </span></p>
<p class="Code"><span class="Monospace">��������������result = result &amp;&amp; (iStatus
 &gt;= 0);
 </span></p>
<p class="Code"><span class="Monospace">�������/*
 </span></p>
<p class="Code"><span class="Monospace">�������Convert sample rate (S/sec) to appropriate timebase and sample
 </span></p>
<p class="Code"><span class="Monospace">�������interval values.
 </span></p>
<p class="Code"><span class="Monospace">�������*/
 </span></p>
<p class="Code"><span class="Monospace">�������iStatus = DAQ_Rate(dSampRate, kPtsPerSecond, &amp;iSampTB, &amp;uSampInt);
 </span></p>
<p class="Code"><span class="Monospace">��������������result = result &amp;&amp; (iStatus
 &gt;= 0);
 </span></p>
<p class="Code"><span class="Monospace">�������/* Turn ON software double-buffered mode. */
 </span></p>
<p class="Code"><span class="Monospace">�������iStatus = DAQ_DB_Config(gDevice, kDBModeON);
 </span></p>
<p class="Code"><span class="Monospace">��������������result = result &amp;&amp; (iStatus
 &gt;= 0);
 </span></p>
<p class="Code"><span class="Monospace">�������/*
 </span></p>
<p class="Code"><span class="Monospace">�������Acquire data indefinitely into circular buffer from a single channel.
 </span></p>
<p class="Code"><span class="Monospace">�������*/
 </span></p>
<p class="Code"><span class="Monospace">�������iStatus = DAQ_Start(gDevice, gChan, iGain, gAcquireBuffer, kBufferSize, iSampTB, uSampInt);
 </span></p>
<p class="Code"><span class="Monospace">��������������result = result &amp;&amp; (iStatus
 &gt;= 0);
 </span></p>
<p class="Code"><span class="Monospace">��������������gAcqFailed = !result;
 </span></p>
<p class="Code"><span class="Monospace">��������������return result;
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">void FinishAcquire(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������/* CLEANUP - Don't check for errors on purpose. */
 </span></p>
<p class="Code"><span class="Monospace">�������(void) DAQ_Clear(gDevice);
 </span></p>
<p class="Code"><span class="Monospace">�������/* Set DB mode back to initial state. */
 </span></p>
<p class="Code"><span class="Monospace">�������(void) DAQ_DB_Config(gDevice, kDBModeOFF);
 </span></p>
<p class="Code"><span class="Monospace">�������/* Disable timeouts. */
 </span></p>
<p class="Code"><span class="Monospace">�������(void) Timeout_Config(gDevice, -1);
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">void DoAcquire(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������i16 iStatus = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������i16 hasStopped = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������u32 nPtsOut = 0;
 </span></p>
<p class="Code"><span class="Monospace">�������iStatus = DAQ_DB_Transfer(gDevice,
 gAcquireOut, &amp;nPtsOut, &amp;hasStopped);
 </span></p>
<p class="Code"><span class="Monospace">�������gAcqFailed = (iStatus &lt; 0);
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">// Analysis Section ----------------------------------------------</span></p>
<p class="Code"><span class="Monospace">void DoProcess(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������int err;
 </span></p>
<p class="Code"><span class="Monospace">�������/* Perform power spectrum on the data. */
 </span></p>
<p class="Code"><span class="Monospace">�������err = Spectrum(gProcessArr, kNPts);
 </span></p>
<p class="Code"><span class="Monospace">�������gProcessFailed = (err != 0);
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">// Save Section --------------------------------------------------</span></p>
<p class="Code"><span class="Monospace">static HANDLE*gSaveFile;�������/* output file pointer */</span></p>
<p class="Code"><span class="Monospace">/*</span></p>
<p class="Code"><span class="Monospace">Initialize save information. Return TRUE if we succeed.</span></p>
<p class="Code"><span class="Monospace">*/</span></p>
<p class="Code"><span class="Monospace">int InitSave(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������gSaveFile = CreateFile("data.out", GENERIC_WRITE, 0,
 </span></p>
<p class="Code"><span class="Monospace">��������������NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
 NULL);
 </span></p>
<p class="Code"><span class="Monospace">�������gSaveFailed = gSaveFile == INVALID_HANDLE_VALUE;
 </span></p>
<p class="Code"><span class="Monospace">�������return !gSaveFailed;
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">void FinishSave(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������CloseHandle(gSaveFile);
 </span></p>
<p class="Code"><span class="Monospace">}</span></p>
<p class="Code"><span class="Monospace">void DoSave(void)</span></p>
<p class="Code"><span class="Monospace">{
 </span></p>
<p class="Code"><span class="Monospace">�������DWORD nWritten;
 </span></p>
<p class="Code"><span class="Monospace">�������BOOL succeeded;
 </span></p>
<p class="Code"><span class="Monospace">�������succeeded = WriteFile(gSaveFile, gSaveArr, sizeof(gSaveArr), &amp;nWritten, NULL);
 </span></p>
<p class="Code"><span class="Monospace">�������if (!succeeded || nWritten != sizeof(gSaveArr))
 </span></p>
<p class="Code"><span class="Monospace">�������gSaveFailed = 1;
 </span></p>
<p class="Code"><span class="Monospace">}
 </span></p><a name="Example_2_G_Code_Equivalent_of_C_Code_in_Example_1"></a><h2>Example 2: G Code Equivalent of C Code in Example 1</h2>
<p class="Anchor"><img src="loc_bd_parallelprocess.gif"></p>
<p class="Body">The Parallel Process VI contains no additional code for threading because multithreading is built into LabVIEW. All the threads or tasks on the block diagram are synchronized each iteration of the loop. As you add functionality to the LabVIEW VI, LabVIEW handles the thread management automatically.</p>
<p class="Body">LabVIEW resolves most of the thread management difficulties. You do not have to create and control threads, because LabVIEW can recognize opportunities for multithreading in VIs, and the execution system handles multithreading communications for you. LabVIEW chooses a multithreaded configuration for the application, or you can customize configurations and priorities by selecting <strong>File�VI Properties</strong> and selecting <strong>Execution</strong> in the <a href="../lvdialog/VI_Properties_Dialog_Box.html">VI Properties</a> dialog box. Priority settings automatically translate to set operating system priorities for the multiple threads. You can choose different thread configurations to optimize for data acquisition, instrument control, or other custom configurations. Experimentation in creating multithreading VIs in LabVIEW sometimes yields the best solution. However, if you use C or other text-based languages, rewriting the application to experiment with different configurations can take too much time and effort for the possible rewards.</p>
<p class="Body">LabVIEW set in multithreaded execution mode manages threads automatically. With LabVIEW, you do not have to be an expert to write multithreaded applications. However, you can still choose custom priorities and configurations if you need more control. Although C users have more low-level direct control of individual threads, they face a more complex set of issues when creating multithreaded applications.</p>
</body>
</html>