<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from Polymorphic_Functions.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Polymorphic Functions</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Polymorphic_Functions"></a><h1>Polymorphic Functions</h1>
<p class="Body">
				
				
				Polymorphism is the ability of VIs and functions to automatically adapt to accept input data of different data types. Functions are polymorphic to varying degrees�none, some, or all of their inputs can be polymorphic. Some function inputs accept numeric values or Boolean values. Some accept numeric values or strings. Some accept not only scalar numeric values but also arrays of numeric values, clusters of numeric values, arrays of clusters of numeric values, and so on. Some accept only one-dimensional arrays although the array elements can be of any type. Some functions accept all types of data, including complex numeric values. You also can create and use <a href="Polymorphic_Units_in_LabVIEW.html">polymorphic units</a>.</p><a name="Numeric_Conversion"></a><h2>Numeric Conversion</h2>
<p class="Body">
				
				
				
				You can convert any numeric representation to any other numeric representation. When you wire two or more numeric inputs of different representations to a function, the function usually returns the data in the larger, or wider, representation. The functions coerce the smaller representations to the widest representation before execution and LabVIEW places a <a href="../lvconcepts/Coercion_Dots.html">coercion dot</a> on the terminal where the conversion takes place.
			</p>
<p class="Body">Some functions, such as <a href="../glang/Divide.html">Divide</a>, <a href="../glang/Sine.html">Sine</a>, and <a href="../glang/Cosine.html">Cosine</a>, produce floating-point output by default. If you wire integers to their inputs, these functions convert the integers to double-precision, floating-point numbers before performing the calculation. However, you can <a href="../lvhowto/configure_fxp_ops.html">configure most Numeric functions</a> to return a data type you specify.</p>
<p class="Body">For floating-point, scalar quantities, it is usually best to use double-precision, floating-point numbers. Single-precision, floating-point numbers save little or no run time and <a href="Block_Diagram_Objects.html#Symbolic_Numeric_Values">overflow</a> much more easily. The analysis libraries, for example, use double-precision, floating-point numbers. You should only use extended-precision, floating-point numbers when necessary. The performance and precision of extended-precision arithmetic varies among the platforms.</p>
<p class="Body">For integers, it is usually best to use a 32-bit signed integer.</p>
<p class="Body">
				If you wire an output to a destination that has a different numeric representation, LabVIEW converts the data according to the following rules:</p>
<ul>
<li>
					<strong>Signed or unsigned integer to floating-point number</strong>�LabVIEW converts the data to the nearest value possible. This conversion is exact when the floating-point number is more precise than the integer. If the integer is more precise than the floating-point number, LabVIEW maintains as much precision as possible in the conversion.</li>
<li>
					<strong>Floating-point number to signed or unsigned integer</strong>�LabVIEW moves out-of-range values to the integer's minimum or maximum value. Most integer objects, such as the iteration terminal of a For Loop, round floating-point numbers. LabVIEW rounds a fractional part of 0.5 to the nearest even integer. For example, LabVIEW rounds 6.5 to 6 rather than 7.</li>
<li><strong>LabVIEW treats enums as unsigned integers</strong>�For example, if you convert �1, a floating-point number, to an enum, LabVIEW coerces the value into the range of the enum. If the range of the enum is 0 to 25, LabVIEW converts the value to 0.
</li>
<li>
					<strong>Integer to integer</strong>�LabVIEW does not move out-of-range values to the integer's minimum or maximum value. If the source is smaller than the destination, LabVIEW extends the sign of a signed source and places zeros in the extra bits of an unsigned source. If the source is larger than the destination, LabVIEW copies only the least significant bits of the value.</li>
<li>
					<strong>Integer, floating-point, or fixed-point  number to fixed-point number</strong>�LabVIEW coerces values outside the desired range for the fixed-point number to within the fixed-point number's maximum and minimum values.</li>
</ul><a name="Polymorphism_for_Numeric_Functions"></a><h2>Polymorphism for Numeric Functions</h2>
<p class="Body">			
				The arithmetic functions take numeric input data. With some exceptions noted in the function descriptions, the default output has the same numeric representation as the input or, if the inputs have different representations, the default output is the larger of the inputs. For example, if you add an 8-bit integer and a 16-bit integer, the default output is a 16-bit integer. If you configure the output of a <a href="../glang/Numeric_Functions.html">Numeric</a> function, the settings you specify override the default behavior.</p>
<p class="Body">The arithmetic functions work on numbers, arrays of numbers, clusters of numbers, arrays of clusters of numbers, complex numbers, and so on. A formal and recursive definition of the allowable input type is as follows:</p>
<p class="Body">
				<em>Numeric type</em> = numeric scalar OR array [<em>numeric type</em>] OR cluster [<em>numeric types</em>]</p>
<p class="Body">The numeric scalars can be floating-point numbers, integers, or complex floating-point numbers. LabVIEW does not allow you to use arrays of arrays.</p>
<p class="Body">Arrays can have any number of dimensions of any size. Clusters can have any number of elements. The output type of functions is of the same numeric representation as the input type. For functions with one input, the functions operate on each element of the array or cluster.</p>
<p class="Body">For functions with two inputs, you can use the following input combinations:</p>
<ul>
<li>
					<strong>Similar</strong>�Both inputs have the same structure, and the output has the same structure as the inputs.</li>
<li>
					<strong>One scalar</strong>�One input is a numeric scalar, the other is an array or cluster, and the output is an array or cluster.</li>
<li>
					<strong>Array of</strong>�One input is a numeric array, the other is the numeric type itself, and the output is an array.</li>
</ul>
<p class="Body">For similar inputs, LabVIEW performs the function on the respective elements of the structures. For example, LabVIEW can add two arrays element by element. Both arrays must have the same dimensionality. You can add arrays with differing numbers of elements; the output of such an addition has the same number of elements as the smallest input. Clusters must have the same number of elements, and the respective elements must be of the same type.</p>
<p class="Body">For operations involving a scalar and an array or cluster, LabVIEW performs the function on the scalar and the respective elements of the structure. For example, LabVIEW can subtract a number from all elements of an array, regardless of the dimensionality of the array.</p>
<p class="Body">For operations that involve a numeric type and an array of that type, LabVIEW performs the function on each array element. For example, a graph is an array of points, and a point is a cluster of two numeric types, <em>x</em> and <em>y</em>. To offset a graph by 5 units in the <em>x</em> direction and 8 units in the <em>y</em> direction, you can add a point, (5, 8), to the graph.</p>
<p class="Body">The following illustration shows the possible polymorphic combinations of the Add function.</p>
<p class="Anchor"><img src="loc_eps_addfnply.gif"></p><a name="Polymorphism_for_Boolean_Functions"></a><h2>Polymorphism for Boolean Functions</h2>
<p class="Body">			
The logical functions accept Boolean input data, numeric input data, and error clusters. If the input is numeric, LabVIEW performs a bitwise operation. If the input is an integer, the output has the same representation. If the input is a floating-point number, LabVIEW rounds it to a 32-bit integer, and the output is a 32-bit integer. If the input is an error cluster, LabVIEW passes only the TRUE or FALSE value of the <strong>status</strong> parameter of the error cluster to the input terminal.</p>
<p class="Body">The logical functions work on arrays of numbers or Boolean values, clusters of numbers or Boolean values, arrays of clusters of numbers or Boolean values, and so on. </p>
<p class="Body">A formal and recursive definition of the allowable input type is as follows:</p>
<p class="Body">
				<em>Logical type</em> = Boolean scalar OR numeric scalar OR array [<em>logical type</em>] OR cluster [<em>logical types</em>] </p>
<p class="Body">except that complex numbers and arrays of arrays are not allowed.</p>
<p class="Body">Logical functions with two inputs can have the same input combinations as the arithmetic functions. However, the logical functions have the further restriction that the base operations can only be between two Boolean values or two numbers. For example, you cannot have an AND between a Boolean value and a number. The following illustration shows some combinations of Boolean values for the AND function.</p>
<p class="Anchor"><img src="loc_eps_boolpoly.gif"></p><a name="Polymorphism_for_Array_Functions"></a><h2>Polymorphism for Array Functions</h2>
<p class="Body">			
Most of the array functions accept <em>n</em>-dimensional arrays of any type. However, the wiring diagrams in the function descriptions show numeric arrays as the default data type. </p><a name="Polymorphism_for_String_Functions"></a><h2>Polymorphism for String Functions</h2>
<p class="Body">			

				<a href="../glang/String_Length.html">String Length</a>, <a href="../glang/To_Upper_Case.html">To Upper Case</a>, <a href="../glang/To_Lower_Case.html">To Lower Case</a>, <a href="../glang/Reverse_String.html">Reverse String</a>, and <a href="../glang/Rotate_String.html">Rotate String</a> accept strings, clusters and arrays of strings, and arrays of clusters. To Upper Case and To Lower Case also accept numbers, clusters of numbers, and arrays of numbers, interpreting them as ASCII codes for characters. Width and precision inputs must be scalar. </p><a name="Polymorphism_for_String_Conversion_Functions"></a><h3>Polymorphism for String Conversion Functions</h3>
<p class="Body">The <a href="../glang/Path_to_String.html">Path To String</a> and <a href="../glang/String_To_Path.html">String To Path</a> functions are polymorphic. That is, they work on scalar values, arrays of scalars, clusters of scalars, arrays of clusters of scalars, and so on. The output has the same composition as the input but with the new type.</p><a name="Polymorphism_for_Additional_String_to_Number_Functions"></a><h3>Polymorphism for Additional String to Number Functions</h3>
<p class="Body">Number To Decimal String, Number To Hex String, Number To Octal String, Number To Engineering String, Number To Fractional String, and Number To Exponential String accept clusters and arrays of numbers and produce clusters and arrays of strings. Decimal String To Number, Hexadecimal String To Number, Octal String To Number, and Fract/Exp String To Number accept clusters and arrays of strings and produce clusters and arrays of numbers. Width and precision inputs must be scalar.</p><a name="Polymorphism_for_Cluster_Functions"></a><h2>Polymorphism for Cluster Functions</h2>
<p class="Body">			
The <a href="../glang/Bundle.html">Bundle</a> and <a href="../glang/Unbundle.html">Unbundle</a> functions do not show the data type for their individual input or output terminals until you wire objects to these terminals. When you wire them, these terminals look similar to the data types of the corresponding front panel control or indicator terminals. </p><a name="Polymorphism_for_Comparison_Functions"></a><h2>Polymorphism for Comparison Functions</h2>
<p class="Body">			
The <a href="../glang/Comparison_Functions.html">Comparison</a> functions <a href="../glang/Equal.html">Equal?</a>, <a href="../glang/Not_Equal.html">Not Equal?</a>, and <a href="../glang/Select.html">Select</a> take inputs of any type, as long as the inputs are the same type. </p>
<p class="Body">The functions <a href="../glang/Greater_Or_Equal.html">Greater Or Equal?</a>, <a href="../glang/Less_Or_Equal.html">Less Or Equal?</a>, <a href="../glang/Less.html">Less?</a>, <a href="../glang/Greater.html">Greater?</a>, <a href="../glang/Max_and_Min.html">Max &amp; Min</a>, and <a href="../glang/In_Range_and_Coerce.html">In Range and Coerce</a> take inputs of any type except complex, path, or refnum, as long as the inputs are the same type. You can compare numbers, strings, Boolean values, arrays of strings, clusters of numbers, clusters of strings, and so on. However, you cannot compare a number to a string or a string to a Boolean value, and so on. </p>
<p class="Body">The functions that compare values to zero accept numeric scalars, clusters, and arrays of numbers. These functions output Boolean values in the same data structure as the input.</p>
<p class="Body">The <a href="../glang/Not_A_Number_Path_Refnum.html">Not A Number/Path/Refnum?</a> function accepts the same input types as functions that compare values to zero. This function also accepts paths and refnums. Not A Number/Path/Refnum? outputs Boolean values in the same data structure as the input.</p>
<p class="Body">The functions <a href="../glang/Decimal_Digit.html">Decimal Digit?</a>, <a href="../glang/Hex_Digit.html">Hex Digit?</a>, <a href="../glang/Octal_Digit.html">Octal Digit?</a>, <a href="../glang/Printable.html">Printable?</a>, and <a href="../glang/White_Space.html">White Space?</a> accept a scalar string or number input, clusters of strings or non-complex numbers, arrays of strings or non-complex numbers, and so on. The output consists of Boolean values in the same data structure as the input.</p>
<p class="Body">The function <a href="../glang/Empty_String_Path.html">Empty String/Path?</a> accepts a path, a scalar string, clusters of strings, arrays of strings, and so on. The output consists of Boolean values in the same data structure as the input. </p>
<p class="Body">You can use the Equal?, Not Equal?, Not A Number/Path/Refnum?, Empty String/Path?, and Select functions with paths and refnums, but no other Comparison functions accept paths or refnums as inputs.</p>
<p class="Body">Comparison functions that accept arrays and clusters normally return Boolean arrays and clusters of the same structure. If you want the function to return a single Boolean value, right-click the function and select <strong>Comparison Mode�Compare Aggregates</strong> from the shortcut menu to <a href="Comparison_Funcs.html#Comparing_Arrays_and_Clusters">compare aggregates</a>.</p><a name="Polymorphism_for_Log_Functions"></a><h2>Polymorphism for Logarithmic Functions</h2>
<p class="Body">
				The <a href="../glang/Logarithmic_Functions.html">Logarithmic</a> functions take numeric input data. If the input is an integer, the output is a double-precision, floating-point number. Otherwise, the output has the same numeric representation as the input.</p>
<p class="Body">These functions work on numbers, arrays of numbers, clusters of numbers, arrays of clusters of numbers, complex numbers, and so on. A formal and recursive definition of the allowable input type is as follows:</p>
<p class="Body">
				<em>Numeric type</em> = numeric scalar OR array [<em>numeric type</em>] OR cluster [<em>numeric types</em>] </p>
<p class="Body">except that arrays of arrays are not allowed.</p>
<p class="Body">Arrays can be any size and can have any number of dimensions. Clusters can have any number of elements. The output type is of the same numeric representation as the input, and the functions operate on each element of the cluster or array. Allowable input type combinations for the <a href="Polymorphic_Functions.html#Polymorphism_for_Numeric_Functions">two-input Logarithmic
 functions</a> include the following:</p>
<ul>
<li>
					<strong>Similar</strong>�Both inputs have the same structure, and the output has the same structure as the inputs.</li>
<li>
					<strong>One scalar</strong>�One input is a numeric scalar, the other is a numeric array or cluster, and the output is an array or cluster.
				</li>
</ul>
</body>
</html>