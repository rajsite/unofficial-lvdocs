<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- Generated from LabVIEW_Data_Storage.xml. Edit in the XML file; do not edit this file.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">

<title>Type Descriptors in LabVIEW 7.x and Earlier</title>
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script><script src="expandable_tree.js" type="text/javascript"></script>
<link rel="STYLESHEET" type="text/css" href="expandable_tree.css"><script src="dynamicjumps.js" type="text/javascript"></script></head>
<body>
<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript><a name="Old_Type_Descriptors"></a><h1>Type Descriptors in LabVIEW 7.x and Earlier</h1>
<p class="Body">
				LabVIEW associates each wire and terminal on the block diagram with a data type. LabVIEW keeps track of this type with a structure in memory called a type descriptor. This type descriptor is a sequence of 16-bit integers that can describe any data type in LabVIEW. Numeric values are written in hexadecimal format, unless otherwise noted.</p>
<table class="Borderless">
<tr>
<td class="Icon"><img src="note.gif"></td>
<td><strong>Note</strong>��The format in which LabVIEW stores type descriptors changed in LabVIEW 8.0. LabVIEW 7.<em>x</em> and earlier <a href="../lvconcepts/Old_Type_Descriptors.html">store type descriptors in 16-bit flat representation</a>. This information applies if you use the <strong>Convert 7.x Data</strong> mode of the Flatten To String function. The following information reflects how LabVIEW stores type descriptors in LabVIEW 7.<em>x</em> and earlier.</td>
</tr>
</table>
<p class="Body">The generic format of a type descriptor in LabVIEW 7.<em>x</em> and earlier is</p>
<p class="Body">
				<span class="Monospace">&lt;length&gt; &lt;type code&gt;</span>
			</p>
<p class="Body">Some type descriptors have additional information following the type code. Arrays and clusters are structured or aggregate data types because they include other types. For example, the cluster type contains additional information about the type of each of its elements.</p>
<p class="Body">The first word (16 bits) in any type descriptor is the length, in bytes, of that type descriptor, including the length word. The second word (16 bits) is the type code. LabVIEW reserves the high-order byte of the type code (the <em>xx</em> in the following tables) for internal use. When comparing two type descriptors for equality, you should ignore this byte. Two type descriptors are equal even if the high-order bytes of the type codes are not.</p>
<p class="Body">The type code encodes the actual type information, such as single-precision or extended-precision, floating-point number, as listed in the following table. These type code values might change in future versions of LabVIEW.</p><a name="Data_Types"></a><h2>Data Types</h2>
<p class="Body">The following tables list numeric and non-numeric data types, type codes, and type descriptors.</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Data Type
					</th>
<th class="Bordered">
						Type Code (numbers in hexadecimal)
					</th>
<th class="Bordered">
						Type Descriptor (numbers in hexadecimal)
					</th>
</tr>
<tr>
<td class="Bordered">
<p class="Body">8-bit Integer</p>
</td>
<td class="Bordered">
						01</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>01</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">16-bit Integer</p>
</td>
<td class="Bordered">
						02</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>02</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">32-bit Integer</p>
</td>
<td class="Bordered">
						03</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>03</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">64-bit Integer</p>
</td>
<td class="Bordered">
						04</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>04</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Unsigned 8-bit Integer</p>
</td>
<td class="Bordered">
						05</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>05</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Unsigned 16-bit Integer</p>
</td>
<td class="Bordered">
						06</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>06</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Unsigned 32-bit Integer</p>
</td>
<td class="Bordered">
						07</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>07</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Unsigned 64-bit Integer</p>
</td>
<td class="Bordered">
						08</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>08</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Single-Precision Floating-Point Number</p>
</td>
<td class="Bordered">
						09</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>09</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Double-Precision Floating-Point Number</p>
</td>
<td class="Bordered">
						0A</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>0A</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Extended-Precision Floating-Point Number</p>
</td>
<td class="Bordered">
						0B</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>0B</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Single-Precision Complex Floating-Point Number</p>
</td>
<td class="Bordered">
						0C</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>0C</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Double-Precision Complex Floating-Point Number</p>
</td>
<td class="Bordered">
						0D</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>0D</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Extended-Precision Complex Floating-Point Number</p>
</td>
<td class="Bordered">
						0E</td>
<td class="Bordered">
<p class="Body">0005 <em>xx</em>0E</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Enumerated 8-bit Integer</p>
</td>
<td class="Bordered">
						15</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>15 &lt;k&gt; &lt;k pstrs&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Enumerated 16-bit Integer</p>
</td>
<td class="Bordered">
						16</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>16 &lt;k&gt; &lt;k pstrs&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Enumerated 32-bit Integer</p>
</td>
<td class="Bordered">
						17</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>17 &lt;k&gt; &lt;k pstrs&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Single-Precision Physical Quantity</p>
</td>
<td class="Bordered">
						19</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>19 &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Double-Precision Physical Quantity</p>
</td>
<td class="Bordered">
						1A</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>1A &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Extended-Precision Physical Quantity</p>
</td>
<td class="Bordered">
						1B</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>1B &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Single-Precision Complex Physical Quantity</p>
</td>
<td class="Bordered">
						1C</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>1C &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Double-Precision Complex Physical Quantity</p>
</td>
<td class="Bordered">
						1D</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>1D &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Extended-Precision Complex Physical Quantity</p>
</td>
<td class="Bordered">
						1E</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>1E &lt;k&gt; &lt;k base-exp&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered" colspan="3">
<p class="Body">n=length; <em>x</em>=reserved; k=number; k pstrs=number of Pascal strings; k base-exp=number of <a href="#Physical_Quantity">base-exponent pairs</a>. </p>
</td>
</tr>
</table>
<p class="Body">
				<br>
				<br>
			</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Data Type
					</th>
<th class="Bordered">
						Type Code (numbers in hexadecimal)
					</th>
<th class="Bordered">
						Type Descriptor (numbers in hexadecimal)
					</th>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Boolean</p>
</td>
<td class="Bordered">
						21</td>
<td class="Bordered">
<p class="Body">0004 <em>xx</em>21</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">String</p>
</td>
<td class="Bordered">
						30</td>
<td class="Bordered">
<p class="Body">0008 <em>xx</em>30 &lt;dim&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Path</p>
</td>
<td class="Bordered">
						32</td>
<td class="Bordered">
<p class="Body">0008 <em>xx</em>32 &lt;dim&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Picture</p>
</td>
<td class="Bordered">
						33</td>
<td class="Bordered">
<p class="Body">0008 <em>xx</em>33 &lt;dim&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Array</p>
</td>
<td class="Bordered">
						40</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>40 &lt;k&gt; &lt;k dims&gt; &lt;element type descriptor&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Cluster</p>
</td>
<td class="Bordered">
						50</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>50 &lt;k&gt; &lt;k element type descriptors&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Waveform</p>
</td>
<td class="Bordered">
						54</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>54 &lt;waveform type&gt; &lt;element type descriptors&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Refnum</p>
</td>
<td class="Bordered">
						70</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; &lt;refnum type code&gt;&lt;specific type code information&gt;</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Variant</p>
</td>
<td class="Bordered">
						53</td>
<td class="Bordered">
<p class="Body">&lt;nn&gt; <em>xx</em>53</p>
</td>
</tr>
<tr>
<td class="Bordered" colspan="3">
<p class="Body">n=length; <em>x</em>=reserved; k=number; k pstrs=number of Pascal strings; k base-exp=number of base-exponent pairs. A dim is a 32-bit integer. The following sections provide examples of data and type descriptors.</p>
</td>
</tr>
</table>
<p class="Body">The minimum value in the size field of a type descriptor is 4, as shown in the previous table. However, any type descriptor can have a name (a Pascal string) appended, in which case the size field is larger by the length of the name rounded up to a multiple of two.</p><a name="Enumerated_8-Bit_Integer"></a><h2>Enumerated 8-Bit Integer</h2>
<p class="Body">In the following example of an enumerated 8-bit integer for the items <span class="Monospace">am</span>, <span class="Monospace">fm</span>, and <span class="Monospace">fm stereo</span>, each group of characters represents a 16-bit word. The space enclosed in quotation marks (<span class="Monospace">"�"</span>) represents an ASCII space.</p>
<p class="Body">
				<span class="Monospace">0016 0015 0003 02a m02 fm 09f m"�"�st�er�eo</span>
			</p>
<p class="Body">
				<span class="Monospace">0016</span> indicates 22 bytes total. <span class="Monospace">0015</span> indicates an enumerated 8-bit integer. <span class="Monospace">0003</span> indicates there are three items.</p><a name="Physical_Quantity"></a><h2>Physical Quantity</h2>
<p class="Body">In the following example of a double-precision physical quantity with units m/s, each group represents a 16-bit word.</p>
<p class="Body">
				<span class="Monospace">000E 001A 0002 0002 FFFF 0003 0001</span>
			</p>
<p class="Body">
				<span class="Monospace">000E</span> indicates 14 bytes total. <span class="Monospace">001A</span> indicates this is a double-precision physical quantity. <span class="Monospace">0002</span> indicates two base-exponent pairs. <span class="Monospace">0002</span> denotes the seconds base index. <span class="Monospace">FFFF (�1)</span> is the exponent of seconds. <span class="Monospace">0003</span> denotes the meters base index. <span class="Monospace">0001</span> is the exponent of meters.</p>
<p class="Body">LabVIEW stores all physical quantities internally in terms of base units, regardless of the units used to display them.</p>
<p class="Body">The following table shows the nine bases that are represented by indexes 0 through 8 for radians through candela.</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Quantity Name
					</th>
<th class="Bordered">
						Unit
					</th>
<th class="Bordered">
						Abbreviation
					</th>
<th class="Bordered">
						Base Value
					</th>
</tr>
<tr>
<td class="Bordered">
<p class="Body">plane angle</p>
</td>
<td class="Bordered">
						radian</td>
<td class="Bordered">
						rad</td>
<td class="Bordered">
						0</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">solid angle</p>
</td>
<td class="Bordered">
						steradian</td>
<td class="Bordered">
						sr</td>
<td class="Bordered">
						1</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">time</p>
</td>
<td class="Bordered">
						second</td>
<td class="Bordered">
						s</td>
<td class="Bordered">
						2</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">length</p>
</td>
<td class="Bordered">
						meter</td>
<td class="Bordered">
						m</td>
<td class="Bordered">
						3</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">mass</p>
</td>
<td class="Bordered">
						kilogram</td>
<td class="Bordered">
						kg</td>
<td class="Bordered">
						4</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">electric current</p>
</td>
<td class="Bordered">
						ampere</td>
<td class="Bordered">
						A</td>
<td class="Bordered">
						5</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">thermodynamic temperature</p>
</td>
<td class="Bordered">
						kelvin</td>
<td class="Bordered">
						K</td>
<td class="Bordered">
						6</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">amount of substance</p>
</td>
<td class="Bordered">
						mole</td>
<td class="Bordered">
						mol</td>
<td class="Bordered">
						7</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">luminous intensity</p>
</td>
<td class="Bordered">
						candela</td>
<td class="Bordered">
						cd</td>
<td class="Bordered">
						8</td>
</tr>
</table><a name="String_Path_and_Pict_Data_Types"></a><h2>String, Path, and Picture Data Types</h2>
<p class="Body">The string, path, and picture data types have a 32-bit length, similar to the array dimension size. However, the only value currently encoded is <span class="Monospace">FFFFFFFF (�1)</span>, which indicates variable sized. Currently, all strings, paths, and pictures are variable sized. The actual length is stored with the data.</p><a name="Array_and_Cluster_Data_Types"></a><h2>Array and Cluster Data Types</h2>
<p class="Body">The array and cluster data types each have their own type code. They also contain additional information about the data types of their elements and the dimensionality for arrays or number of elements for clusters.</p><a name="Array"></a><h2>Array</h2>
<p class="Body">The type code for an array is 40. A word that contains the number of dimensions of the array immediately follows the type code. Then, for each dimension, a 32-bit integer contains the size in elements of that dimension. Finally, after all of the dimension sizes, the type descriptor for the element appears. The element type can be any type except an array. Currently all sizes are <span class="Monospace">FFFFFFFF (�1)</span>, which means the array dimension size is variable. LabVIEW stores the actual dimension size, which is always greater than or equal to zero, with the data. The following example is a type descriptor for a 1D array of double-precision floating-point numbers:</p>
<p class="Body">
				<span class="Monospace">000E 0040 0001 FFFF FFFF 0004 000A</span>
			</p>
<p class="Body">
				<span class="Monospace">000E</span> is the length of the entire type descriptor, including the element type descriptor. The array is variable sized, so the dimension size is <span class="Monospace">FFFFFFFF</span>. The element type descriptor (<span class="Monospace">0004 000A</span>) appears exactly as it does for a scalar of the same type.</p>
<p class="Body">The following example is a type descriptor for a 2D array of Boolean values:</p>
<p class="Body">
				<span class="Monospace">0012 0040 0002 FFFF FFFF FFFF FFFF 0004 0021</span>
			</p><a name="Cluster"></a><h2>Cluster</h2>
<p class="Body">The type code for a cluster is 50. A word that contains the number of items in the cluster immediately follows the type code. The type descriptor for each element in <em>cluster order</em> follows this word. For example, consider a cluster of two integers, a 16-bit signed integer and a 32-bit unsigned integer:</p>
<p class="Body">
				<span class="Monospace">000E 0050 0002 0004 0002 0004 0007</span>
			</p>
<p class="Body">
				<span class="Monospace">000E</span> is the length of the type descriptor including the element type descriptors.</p>
<p class="Body">Because array and cluster type descriptors contain other type descriptors, they might become deeply nested. For example, the following is a type descriptor for a multi-plot graph. The numeric types can vary.</p>
<p class="Body">
				<span class="Monospace">0028 0040 0001 FFFF FFFF...</span>1D array of</p>
<p class="Body">
				<span class="Monospace">001E 0050 0001...</span>1 component cluster of </p>
<p class="Body">
				<span class="Monospace">0018 0040 0001 FFFF FFFF...</span>1D array of</p>
<p class="Body">
				<span class="Monospace">000E 0050 0002...</span>2 component cluster of </p>
<p class="Body">
				<span class="Monospace">0004 000A...</span>double-precision floating-point number </p>
<p class="Body">
				<span class="Monospace">0004 0003...</span>32-bit integer</p><a name="Waveform"></a><h2>Waveform</h2>
<p class="Body">The type code for a waveform is 54. A word that contains the type of waveform immediately follows the type code. The type descriptor of the cluster of the waveforms elements follows this word. There are five categories of waveforms:</p>
<ul>
<li>Analog</li>
<li>Digital</li>
<li>Digital Data</li>
<li>Time Stamp</li>
<li>Dynamic</li>
</ul>
<p class="Body">The following table lists the types of analog waveforms.</p>
<table class="Bordered">
<tr>
<th class="Bordered">
						Type
					</th>
<th class="Bordered">
						Subtype Code
					</th>
</tr>
<tr>
<td class="Bordered">
<p class="Body">8-bit signed</p>
</td>
<td class="Bordered">14</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">16-bit signed</p>
</td>
<td class="Bordered">2</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">32-bit signed</p>
</td>
<td class="Bordered">15</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">64-bit signed</p>
</td>
<td class="Bordered">
<p class="Body">19</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Double-Precision</p>
</td>
<td class="Bordered">3</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Single-Precision</p>
</td>
<td class="Bordered">5</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Extended-Precision</p>
</td>
<td class="Bordered">10</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">8-bit unsigned</p>
</td>
<td class="Bordered">11</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">16-bit unsigned</p>
</td>
<td class="Bordered">12</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">32-bit unsigned</p>
</td>
<td class="Bordered">13</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">64-bit unsigned</p>
</td>
<td class="Bordered">
<p class="Body">20</p>
</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Complex Single-Precision</p>
</td>
<td class="Bordered">16</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Complex Double-Precision</p>
</td>
<td class="Bordered">17</td>
</tr>
<tr>
<td class="Bordered">
<p class="Body">Complex Extended-Precision</p>
</td>
<td class="Bordered">18</td>
</tr>
</table>
<p class="Body">For example, consider a double-precision waveform:</p>
<p class="Body">0086 0054 0003...size of waveform, followed by type and subtype code</p>
<p class="Body">0080 0050 0005...size of cluster, cluster code, and number of elements</p>
<p class="Body">&lt;type descriptor of time stamp&gt;</p>
<p class="Body">&lt;type descriptor of <em>dt</em>&gt;</p>
<p class="Body">&lt;type descriptor of array of element type&gt;</p>
<p class="Body">&lt;type descriptor of unused error cluster&gt;</p>
<p class="Body">&lt;type descriptor of attributes&gt;</p>
<p class="Body">The type descriptor of the other types of analog waveforms is similar to the double-precision waveform. The difference is a different type for the array element and a different subtype.</p>
<h2>Digital Waveform and Digital Data</h2>
<p class="Body">The digital waveform is the only type of waveform that has a subtype code 8.</p>
<p class="Body">For example,</p>
<p class="Body">00B6 0054 0008...size of digital waveform, type code and subtype code</p>
<p class="Body">00B0 0050 0005...size of cluster, cluster code and number of elements</p>
<p class="Body">&lt;type descriptor of time stamp&gt;</p>
<p class="Body">&lt;type descriptor of <em>dt</em>&gt;</p>
<p class="Body">&lt;type descriptor of digital data&gt;</p>
<p class="Body">&lt;type descriptor of unused error cluster&gt;</p>
<p class="Body">&lt;type descriptor of attributes&gt;</p>
<p class="Body">Digital data is the only data type with a waveform type code and a subtype code of 7.</p>
<p class="Body">For example,</p>
<p class="Body">003E 0054 0007...size of digital data, type code and subtype code</p>
<p class="Body">0038 0050 0002...size of cluster, cluster code and number of elements.</p>
<p class="Body">&lt;type descriptor of transitions&gt;</p>
<p class="Body">&lt;type descriptor of data&gt;</p>
<h2>Time Stamp</h2>
<p class="Body">The time stamp has a subtype code of 6. The time stamp is a 128-bit fixed-point number. LabVIEW stores a time stamp as a cluster of four integers where the first two integers (64 bits) represent the number of whole seconds after 12:00 a.m., Friday, January 1, 1904, Universal Time [01-01-1904 00:00:00]. The next two integers (64 bits) represent the fractions of seconds.</p>
<p class="Body">001C 0054 0006 0016 0050 0004 0004 0003, 0004 0003, 0004 0003, 0004 0003</p>
<p class="Body">09...size of dynamic waveform, type code subtype</p>
<p class="Body">0096 0050 0001...cluster of one element</p>
<p class="Body">0090 0040 0001 FFFF FFFF...array of one element </p>
<p class="Body">&lt;type descriptor of an analog waveform&gt;</p>
</body>
</html>