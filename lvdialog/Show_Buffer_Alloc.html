<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<!--Generated from database. Edit in the database; do not edit this file.-->
<!--Dialog id="201"-->
<title>Show Buffer Allocations Window</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="STYLESHEET" type="text/css" href="minimal.css">
<script src="common.js" type="text/javascript"></script>
</head>

<body bgcolor="#ffffff">

<noscript>
<p class="Body">JavaScript is disabled. <a href="../lvhelp/JavaScript_Disabled.html">Details</a></p>
<hr width="100%" noshade>
</noscript>

<h1>Show Buffer Allocations Window</h1>
<p class="Body"><strong>Requires:</strong> Base Development System</p>

<p class="Body">Select <strong>Tools&#0187;Profile&#0187;Show Buffer Allocations</strong> to display this window.</p>
<p class="Body">Use this window to identify specific areas on the block diagram where LabVIEW allocates memory space in the form of a buffer.</p>
<p class="Body"><!-- begin parent: ../lvconcepts/LabVIEW_Performance_and_Memory_Management.xml-->Place a checkmark next to the <a href="../lvhowto/Numeric_Data_Types_Table.html">data type</a> you want to see buffers for and click the <strong>Refresh</strong> button. The black squares that appear on the block diagram indicate where LabVIEW creates buffers to allocate space for data.</p>
<p class="Body">The amount of memory LabVIEW allocates for each buffer is the same size as the top-level data size of the object for which LabVIEW allocates the buffer. For a 32-bit integer, the top-level data size is 4 bytes. For an array, the top-level data size is the size of a single pointer, which is 4 bytes on 32-bit platforms and 8 bytes on 64-bit platforms, regardless of the type of array. For clusters, the top-level data size is equal to the sum of the top-level data sizes for all the elements inside the cluster. When you run a VI, LabVIEW might or might not use the allocated buffers to store data. You cannot know whether LabVIEW makes a copy of the data because LabVIEW makes that decision at run time or the VI might depend on dynamic data.</p>
<p class="Body">If the VI needs memory for a buffer allocation, LabVIEW makes a data copy for the buffer. If LabVIEW is not sure whether the buffer needs a data copy, LabVIEW sometimes still makes a copy for the buffer.<!-- end parent: ../lvconcepts/LabVIEW_Performance_and_Memory_Management.xml--></p>
<table class="Borderless"><tr><td class="Icon"><img src="note.gif"></td><td>If your VI is broken, no black squares appear.</td></tr></table>
<p class="Body">Once you know where LabVIEW creates buffers, you might be able to optimize the performance of the VI by editing it to reduce the <a href="../lvconcepts/VI_Memory_Usage.html">amount of memory</a> LabVIEW requires to run the VI.</p>
<p class="Body">This window includes the following components:</p><ul>
<li><strong>Arrays</strong>&#8212;Displays buffers for <a href="../lvhowto/Arrays_howto.html">arrays</a> on the block diagram. If you want to reduce the amount of memory LabVIEW requires to run the VI, avoid displaying large arrays on open front panels if possible. Indicators on open front panels retain a copy of the data they display. Also, avoid overusing global and local variables when working with arrays. Reading a global or local variable causes LabVIEW to generate a copy of the data.</li>
<li><strong>Clusters</strong>&#8212;Displays buffers for <a href="../lvhowto/Clusters_howto.html">clusters</a> on the block diagram. If you want to reduce the amount of memory LabVIEW requires to run the VI, avoid using hierarchical data structures, such as clusters or arrays of clusters that contain large arrays or strings because LabVIEW cannot manipulate these structures efficiently and might cause a VI to use more memory.</li>
<li><strong>Strings</strong>&#8212;Displays buffers for <a href="../lvconcepts/FP_Controls_Indicators.html">strings</a> on the block diagram. If you want to reduce the amount of memory required to run the VI, avoid displaying large strings on open front panels when possible. Indicators on open front panels retain a copy of the data they display. Also, avoid overusing global and local variables when working with large strings. Reading a global or local variable causes LabVIEW to generate a copy of the data.</li>
<li><strong>Paths</strong>&#8212;Displays buffers for <a href="../lvconcepts/FP_Controls_Indicators.html">paths</a> on the block diagram.</li>
<li><strong>Scalars</strong>&#8212;Displays buffers for <a href="../lvhowto/Numeric_Data_Types_Table.html">scalar values</a> on the block diagram.</li>
<li><strong>Variants</strong>&#8212;Displays buffers for <a href="../lvhowto/Variants.html">variant values</a> on the block diagram.</li>
<li><strong>All other types</strong>&#8212;Displays buffers for <a href="../lvconcepts/Block_Diagram_Objects.html#Control_and_Indicator_Data_Types">all data types</a> not listed above.</li>
<li><strong>Dynamic dispatch temporaries</strong>&#8212;Configures the dynamic dispatch subVIs to display temporary buffer allocations. This occurs when the original ancestor implementation VI does not modify the input value, but the descendant implementation VI invoked at run-time does modify the input value. The temporary buffer allocations do not indicate a copy occurs, only that a copy might occur.</li>
<li><strong>Refresh</strong>&#8212;Displays black squares on the block diagram to show the buffers for the data type(s) you select. If you make a change to a VI that requires LabVIEW to recompile the VI, the black squares disappear because the buffer information might no longer be correct. Click the <strong>Refresh</strong> button to recompile the VI and display the black squares.</li></ul>
</body>
</html>